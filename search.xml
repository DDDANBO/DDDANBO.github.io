<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F04%2F14%2Fzong-zhang%2F</url>
    <content type="text"><![CDATA[@[TOC] 第一章 常用算法杂项 第二章 C语言程序设计 第三章 数据结构基本操作 预定义常量和类型 1234567891011//函数结果状态代码#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2//Status是函数的类型，其值是函数结果状态代码typedef int Status;typedef int ElemType; Visit遍历函数 12345Status Visit(ElemType c)&#123; printf("%d ",c); return OK;&#125; 自定义Scanf函数 自定义的数据录入函数，用于从文件fp中读取格式化的输入。 与fscanf不同之处在于此函数只会读取西文字符，对于中文字符，则会跳过。 形参部分可以使用省略号 ==C++==允许定义形参个数和类型不确定的函数。例如，C语言中的标准函数printf便使用这种机制。在声明不确定形参的函数时，==形参部分可以使用省略号“…”代替。==“…”告诉编译器，在函数调用时不检查形参类型是否与实参类型相同，也不检查参数个数。 即省略参数：用省略号…表示, ==省略号出现的地方可以有任意个任意类型的参数。==例如常用的printf函数： int printf (const char *format, …); 引用 &lt;stdarg.h&gt; 头文件的va_list、va_start、va_arg、va_end 例如： void ConnectData(int i,...); 在上面的代码中，编译器只检查第一个参数是否为整型，而不对其他参数进行检查。 对于可变参数的函数，需要进行特殊的处理。首先需要==引用 &lt;stdarg.h&gt; 头文件==，然后利用va_list类型和va_start、va_arg、va_end 3个宏读取传递到函数中的参数值。 12&gt; #include &lt;stdarg.h&gt; //提供宏va_list、va_start、va_arg、va_end&gt; 这几个宏的定义如下（在 ANSI C 中）： 1234&gt; type va_arg( va_list arg_ptr, type );&gt; void va_end( va_list arg_ptr );&gt; void va_start( va_list arg_ptr, prev_param ); &gt; va_start函数 va_start函数将参数arg_ptr设置为可变参数列表的第一个参数。参数arg_ptr的类型必须为va_list。参数prev_param是在可变参数列表之前的那一个参数。（也就是说在 ANSI C 中，如果一个函数有可变参数，那么在该可变参数前必须有一个明确定义的参数，否则无法调用函数 va_start ，例如函数 int add(int i,...）是合法的，而函数 int add(...)是不合法的。） va_arg函数 va_arg函数将返回 arg_ptr 所指位置的值，并将 arg_ptr 指向下一个参数 va_end函数 检索完所有参数后，va_end将指针重置为NULL。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100int Scanf(FILE *fp, char *format, ...)&#123; int *i; char *ch, *s; float *f; int count, k, len, n; int tmp; va_list ap; len = strlen(format); va_start(ap, format); for(count=0,k=2; k&lt;=len; k=k+2) &#123; while((tmp=getc(fp))!=EOF) //跳过所有非西文字符 &#123; if((tmp&gt;=0 &amp;&amp; tmp&lt;=127)) &#123; ungetc(tmp, fp); //遇到首个西文字符，将此西文字符放入输入流 break; &#125; &#125; if(tmp==EOF) break; if(format[k-1]=='c') //读取字符 &#123; ch = va_arg(ap, char*); if(tmp!=EOF) count += fscanf(fp, "%c", ch); &#125; if(format[k-1]=='d') //读取整型 &#123; i = va_arg(ap, int*); while((tmp=getc(fp))!=EOF) &#123; if((tmp&gt;='0' &amp;&amp; tmp&lt;='9') || tmp=='-' || tmp=='+') &#123; ungetc(tmp, fp); break; &#125; &#125; if(tmp!=EOF) count += fscanf(fp, "%d", i); &#125; if(format[k-1]=='f') //读取浮点型 &#123; f = va_arg(ap, float*); while((tmp=getc(fp))!=EOF) &#123; if((tmp&gt;='0' &amp;&amp; tmp&lt;='9') || tmp=='-' || tmp=='+'|| tmp=='.' ) &#123; ungetc(tmp, fp); break; &#125; &#125; if(tmp!=EOF) count += fscanf(fp, "%f", f); &#125; if(format[k-1]=='s') //读取字符串 &#123; s = va_arg(ap, char*); while((tmp=getc(fp))!=EOF &amp;&amp; (!isprint(tmp) || tmp==' ')) ; n = 0; if(!feof(fp)) &#123; ungetc(tmp, fp); while((tmp=getc(fp))!=EOF) &#123; if(isprint(tmp) &amp;&amp; tmp!=' ') s[n++] = tmp; else break; &#125; ungetc(tmp, fp); &#125; s[n] = '\0'; count++; &#125; &#125; va_end(ap); return count;&#125; 顺序线性表（数组） 类型定义 12345typedef struct&#123; ElemType data[MAXSIZE]; /* 数组，存储数据元素 */ int length; /* 线性表当前长度 */&#125;SqList; 初始化顺序线性表 12345Status InitList(SqList *L) &#123; L-&gt;length=0; return OK;&#125; 判断顺序表是否为空 1234567Status ListEmpty(SqList L)&#123; if(L.length==0) return TRUE; else return FALSE;&#125; 清空顺序表 12345Status ClearList(SqList *L)&#123; L-&gt;length=0; return OK;&#125; 计算顺序表的长度 1234int ListLength(SqList L)&#123; return L.length;&#125; 用e返回L中第i个数据元素的值 12345678Status GetElem(SqList L,int i,ElemType *e)&#123; if(L.length==0 || i&lt;1 || i&gt;L.length) return ERROR; *e=L.data[i-1]; return OK;&#125; 返回L中第1个与e满足关系的数据元素的位序 123456789101112131415int LocateElem(SqList L,ElemType e)&#123; int i; if (L.length==0) return 0; for(i=0;i&lt;L.length;i++) &#123; if (L.data[i]==e) break; &#125; if(i&gt;=L.length) return 0; return i+1;&#125; 在L中第i个位置之前插入新的数据元素e 123456789101112131415161718Status ListInsert(SqList *L,int i,ElemType e)&#123; int k; if (L-&gt;length==MAXSIZE) /* 顺序线性表已经满 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length+1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */ return ERROR; if (i&lt;=L-&gt;length) /* 若插入数据位置不在表尾 */ &#123; for(k=L-&gt;length-1;k&gt;=i-1;k--) /* 将要插入位置之后的数据元素向后移动一位 */ L-&gt;data[k+1]=L-&gt;data[k]; &#125; L-&gt;data[i-1]=e; /* 将新元素插入 */ L-&gt;length++; return OK;&#125; 删除L的第i个数据元素，并用e返回其值 12345678910111213141516Status ListDelete(SqList *L,int i,ElemType *e) &#123; int k; if (L-&gt;length==0) /* 线性表为空 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length) /* 删除位置不正确 */ return ERROR; *e=L-&gt;data[i-1]; if (i&lt;L-&gt;length) /* 如果删除不是最后位置 */ &#123; for(k=i;k&lt;L-&gt;length;k++)/* 将删除位置后继元素前移 */ L-&gt;data[k-1]=L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; 遍历顺序线性表 12345678Status ListTraverse(SqList L)&#123; int i; for(i=0;i&lt;L.length;i++) visit(L.data[i]); printf("\n"); return OK;&#125; 合并La、Lb两个顺序线性表 12345678910111213void unionL(SqList *La,SqList Lb)&#123; int La_len,Lb_len,i; ElemType e; La_len=ListLength(*La); Lb_len=ListLength(Lb); for (i=1;i&lt;=Lb_len;i++) &#123; GetElem(Lb,i,&amp;e); if (!LocateElem(*La,e)) ListInsert(La,++La_len,e); &#125;&#125; 静态链表（数组） 类型定义 12345typedef struct &#123; ElemType data; int cur; /* 游标(Cursor) ，为0时表示无指向 */&#125; Component,StaticLinkList[MAXSIZE]; 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针 12345678Status InitList(StaticLinkList space) &#123; int i; for (i=0; i&lt;MAXSIZE-1; i++) space[i].cur = i+1; space[MAXSIZE-1].cur = 0; /* 目前静态链表为空，最后一个元素的cur为0 */ return OK;&#125; 若备用空间链表非空，则返回分配的结点下标，否则返回0 12345678910int Malloc_SSL(StaticLinkList space) &#123; int i = space[0].cur; /* 当前数组第一个元素的cur存的值 */ /* 就是要返回的第一个备用空闲的下标 */ if (space[0]. cur) space[0]. cur = space[i].cur; /* 由于要拿出一个分量来使用了， */ /* 所以我们就得把它的下一个 */ /* 分量用来做备用 */ return i;&#125; 将下标为k的空闲结点回收到备用链表 12345void Free_SSL(StaticLinkList space, int k) &#123; space[k].cur = space[0].cur; /* 把第一个元素的cur值赋给要删除的分量cur */ space[0].cur = k; /* 把要删除的分量下标赋值给第一个元素的cur */&#125; 计算静态链表的长度 1234567891011int ListLength(StaticLinkList L)&#123; int j=0; int i=L[MAXSIZE-1].cur; while(i) &#123; i=L[i].cur; j++; &#125; return j;&#125; 在L中第i个元素之前插入新的数据元素e 123456789101112131415161718Status ListInsert(StaticLinkList L, int i, ElemType e) &#123; int j, k, l; k = MAXSIZE - 1; /* 注意k首先是最后一个元素的下标 */ if (i &lt; 1 || i &gt; ListLength(L) + 1) return ERROR; j = Malloc_SSL(L); /* 获得空闲分量的下标 */ if (j) &#123; L[j].data = e; /* 将数据赋值给此分量的data */ for(l = 1; l &lt;= i - 1; l++) /* 找到第i个元素之前的位置 */ k = L[k].cur; L[j].cur = L[k].cur; /* 把第i个元素之前的cur赋值给新元素的cur */ L[k].cur = j; /* 把新元素的下标赋值给第i个元素之前元素的ur */ return OK; &#125; return ERROR; &#125; 删除在L中第i个数据元素 12345678910111213Status ListDelete(StaticLinkList L, int i) &#123; int j, k; if (i &lt; 1 || i &gt; ListLength(L)) return ERROR; k = MAXSIZE - 1; for (j = 1; j &lt;= i - 1; j++) k = L[k].cur; j = L[k].cur; L[k].cur = L[j].cur; Free_SSL(L, j); return OK; &#125; 遍历静态链表 1234567891011121314Status ListTraverse(StaticLinkList L)&#123; int j=0; int i=L[MAXSIZE-1].cur; while(i) &#123; visit(L[i].data); i=L[i].cur; j++; &#125; return j; printf("\n"); return OK;&#125; 非循环单向线性表 类型定义 123456789101112#define LIST_INIT_SIZE 100 //顺序表存储空间的初始分配量 #define LISTINCREMENT 10 //顺序表存储空间的分配增量typedef int LElemType_Sq;typedef struct&#123; LElemType_Sq *elem; //存储空间基址（指向第一个结点的指针） int length; //当前顺序表长度 int listsize; //当前分配的存储容量 &#125;SqList; 初始化线性表 1234567891011Status InitList_Sq(SqList *L)&#123; (*L).elem = (LElemType_Sq*)malloc(LIST_INIT_SIZE*sizeof(LElemType_Sq)); if(!(*L).elem) exit(OVERFLOW); //分配内存失败 (*L).length = 0; //初始化顺序表长度为0 (*L).listsize = LIST_INIT_SIZE; //顺序表初始内存分配量 return OK; //初始化成功 &#125; 清空线性表 1234void ClearList_Sq(SqList *L)&#123; (*L).length = 0;&#125; 销毁线性表 12345678void DestroyList_Sq(SqList *L)&#123; free((*L).elem); (*L).elem = NULL; //释放内存后置空指针 (*L).length = 0; (*L).listsize = 0;&#125; 判断线性表是否为空 1234Status ListEmpty_Sq(SqList L)&#123; return L.length==0 ? TRUE : FALSE;&#125; 计算线性表的长度 1234int ListLength_Sq(SqList L)&#123; return L.length; &#125; 用e接收顺序表L中第i个元素 123456789Status GetElem_Sq(SqList L, int i, LElemType_Sq *e)&#123; if(i&lt;1 || i&gt;L.length) return ERROR; //i值不合法 else *e = L.elem[i-1]; return OK;&#125; 返回顺序表L中首个与e满足Compare关系的元素位序 123456789101112int LocateElem_Sq(SqList L, LElemType_Sq e, Status(Compare)(LElemType_Sq, LElemType_Sq))&#123; int i = 1; //i的初值为第一个元素的位序 while(i&lt;=L.length &amp;&amp; !Compare(e, L.elem[i-1])) ++i; if(i&lt;=L.length) return i; else return 0; &#125; 用pre_e接收cur_e的前驱 123456789101112131415161718Status PriorElem_Sq(SqList L, LElemType_Sq cur_e, LElemType_Sq *pre_e)&#123; int i = 1; if(L.elem[0]!=cur_e) //第一个结点无前驱 &#123; while(i&lt;L.length &amp;&amp; L.elem[i]!=cur_e) ++i; if(i&lt;L.length) &#123; *pre_e = L.elem[i-1]; return OK; &#125; &#125; return ERROR;&#125; 用next_e接收cur_e的后继 123456789101112131415Status NextElem_Sq(SqList L, LElemType_Sq cur_e, LElemType_Sq *next_e)&#123; int i = 0; while(i&lt;L.length &amp;&amp; L.elem[i]!=cur_e) ++i; if(i&lt;L.length-1) //最后一个结点无后继 &#123; *next_e = L.elem[i+1]; return OK; &#125; return ERROR;&#125; 在顺序表L的第i个位置上插入e 12345678910111213141516171819202122232425262728Status ListInsert_Sq(SqList *L, int i, LElemType_Sq e)&#123; LElemType_Sq *newbase; LElemType_Sq *p, *q; if(i&lt;1 || i&gt;(*L).length+1) return ERROR; //i值不合法 if((*L).length &gt;= (*L).listsize) //若存储空间已满，需开辟新空间 &#123; newbase = (LElemType_Sq*)realloc((*L).elem, ((*L).listsize+LISTINCREMENT)*sizeof(LElemType_Sq)); if(!newbase) exit(OVERFLOW); (*L).elem = newbase; (*L).listsize += LISTINCREMENT; &#125; q = &amp;(*L).elem[i-1]; //q为插入位置 for(p=&amp;(*L).elem[(*L).length-1]; p&gt;=q; --p) *(p+1) = *p; //插入位置及之后的元素右移 *q = e; //插入e (*L).length++; //表长增1 return OK; &#125; 删除顺序表L上第i个位置的元素，并用e返回 123456789101112131415161718Status ListDelete_Sq(SqList *L, int i, LElemType_Sq *e)&#123; LElemType_Sq *p, *q; if(i&lt;1 || i&gt;(*L).length) return ERROR; //i值不合法 p = &amp;(*L).elem[i-1]; //p为被删除元素的位置 *e = *p; q = (*L).elem+(*L).length-1; //表尾元素位置 for(++p; p&lt;=q; ++p) *(p-1) = *p; //被删元素之后的元素左移 (*L).length--; //表长减1 return OK;&#125; 用visit函数访问顺序表L 123456789Status ListTraverse_Sq(SqList L, void(Visit)(LElemType_Sq))&#123; int i; for(i=0; i&lt;L.length; i++) Visit(L.elem[i]); return OK;&#125; 单向循环链表 顺序栈 类型定义 123456789101112#define STACK_INIT_SIZE 100 //顺序栈存储空间的初始分配量#define STACKINCREMENT 10 //顺序栈存储空间的分配增量typedef int SElemType_Sq;typedef struct&#123; SElemType_Sq *base; //在栈构造之前和销毁之后，base的值为NULL SElemType_Sq *top; //栈顶指针 int stacksize; //当前已分配的存储空间，以元素为单位 &#125;SqStack; 栈的初始化 12345678910111213141516171819202122232425Status InitStack_Sq(SqStack &amp;S)&#123; S.base = (SElemType_Sq *)malloc(STACK_INIT_SIZE*sizeof(SElemType_Sq)); if(!S.base) exit(OVERFLOW); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK;&#125; //*******************Status InitStack_Sq(SqStack *S)&#123; (*S).base = (SElemType_Sq *)malloc(STACK_INIT_SIZE*sizeof(SElemType_Sq)); if(!(*S).base) exit(OVERFLOW); (*S).top = (*S).base; (*S).stacksize = STACK_INIT_SIZE; return OK;&#125; 销毁栈 1234567891011121314151617181920212223Status DestroyStack_Sq(SqStack &amp;S)&#123; free(S.base); S.base = NULL; S.top = NULL; S.stacksize = 0; return OK;&#125; //*******************Status DestroyStack_Sq(SqStack *S)&#123; free((*S).base); (*S).base = NULL; (*S).top = NULL; (*S).stacksize = 0; return OK;&#125; 清空栈 123456789101112131415Status ClearStack_Sq(SqStack &amp;S)&#123; S.top = S.base; return OK;&#125; //*******************Status ClearStack_Sq(SqStack *S)&#123; (*S).top = (*S).base; return OK;&#125; 判断栈是否为空 123456789Status StackEmpty_Sq(SqStack S)&#123; if(S.top==S.base) return TRUE; else return FALSE;&#125; //******************* 计算栈的长度 123456int StackLength_Sq(SqStack S)&#123; return S.top - S.base;&#125; //******************* 得到栈顶元素 1234567891011121314151617181920212223Status GetTop_Sq(SqStack S, SElemType_Sq &amp;e)&#123; if(S.top==S.base) return ERROR; e = *(S.top - 1); //并不破坏栈 return OK;&#125; //*******************Status GetTop_Sq(SqStack S, SElemType_Sq *e)&#123; if(S.top==S.base) return ERROR; *e = *(S.top - 1); //并不破坏栈 return OK;&#125; 入栈 1234567891011121314151617181920212223242526272829303132333435Status Push_Sq(SqStack &amp;S, SElemType_Sq e)&#123; if(S.top-S.base&gt;=S.stacksize) //栈满，追加存储空间 &#123; S.base = (SElemType_Sq *)realloc(S.base, (S.stacksize+STACKINCREMENT)*sizeof(SElemType_Sq)); if(!S.base) exit(OVERFLOW); //存储分配失败 S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; &#125; *(S.top) = e; //进栈先赋值，栈顶指针再自增 (S.top)++; return OK;&#125; //*******************Status Push_Sq(SqStack *S, SElemType_Sq e)&#123; if((*S).top-(*S).base&gt;=(*S).stacksize) //栈满，追加存储空间 &#123; (*S).base = (SElemType_Sq *)realloc((*S).base, ((*S).stacksize+STACKINCREMENT)*sizeof(SElemType_Sq)); if(!(*S).base) exit(OVERFLOW); //存储分配失败 (*S).top = (*S).base + (*S).stacksize; (*S).stacksize += STACKINCREMENT; &#125; *(S-&gt;top) = e; //进栈先赋值，栈顶指针再自增 (S-&gt;top)++; return OK;&#125; 出栈 1234567891011121314151617181920212223Status Pop_Sq(SqStack &amp;S, SElemType_Sq &amp;e)&#123; if(S.top==S.base) return ERROR; S.top--; //出栈栈顶指针先递减，再赋值 e = *(S.top); return OK;&#125; //*******************Status Pop_Sq(SqStack *S, SElemType_Sq *e)&#123; if((*S).top==(*S).base) return ERROR; (*S).top--; //出栈栈顶指针先递减，再赋值 *e = *((*S).top); return OK;&#125; 遍历栈中元素 1234567891011Status StackTraverse_Sq(SqStack S, void(Visit)(SElemType_Sq))&#123; //遍历不应该破坏栈 SElemType_Sq *p = S.base; while(p&lt;S.top) Visit(*p++); return OK;&#125;//******************* 非循环队列 类型定义 12345678910111213typedef int QElemType_L;typedef struct QNode &#123; QElemType_L data; struct QNode *next;&#125;QNode,* QueuePtr;typedef struct&#123; QueuePtr front; //头指针 QueuePtr rear; //尾指针 &#125;LinkQueue; //队列的链式存储表示 非循环队列的初始化 1234567891011121314151617181920212223Status InitQueue_L(LinkQueue &amp;Q)&#123; Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); if(!Q.front) exit(OVERFLOW); Q.front-&gt;next = NULL; return OK;&#125;//*******************Status InitQueue_L(LinkQueue *Q)&#123; (*Q).front = (*Q).rear = (QueuePtr)malloc(sizeof(QNode)); if(!(*Q).front) exit(OVERFLOW); (*Q).front-&gt;next = NULL; return OK;&#125; 清空队列 1234567891011121314151617181920212223242526272829void ClearQueue_L(LinkQueue &amp;Q)&#123; Q.rear = Q.front-&gt;next; while(Q.rear) &#123; Q.front-&gt;next = Q.rear-&gt;next; free(Q.rear); Q.rear = Q.front-&gt;next; &#125; Q.rear = Q.front;&#125;//*******************void ClearQueue_L(LinkQueue *Q)&#123; (*Q).rear = (*Q).front-&gt;next; while((*Q).rear) &#123; (*Q).front-&gt;next = (*Q).rear-&gt;next; free((*Q).rear); (*Q).rear = (*Q).front-&gt;next; &#125; (*Q).rear = (*Q).front;&#125; 销毁队列 123456789101112131415161718192021void DestroyQueue_L(LinkQueue &amp;Q)&#123; while(Q.front) &#123; Q.rear = Q.front-&gt;next; free(Q.front); Q.front = Q.rear; &#125;&#125;//*******************void DestroyQueue_L(LinkQueue *Q)&#123; while((*Q).front) &#123; (*Q).rear = (*Q).front-&gt;next; free((*Q).front); (*Q).front = (*Q).rear; &#125;&#125; 判断队列是否为空 123456789Status QueueEmpty_L(LinkQueue Q)&#123; if(Q.front==Q.rear) return TRUE; else return FALSE;&#125; //******************* 计算队列的长度 123456789101112131415int QueueLength_L(LinkQueue Q)&#123; int count = 0; QueuePtr p = Q.front; while(p!=Q.rear) &#123; count++; p = p-&gt;next; &#125; return count;&#125; //******************* 得到队头元素 123456789101112131415161718192021222324252627Status GetHead_L(LinkQueue Q, QElemType_L &amp;e)&#123; QueuePtr p; if(Q.front==Q.rear) return ERROR; p = Q.front-&gt;next; e = p-&gt;data; return OK;&#125; //*******************Status GetHead_L(LinkQueue Q, QElemType_L *e)&#123; QueuePtr p; if(Q.front==Q.rear) return ERROR; p = Q.front-&gt;next; *e = p-&gt;data; return OK;&#125; 入队 1234567891011121314151617181920212223242526272829303132333435Status EnQueue_L(LinkQueue &amp;Q, QElemType_L e)&#123; QueuePtr p; p = (QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-&gt;data = e; p-&gt;next = NULL; Q.rear-&gt;next = p; Q.rear=p; return OK;&#125; //*******************Status EnQueue_L(LinkQueue *Q, QElemType_L e)&#123; QueuePtr p; p = (QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-&gt;data = e; p-&gt;next = NULL; (*Q).rear-&gt;next = p; (*Q).rear=p; return OK;&#125; 出队 123456789101112131415161718192021222324252627282930313233343536373839Status DeQueue_L(LinkQueue &amp;Q, QElemType_L &amp;e)&#123; QueuePtr p; if(Q.front==Q.rear) return ERROR; p = Q.front-&gt;next; e = p-&gt;data; Q.front-&gt;next = p-&gt;next; if(Q.rear==p) Q.rear = Q.front; free(p); return OK;&#125; //*******************Status DeQueue_L(LinkQueue *Q, QElemType_L *e)&#123; QueuePtr p; if((*Q).front==(*Q).rear) return ERROR; p = (*Q).front-&gt;next; *e = p-&gt;data; (*Q).front-&gt;next = p-&gt;next; if((*Q).rear==p) (*Q).rear = (*Q).front; free(p); return OK;&#125; 遍历非循环队列 1234567891011121314void QueueTraverse_L(LinkQueue Q, void (Visit)(QElemType_L))&#123; QueuePtr p; p = Q.front-&gt;next; while(p) &#123; Visit(p-&gt;data); p = p-&gt;next; &#125;&#125;//******************* 循环队列（不设头指针） 假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针） 类型定义 123456789101112typedef int QElemType_L;typedef struct QNode &#123; QElemType_L data; struct QNode *next;&#125;QNode,* QueuePtr;typedef struct&#123; QueuePtr rear; //尾指针 &#125;LinkQueue; //队列的链式存储表示 循环队列初始化 1234567891011Status InitQueue_L(LinkQueue *Q) //队列初始化 &#123; (*Q).rear = (QueuePtr)malloc(sizeof(QNode)); if(!(*Q).rear) exit(OVERFLOW); (*Q).rear-&gt;next = (*Q).rear; //初次创建的(*Q).rear为头结点，且next指向 //自身，达到循环效果。 return OK;&#125; 入队 123456789101112131415Status EnQueue_L(LinkQueue *Q, QElemType e) //入队 &#123; QueuePtr p; p = (QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-&gt;data = e; p-&gt;next = (*Q).rear-&gt;next; //入队后新结点的next始终指向头结点，构成循环队列 (*Q).rear-&gt;next = p; //每次都在队尾入队 (*Q).rear = p; return OK;&#125; 出队 1234567891011121314151617181920Status DeQueue_L(LinkQueue *Q, QElemType *e) //出队 &#123; QueuePtr h, p; h = (*Q).rear-&gt;next; if(h-&gt;next==(*Q).rear-&gt;next) return ERROR; p = h-&gt;next; *e = p-&gt;data; h-&gt;next = p-&gt;next; //当队列只有一个元素时，头结点的next指向自身 if(p==(*Q).rear) //队列只有一个元素 (*Q).rear = h; //rear指向头结点 free(p); return OK;&#125; 遍历循环队列 1234567void Output_L(LinkQueue Q)&#123; QueuePtr p; for(p=Q.rear-&gt;next-&gt;next; p!=Q.rear-&gt;next; p=p-&gt;next) printf("%d ", p-&gt;data);&#125; 循环队列（设头指针） 设置一个标志域tag，并以tag的值为0和1来区分，尾指针和头指针值相同时的队列状态是“空”还是“满”。 类型定义 123456789typedef int QElemType;typedef struct&#123; QElemType *base; int front; int rear; int tag; //0表示空，1表示满 &#125;SqQueue; 队列初始化 123456789Status InitQueue_L(SqQueue *Q)&#123; (*Q).base = (QElemType *)malloc(MAXQSIZE*sizeof(QElemType)); if(!((*Q).base)) exit(OVERFLOW); (*Q).front = (*Q).rear = 0; (*Q).tag = 0;&#125; 入队 12345678910111213Status EnQueue_L(SqQueue *Q, QElemType e)&#123; if((*Q).rear==(*Q).front &amp;&amp; (*Q).tag==1) //队列满 return ERROR; (*Q).base[(*Q).rear] = e; (*Q).rear = ((*Q).rear+1)%MAXQSIZE; if((*Q).rear==(*Q).front) //入队后队满 (*Q).tag = 1; return OK;&#125; 出队 12345678910111213Status DeQueue_L(SqQueue *Q, QElemType *e)&#123; if((*Q).front==(*Q).rear &amp;&amp; (*Q).tag==0) //队列空 return ERROR; *e = (*Q).base[(*Q).front]; (*Q).front = ((*Q).front+1)%MAXQSIZE; if((*Q).rear==(*Q).front) //出队后队空 (*Q).tag = 0; return OK;&#125; 遍历队列 1234567void Output_L(SqQueue Q)&#123; int i; for(i=Q.front; i!=Q.rear; i=(i+1)%MAXQSIZE) printf("%d ", Q.base[i]);&#125; 堆串 类型定义 123456/* 串的堆存储表示 */typedef struct&#123; char *ch; //若是非空串，则按串长分配存储区，否则ch为NULL int length;&#125;HString; 初始化S为空串 12345void InitString_H(HString *S)&#123; (*S).ch = NULL; (*S).length = 0;&#125; 生成一个其值等于常量chars的串T 123456789101112131415161718192021222324Status StrAssign_H(HString *T, char *chars)&#123; int i, j; InitString_H(T); i = strlen(chars); if(!i) return ERROR; else &#123; (*T).ch = (char*)malloc(i*sizeof(char)); if(!((*T).ch)) exit(OVERFLOW); for(j=0; j&lt;i; j++) (*T).ch[j] = chars[j]; (*T).length = i; &#125; return OK;&#125; 由串S复制得到串T 1234567891011121314151617181920Status StrCopy_H(HString *T, HString S)&#123; int i; InitString_H(T); if(StrEmpty_H(S)) return ERROR; (*T).ch = (char*)malloc(S.length*sizeof(char)); if(!(*T).ch) exit(OVERFLOW); for(i=0; i&lt;S.length; i++) (*T).ch[i] = S.ch[i]; (*T).length = S.length; return OK;&#125; 若S为空串，返回TRUE,否则返回FALSE 1234567Status StrEmpty_H(HString S)&#123; if(S.length==0 &amp;&amp; S.ch==NULL) return TRUE; else return FALSE;&#125; 若S&gt;T，返回值&gt;0；若S&lt;T，返回值&lt;0；否则，返回值=0 123456789101112Status StrCompare_H(HString S, HString T)&#123; int i; for(i=0; i&lt;S.length&amp;&amp;i&lt;T.length; i++) &#123; if(S.ch[i]!=T.ch[i]) return S.ch[i]-T.ch[i]; &#125; return S.length-T.length;&#125; 求串长 1234567int StrLength_H(HString S)&#123; if(StrEmpty_H(S)) return 0; else return S.length;&#125; 清空串S 123456789101112Status ClearString_H(HString *S)&#123; if((*S).ch) &#123; free((*S).ch); (*S).ch = NULL; &#125; (*S).length = 0; return OK;&#125; 用T返回由S1和S2联接而成的新串 1234567891011121314151617181920Status Concat_H(HString *T, HString S1, HString S2)&#123; int i; InitString_H(T); (*T).length = S1.length + S2.length; (*T).ch = (char*)malloc((*T).length*sizeof(char)); if(!(*T).ch) exit(OVERFLOW); for(i=0; i&lt;S1.length; i++) (*T).ch[i] = S1.ch[i]; for(i=0; i&lt;S2.length; i++) (*T).ch[S1.length+i] = S2.ch[i]; return OK;&#125; 用Sub返回串S的第pos个字符起长度为len的子串 1234567891011121314151617181920212223242526Status SubString_H(HString *Sub, HString S, int pos, int len)&#123; int i; InitString_H(Sub); if(StrEmpty_H(S)) return ERROR; if(pos&lt;1 || pos&gt;S.length || len&lt;0 || pos+len-1&gt;S.length) return ERROR; if(len) //非空子串 &#123; (*Sub).ch = (char*)malloc(len*sizeof(char)); if(!(*Sub).ch) exit(OVERFLOW); for(i=0; i&lt;len; i++) (*Sub).ch[i] = S.ch[i+pos-1]; (*Sub).length = len; &#125; return OK;&#125; 返回T在S中第pos个字符后第一次出现的位置，不存在则返回0 1234567891011121314151617181920212223242526int Index_H(HString S, HString T, int pos)&#123; int s, t, i; HString Sub; InitString_H(&amp;Sub); if(pos&gt;0) &#123; s = S.length; t = T.length; i = pos; while(i+t-1&lt;=s) &#123; SubString_H(&amp;Sub, S, i, t); if(StrCompare_H(Sub, T)) i++; else return i; &#125; &#125; return 0;&#125; 用V替换主串S中出现的所有与T相等的不重叠的子串 12345678910111213141516171819202122Status Replace_H(HString *S, HString T, HString V)&#123; int i; if(StrEmpty_H(T)) return ERROR; i = Index_H(*S, T, 1); while(i!=0) &#123; StrDelete_H(S, i, StrLength_H(T)); StrInsert_H(S, i, V); i += StrLength_H(V); i = Index_H(*S, T, i); &#125; return OK;&#125; 在串S的第pos个字符之前插入串T 1234567891011121314151617181920212223242526Status StrInsert_H(HString *S, int pos, HString T)&#123; int i; if(pos&lt;1 || pos&gt;(*S).length+1) return ERROR; if(StrEmpty_H(T)) return ERROR; else &#123; (*S).ch = (char*)realloc((*S).ch, ((*S).length+T.length)*sizeof(char)); if(!(*S).ch) exit(OVERFLOW); for(i=(*S).length-1; i&gt;=pos-1; i--) //为插入T而腾出位置 (*S).ch[i+T.length] = (*S).ch[i]; for(i=0; i&lt;T.length; i++) (*S).ch[pos-1+i] = T.ch[i]; //插入T (*S).length += T.length; &#125; return OK; &#125; 从串S中删除第pos个字符起长度为len的子串 12345678910111213141516171819Status StrDelete_H(HString *S, int pos, int len)&#123; int i; if(StrEmpty_H(*S)) return ERROR; if(pos&lt;1 || pos+len-1&gt;(*S).length ||len&lt;0) return ERROR; for(i=pos-1; i+len&lt;=(*S).length; i++) (*S).ch[i] = (*S).ch[i+len]; (*S).length -= len; (*S).ch = (char*)realloc((*S).ch, (*S).length*sizeof(char)); //缩小分配的空间 return OK;&#125; 销毁串S 1234void DestroyString_H(HString *S)&#123; //堆串不能被销毁&#125; 输出串S 12345678910void StrPrint_H(HString S)&#123; int i; if(StrEmpty_H(S)) printf("S为空串，不可输出！"); for(i=0; i&lt;S.length; i++) printf("%c", S.ch[i]);&#125; 数组和广义表 类型定义 1#define MAXSIZE 400 //假设非零元个数的最大值为400 三元组顺序表(稀疏矩阵)类型定义 123456789101112typedef int MElemType_TSq;typedef struct&#123; int i, j; //该非零元的行下标和列下标 MElemType_TSq e;&#125;Triple;typedef struct&#123; Triple data[MAXSIZE+1]; //非零元三元组表，data[0]未用 int mu, nu, tu; //矩阵的行数、列数和非零元个数&#125;TSMatrix; 创建n个矩阵 12345678910111213141516171819202122232425Status CreateSMatrix_T(FILE *fp, int n, ...)&#123; int count, k; TSMatrix *M; if(n&lt;1) return ERROR; va_list ap; va_start(ap, n); for(count=1; count&lt;=n; count++) &#123; M = va_arg(ap, TSMatrix*); Scanf(fp, "%d%d%d", &amp;((*M).mu), &amp;((*M).nu), &amp;((*M).tu)); for(k=1; k&lt;=(*M).tu; k++) Scanf(fp, "%d%d%d", &amp;((*M).data[k].i), &amp;((*M).data[k].j), &amp;((*M).data[k].e)); &#125; va_end(ap); return OK; &#125; 销毁矩阵 123456void DestroySMatrix_T(TSMatrix *M)&#123; (*M).mu = 0; (*M).nu = 0; (*M).tu = 0;&#125; 输出矩阵 1234567891011121314151617181920void PrintSMatrix_T(TSMatrix M)&#123; int r, c; int k = 1; for(r=1; r&lt;=M.mu; r++) &#123; for(c=1; c&lt;=M.nu; c++) &#123; if(r==M.data[k].i &amp;&amp; c==M.data[k].j) &#123; printf("%3d ", M.data[k].e); k++; &#125; else printf(" 0 "); &#125; printf("\n"); &#125; &#125; 矩阵的复制 1234void CopySMatrix_T(TSMatrix M, TSMatrix *T)&#123; (*T) = M; //结构可以直接复制 &#125; 矩阵的加法Q = M + N 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980Status AddSMatri_T(TSMatrix M, TSMatrix N, TSMatrix *Q)&#123; int m, n, k; if(M.mu!=N.mu || M.nu!=N.nu) &#123; printf("两矩阵不能相加！！\n"); return ERROR; &#125; Q-&gt;mu = M.mu; Q-&gt;nu = M.nu; Q-&gt;tu = 0; m = n = k = 1; while(m&lt;=M.tu &amp;&amp; n&lt;=N.tu) //依次遍历M与N的三元组 &#123; if(M.data[m].i&lt;N.data[n].i) &#123; Q-&gt;data[k] = M.data[m]; m++; &#125; else if(M.data[m].i&gt;N.data[n].i) &#123; Q-&gt;data[k] = N.data[n]; n++; &#125; else //M.data[m].i==N.data[n].i &#123; if(M.data[m].j&lt;N.data[n].j) &#123; Q-&gt;data[k] = M.data[m]; m++; &#125; else if(M.data[m].j&gt;N.data[n].j) &#123; Q-&gt;data[k] = N.data[n]; n++; &#125; else //M.data[m].j==N.data[n].j &#123; if(M.data[m].e+N.data[n].e) &#123; Q-&gt;data[k].i = M.data[m].i; Q-&gt;data[k].j = M.data[m].j; Q-&gt;data[k].e = M.data[m].e + N.data[n].e; m++; n++; &#125; else &#123; m++; n++; continue; &#125; &#125; &#125; k++; Q-&gt;tu++; &#125; while(m&lt;=M.tu) &#123; Q-&gt;data[k] = M.data[m]; m++; k++; Q-&gt;tu++; &#125; while(n&lt;=N.tu) &#123; Q-&gt;data[k] = N.data[n]; n++; k++; Q-&gt;tu++; &#125; return OK;&#125; 矩阵的减法Q = M - N 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586Status SubSMatrix_T(TSMatrix M, TSMatrix N, TSMatrix *Q)&#123; int m, n, k; if(M.mu!=N.mu || M.nu!=N.nu) &#123; printf("两矩阵不能相减！！\n"); return ERROR; &#125; Q-&gt;mu = M.mu; Q-&gt;nu = M.nu; Q-&gt;tu = 0; m = n = k = 1; while(m&lt;=M.tu &amp;&amp; n&lt;=N.tu) &#123; if(M.data[m].i&lt;N.data[n].i) &#123; Q-&gt;data[k] = M.data[m]; m++; &#125; else if(M.data[m].i&gt;N.data[n].i) &#123; Q-&gt;data[k].i = N.data[n].i; Q-&gt;data[k].j = N.data[n].j; Q-&gt;data[k].e = -N.data[n].e; n++; &#125; else //M.data[m].i==N.data[n].i &#123; if(M.data[m].j&lt;N.data[n].j) &#123; Q-&gt;data[k] = M.data[m]; m++; &#125; else if(M.data[m].j&gt;N.data[n].j) &#123; Q-&gt;data[k].i = N.data[n].i; Q-&gt;data[k].j = N.data[n].j; Q-&gt;data[k].e = -N.data[n].e; n++; &#125; else //M.data[m].j==N.data[n].j &#123; if(M.data[m].e-N.data[n].e) &#123; Q-&gt;data[k].i = M.data[m].i; Q-&gt;data[k].j = M.data[m].j; Q-&gt;data[k].e = M.data[m].e - N.data[n].e; m++; n++; &#125; else &#123; m++; n++; continue; &#125; &#125; &#125; k++; Q-&gt;tu++; &#125; while(m&lt;=M.tu) &#123; Q-&gt;data[k] = M.data[m]; m++; k++; Q-&gt;tu++; &#125; while(n&lt;=N.tu) &#123; Q-&gt;data[k].i = N.data[n].i; Q-&gt;data[k].j = N.data[n].j; Q-&gt;data[k].e = -N.data[n].e;; n++; k++; Q-&gt;tu++; &#125; return OK; &#125; 矩阵的乘法Q = M * N 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Status MultSMatrix_T(TSMatrix M, TSMatrix N, TSMatrix *Q)&#123; int m, n, i, j, k; MElemType_TSq c, c1, c2; if(M.nu!=N.mu) //M列数等于N行数 &#123; printf("两矩阵不能相乘！！\n"); return ERROR; &#125; Q-&gt;mu = M.mu; //Q初始化 Q-&gt;nu = N.nu; Q-&gt;tu = 0; if(M.tu*N.tu) //Q是非零矩阵 &#123; for(i=1; i&lt;=M.mu; i++) //传统矩阵乘法 &#123; for(j=1; j&lt;=N.nu; j++) &#123; c = 0; for(k=1; k&lt;=M.nu; k++) &#123; c1 = 0; for(m=1; m&lt;=M.tu; m++) //依次寻找位于指定位置的M三元组 &#123; if(M.data[m].i==i &amp;&amp; M.data[m].j==k) &#123; c1 = M.data[m].e; break; &#125; &#125; c2 = 0; for(n=1; n&lt;=N.tu; n++) //依次寻找位于指定位置的N三元组 &#123; if(N.data[n].i==k &amp;&amp; N.data[n].j==j) &#123; c2 = N.data[n].e; break; &#125; &#125; if(c1 &amp;&amp; c2) c += c1 * c2; &#125; if(c) &#123; Q-&gt;tu++; Q-&gt;data[Q-&gt;tu].i = i; Q-&gt;data[Q-&gt;tu].j = j; Q-&gt;data[Q-&gt;tu].e = c; &#125; &#125; &#125; &#125; return OK;&#125; 矩阵转置 1234567891011121314151617181920212223242526void TransposeSMatrix_T(TSMatrix M, TSMatrix *T)&#123; int p, q, col; T-&gt;mu = M.nu; T-&gt;nu = M.mu; T-&gt;tu = M.tu; if(T-&gt;tu) &#123; q = 1; //q用于T中非零元计数 for(col=1; col&lt;=M.nu; ++col) //col代表M的列，T的行 &#123; for(p=1; p&lt;=M.tu; ++p) //p用于M中非零元计数 &#123; if(M.data[p].j==col) &#123; T-&gt;data[q].i = M.data[p].j; //M的列变为T的行 T-&gt;data[q].j = M.data[p].i; //M的行变为T的列 T-&gt;data[q].e = M.data[p].e; //每个三元组值不变 ++q; &#125; &#125; &#125; &#125;&#125; 矩阵快速转置 123456789101112131415161718192021222324252627282930313233void FastTransposeSMatrix_T(TSMatrix M, TSMatrix *T)&#123; int col, t, p, q; int num[M.nu]; //num[col]表示M第col列中非零元的个数 int copt[M.nu]; //copt[col]表示M第col列第一个非零元在T-&gt;data中恰当的位置 T-&gt;mu = M.nu; T-&gt;nu = M.mu; T-&gt;tu = M.tu; if(T-&gt;tu) &#123; for(col=1; col&lt;=M.nu; ++col) num[col] = 0; //初始化数组num for(t=1; t&lt;=M.tu; ++t) //t遍历M中三元组 num[M.data[t].j]++; //统计M中每列非零元个数 copt[1] = 1; for(col=2; col&lt;=M.nu; ++col) copt[col] = copt[col-1] + num[col-1]; for(p=1; p&lt;=M.tu; ++p) //依次扫描M中的三元组 &#123; col = M.data[p].j; //col为M中第p个三元组中元素的列 q = copt[col]; //q为当前三元组元素在T中应放置的位置 T-&gt;data[q].i = M.data[p].j; T-&gt;data[q].j = M.data[p].i; T-&gt;data[q].e = M.data[p].e; ++copt[col]; //再遇到此列元素时位置增一 &#125; &#125;&#125; 树和二叉树 二叉树（二叉链表存储）相关类型定义 12345678typedef char TElemType; //假设二叉树元素均为字符typedef struct BiTNode&#123; TElemType data; //结点元素 struct BiTNode* lchild; //左孩子指针 struct BiTNode* rchild; //右孩子指针 &#125;BiTNode; //二叉树结点 typedef BiTNode* BiTree; //指向二叉树结点的指针 栈元素类型 1234typedef BiTree SElemType_Sq; //重定义栈元素类型 #include "../../▲03 栈和队列/01 SequenceStack/SequenceStack.c" //**▲03 栈和队列**// 要用到栈的类型定义 存储当前结点信息，按树结构打印树的时候使用 123456typedef struct &#123; BiTree left; //当前结点的左指针 BiTree right; //当前结点的右指针 int n; //当前结点的次序 &#125;Node; 构造空二叉树T (初始化二叉树) 1234void InitBiTree(BiTree *T)&#123; *T = NULL;&#125; 清空二叉树T 1234567891011121314void ClearBiTree(BiTree *T)&#123; if(*T) //二叉树不为空 &#123; if((*T)-&gt;lchild) //清空左树 ClearBiTree(&amp;((*T)-&gt;lchild)); if((*T)-&gt;rchild) //清空右树 ClearBiTree(&amp;((*T)-&gt;rchild)); free(*T); //释放根结点 *T = NULL; //置空树指针 &#125; &#125; 销毁二叉树T 1234void DestroyBiTree(BiTree *T)&#123; //二叉树无法销毁 &#125; 判断二叉树T是否为空 1234Status BiTreeEmpty(BiTree T)&#123; return T==NULL ? TRUE : ERROR;&#125; 按先序序列构造二叉树_1 1234567891011121314151617181920Status CreateBiTree(FILE *fp, BiTree *T)&#123; char ch; Scanf(fp, "%c", &amp;ch); if(ch == '^') *T = NULL; else &#123; *T = (BiTree)malloc(sizeof(BiTNode)); if(!(*T)) exit(OVERFLOW); (*T)-&gt;data = ch; CreateBiTree(fp, &amp;(*T)-&gt;lchild); CreateBiTree(fp, &amp;(*T)-&gt;rchild); &#125; return OK;&#125; 按先序序列构造二叉树_2 123456789101112131415161718BiTree f(FILE *fp, BiTree *T)&#123; char ch; Scanf(fp, "%c", &amp;ch); if(ch == '^') *T = NULL; else &#123; *T = (BiTree)malloc(sizeof(BiTNode)); if(!(*T)) exit(OVERFLOW); (*T)-&gt;data = ch; CreateBiTree(fp, &amp;(*T)-&gt;lchild); CreateBiTree(fp, &amp;(*T)-&gt;rchild); &#125;&#125; 返回二叉树长度（按完全二叉树计算） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int BiTreeLength(BiTree T)&#123; Node node[100]; //存储结点信息 int i, len; i = len = 0; if(T) &#123; node[i].left = T-&gt;lchild; node[i].right = T-&gt;rchild; node[i].n = 1; if(node[i].n&gt;len) len = node[i].n; while(i&gt;=0) &#123; while(node[i].left) //访问左子树 &#123; node[i+1].left = node[i].left-&gt;lchild; node[i+1].right = node[i].left-&gt;rchild; node[i+1].n = 2*node[i].n; node[i].left = NULL; i++; if(node[i].n&gt;len) len = node[i].n; &#125; if(node[i].right) //左子树为空时访问右子树 &#123; node[i+1].left = node[i].right-&gt;lchild; node[i+1].right = node[i].right-&gt;rchild; node[i+1].n = 2*node[i].n+1; node[i].right = NULL; i++; if(node[i].n&gt;len) len = node[i].n; &#125; if(node[i].left==NULL &amp;&amp; node[i].right==NULL) i--; &#125; &#125; return len;&#125; 返回二叉树深度（层数） 1234567891011121314int BiTreeDepth(BiTree T)&#123; int LD, RD; if(T==NULL) return 0; //空树深度为0 else &#123; LD = BiTreeDepth(T-&gt;lchild); //求左子树深度 RD = BiTreeDepth(T-&gt;rchild); //求右子树深度 return (LD&gt;=RD?LD:RD)+1; &#125;&#125; 用e返回二叉树的根结点值 12345678910Status Root(BiTree T, TElemType *e)&#123; if(!T) return ERROR; else &#123; *e = T-&gt;data; return OK; &#125;&#125; 返回某结点的值，p为结点指针 1234TElemType Value(BiTree p)&#123; return p-&gt;data;&#125; 为某结点赋值，p为结点指针 1234void Assign(BiTree p, TElemType value)&#123; p-&gt;data = value;&#125; 返回某结点的双亲结点值 12345678910111213141516171819202122232425262728293031323334353637TElemType Parent(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(T==NULL || (T!=NULL &amp;&amp; e==T-&gt;data)) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].lchild) &#123; if(node[i].lchild-&gt;data==e) return node[i].data; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].rchild) &#123; if(node[i].rchild-&gt;data==e) return node[i].data; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return '\0'; &#125; 返回某结点的左孩子结点值 1234567891011121314151617181920212223242526272829303132333435363738394041TElemType LeftChild(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(!T) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].data!=e &amp;&amp; node[i].lchild) &#123; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].data==e) &#123; if(node[i].lchild) return node[i].lchild-&gt;data; else return '\0'; &#125; if(node[i].rchild) &#123; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL &amp;&amp; node[i].data!=e) i--; &#125; if(i&lt;0) return '\0'; &#125; 返回某结点的右孩子结点值 12345678910111213141516171819202122232425262728293031323334353637383940TElemType RightChild(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(!T) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].data!=e &amp;&amp; node[i].lchild) &#123; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].data==e) &#123; if(node[i].rchild) return node[i].rchild-&gt;data; else return '\0'; &#125; if(node[i].rchild) &#123; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return '\0';&#125; 返回某结点的左兄弟结点值 12345678910111213141516171819202122232425262728293031323334353637383940414243TElemType LeftSibling(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(T==NULL || (T!=NULL &amp;&amp; e==T-&gt;data)) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].rchild) &#123; if(node[i].rchild-&gt;data==e) &#123; if(node[i].lchild) return node[i].lchild-&gt;data; else return '\0'; &#125; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild) &#123; if(node[i].lchild-&gt;data==e) return '\0'; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return '\0';&#125; 返回某结点的右兄弟结点值 123456789101112131415161718192021222324252627282930313233343536373839404142TElemType RightSibling(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(T==NULL || (T!=NULL &amp;&amp; e==T-&gt;data)) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].lchild) &#123; if(node[i].lchild-&gt;data==e) &#123; if(node[i].rchild) return node[i].rchild-&gt;data; else return '\0'; &#125; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].rchild) &#123; if(node[i].rchild-&gt;data==e) return '\0'; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return '\0';&#125; 获取指向结点e的指针_1 12345678910111213141516171819202122232425262728293031323334353637383940BiTree LocationBiTree_1(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(T==NULL) return NULL; if(T-&gt;data==e) return T; node[i] = *T; while(i&gt;=0) &#123; while(node[i].lchild) &#123; if(node[i].lchild-&gt;data==e) return node[i].lchild; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].rchild) &#123; if(node[i].rchild-&gt;data==e) return node[i].rchild; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return NULL;&#125; 获取指向结点e的指针_2 1234567891011121314151617181920BiTree LocationBiTree_2(BiTree T, TElemType e)&#123; BiTree p = NULL; if(T) &#123; if(T-&gt;data==e) p = T; else &#123; if(p=LocationBiTree_2(T-&gt;lchild, e)) return p; if(p=LocationBiTree_2(T-&gt;rchild, e)) return p; &#125; &#125; return p;&#125; 将树T0插入到树T中成为结点e的子树，LR为插入标记，T0只有左子树 1234567891011121314Status InsertBiTree(BiTree T, TElemType e, BiTree T0, int LR)&#123; BiTree p = LocationBiTree_1(T, e); if(p) &#123; T0-&gt;rchild = LR ? p-&gt;rchild : p-&gt;lchild; LR ? (p-&gt;rchild=T0) : (p-&gt;lchild=T0); return OK; &#125; return ERROR; &#125; 删除e结点的左子树或右子树，LR为删除标记 12345678910111213Status DeleteBiTree(BiTree T, TElemType e, int LR)&#123; BiTree p = LocationBiTree_2(T, e); if(p) &#123; LR ? ClearBiTree(&amp;(p-&gt;rchild)) : ClearBiTree(&amp;(p-&gt;lchild)); return OK; &#125; return ERROR;&#125; 层序遍历二叉树_1（利用数组实现） 1234567891011121314151617181920void LevelOrderTraverse_1(BiTree T, void(Visit)(TElemType))&#123; int i, j; BiTree p[100]; //树指针数组 i = j = 0; if(T) p[j++] = T; while(i&lt;j) &#123; Visit(p[i]-&gt;data); if(p[i]-&gt;lchild) p[j++] = p[i]-&gt;lchild; if(p[i]-&gt;rchild) p[j++] = p[i]-&gt;rchild; i++; &#125;&#125; 层序遍历二叉树_2（利用队列实现） 1234567891011121314151617181920212223Status LevelOrderTraverse_2(BiTree T, Status (*visit)(TElemType e))&#123; BiTree p; LinkQueue Q; InitQueue(Q); p = T; while (p || !QueueEmpty(Q)) &#123; if (p) &#123; visit(p-&gt;data); if (p-&gt;lchild) EnQueue(Q, p-&gt;lchild); if (p-&gt;rchild) EnQueue(Q, p-&gt;rchild); if (!QueueEmpty(Q)) DeQueue(Q, p); else //队列为空时，退出while循环 break; &#125; &#125; return OK;&#125; 先序遍历二叉树_1（递归） 123456789void PreOrderTraverse_1(BiTree T, void(Visit)(TElemType))&#123; if(T) &#123; Visit(T-&gt;data); PreOrderTraverse_1(T-&gt;lchild, Visit); PreOrderTraverse_1(T-&gt;rchild, Visit); &#125;&#125; 先序遍历二叉树_2（递归） 1234567891011121314Status PreOrderTraverse_2(BiTree T, Status(Visit)(TElemType))&#123; if(T) &#123; if(Visit(T-&gt;data)) &#123; PreOrderTraverse_2(T-&gt;lchild, Visit); PreOrderTraverse_2(T-&gt;rchild, Visit); &#125; return OK; &#125; else return ERROR;&#125; 先序遍历二叉树_1（非递归） 123456789101112131415161718192021222324252627282930313233void PreOrderTraverse_3(BiTree T)&#123; SqStack S; SElemType_Sq e; if(!BiTreeEmpty(T)) &#123; InitStack_Sq(&amp;S); Push_Sq(&amp;S, T); while(!StackEmpty_Sq(S)) &#123; GetTop_Sq(S, &amp;e); printf("%c ", e-&gt;data); if(e-&gt;lchild) Push_Sq(&amp;S, e-&gt;lchild); else &#123; while(!StackEmpty_Sq(S)) &#123; Pop_Sq(&amp;S, &amp;e); if(e-&gt;rchild) &#123; Push_Sq(&amp;S, e-&gt;rchild); break; &#125; &#125; &#125; &#125; &#125;&#125; 先序遍历二叉树_2（非递归） 1234567891011121314151617181920212223Status PreOrderTraverse_4(BiTree T, Status (*visit)(TElemType e))&#123; SqStack S; BiTree p; InitStack(S); p = T; while (p || !StackEmpty(S)) &#123; if (p) //访问根指针，左指针进栈 &#123; if (ERROR == visit(p-&gt;data)) return ERROR; Push(S, p); p = p-&gt;lchild; &#125; else &#123; Pop(S, p); p = p-&gt;rchild; &#125; &#125; return OK;&#125; 中序遍历二叉树_1（递归） 123456789void InOrderTraverse_1(BiTree T, void(Visit)(TElemType))&#123; if(T) &#123; InOrderTraverse_1(T-&gt;lchild, Visit); Visit(T-&gt;data); InOrderTraverse_1(T-&gt;rchild, Visit); &#125;&#125; 中序遍历二叉树_2（非递归） 12345678910111213141516171819202122232425Status InOrderTraverse_2(BiTree T, Status(Visit)(TElemType))&#123; SqStack S; SElemType_Sq p; InitStack_Sq(&amp;S); Push_Sq(&amp;S, T); while(!StackEmpty_Sq(S)) &#123; while(GetTop_Sq(S, &amp;p) &amp;&amp; p) //栈顶元素不为空 Push_Sq(&amp;S, p-&gt;lchild); //向左走到尽头 Pop_Sq(&amp;S, &amp;p); //空指针退栈 if(!StackEmpty_Sq(S)) //访问结点，向右一步 &#123; Pop_Sq(&amp;S, &amp;p); if(!Visit(p-&gt;data)) return ERROR; Push_Sq(&amp;S, p-&gt;rchild); &#125; &#125; return OK; &#125; 中序遍历二叉树_3（非递归） 12345678910111213141516171819202122232425Status InOrderTraverse_3(BiTree T, Status(Visit)(TElemType))&#123; SqStack S; SElemType_Sq p; InitStack_Sq(&amp;S); p = T; while(p || !StackEmpty_Sq(S)) &#123; if(p) &#123; Push_Sq(&amp;S, p); p = p-&gt;lchild; &#125; else &#123; Pop_Sq(&amp;S, &amp;p); if(!Visit(p-&gt;data)) return ERROR; p = p-&gt;rchild; &#125; &#125; return OK; &#125; 后序遍历二叉树（递归） 123456789void PostOrderTraverse(BiTree T, void(Visit)(TElemType))&#123; if(T) &#123; PostOrderTraverse(T-&gt;lchild, Visit); PostOrderTraverse(T-&gt;rchild, Visit); Visit(T-&gt;data); &#125;&#125; 后序遍历二叉树_1（非递归） 123456789101112131415161718192021222324252627282930313233343536373839404142434445void PostOrderTraverse_1(BiTree T)&#123; SqStack S; BiTree p; SElemType_Sq e; int StackMark[100] = &#123;&#125;; //模拟栈，设置各结点访问标记 int k; InitStack_Sq(&amp;S); p = T; k = -1; while(1) &#123; while(p) &#123; Push_Sq(&amp;S, p); k++; StackMark[k] = 1; p = p-&gt;lchild; &#125; while(!p &amp;&amp; !StackEmpty_Sq(S)) //p为空但栈不为空 &#123; GetTop_Sq(S, &amp;p); if(StackMark[k]==1) //已访问过一次，当前是第二次访问 &#123; StackMark[k] = 2; p = p-&gt;rchild; &#125; else //已访问过两次，当前是第三次访问 &#123; printf("%c ", p-&gt;data); Pop_Sq(&amp;S, &amp;e); StackMark[k] = 0; k--; p = NULL; &#125; &#125; if(StackEmpty_Sq(S)) break; &#125; &#125; 后序遍历二叉树_2（非递归） 12345678910111213141516171819202122232425262728293031323334353637Status PostOrderTraverse_2(BiTree T, Status (*visit)(TElemType e))&#123; SqStack S; InitStack(S); BiTree p; int Tag[20]; //标志栈 int t = 1; p = T; while (p || !StackEmpty(S)) &#123; while (p) //向左走到尽头 &#123; Push(S, p); p = p-&gt;lchild; Tag[t++] = 0; &#125; while (!StackEmpty(S) &amp;&amp; 1 == Tag[t-1]) //结点标志为1表示右子树已经访问过 &#123; Pop(S, p); t--; if (ERROR == visit(p-&gt;data)) return ERROR; &#125; if (!StackEmpty(S)) //结点标志为0，则访问右子树，并将结点标志置为1 &#123; Tag[t-1] = 1; GetTop(S, p); p = p-&gt;rchild; &#125; else break; &#125; return OK;&#125; 按二叉树的结构打印树 12345678910111213141516171819202122232425262728293031323334353637383940414243void PrintTree(BiTree T)&#123; int row, col; int i, j, m, l, r; BiTNode a[100][100] = &#123;&#125;; //用一个足够大的矩阵按原样存储树 if(T) &#123; row = BiTreeDepth(T); //总行数 col = pow(2, row) - 1; //总列数 for(i=1; i&lt;=row-1; i++) &#123; for(j=1; j&lt;=pow(2, i-1); j++) &#123; m = (2*j-1)*pow(2, row-i); //当前行结点相对位序 l = (4*j-3)*pow(2, row-i-1); //下一行结点相对位序 r = (4*j-1)*pow(2, row-i-1); if(i==1) //初始化 a[i][m] = *T; if(a[i][m].lchild) //下一行 a[i+1][l] = *(a[i][m].lchild); if(a[i][m].rchild) //下一行 a[i+1][r] = *(a[i][m].rchild); &#125; &#125; for(i=1; i&lt;=row; i++) &#123; for(j=1; j&lt;=col; j++) &#123; if(a[i][j].data) printf("%c", a[i][j].data); else printf(" "); &#125; printf("\n"); &#125; &#125;&#125; 第四章 数据结构算法描述 栈 中缀表达式转换成后缀表达式（逆波兰式），并对逆波兰表达式求值 [Question-3.21-main.c](E:\数据结构和算法\数据结构严蔚敏\Data-Structure-master\▼配套习题解析\▼03 栈和队列\▼习题测试文档-03\Question-3.21-main.c) [Question-3.22-main.c](E:\数据结构和算法\数据结构严蔚敏\Data-Structure-master\▼配套习题解析\▼03 栈和队列\▼习题测试文档-03\Question-3.22-main.c)]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法介绍 Typora 编辑]]></title>
    <url>%2F2019%2F02%2F23%2Fmarkdown-yu-fa-jie-shao-typora-bian-ji%2F</url>
    <content type="text"><![CDATA[Markdown 语法介绍 (Typora 编辑) 注：部分Markdown语法无法在博客中显示，但在编辑器中能正常显示 因显示原因，本文有删减，原文地址：https://blog.csdn.net/qq_43613189/article/details/87887737 @[TOC] 参考资料： https://ouweiya.gitbooks.io/markdown/index.html https://www.jianshu.com/p/b03a8d7b1719 https://segmentfault.com/markdown#articleHeader4 https://wizardforcel.gitbooks.io/markdown-simple-world/0.html https://coding.net/help/doc/project/markdown.html https://guo365.github.io/study/Markdown.html https://yuedu.baidu.com/ebook/f2ec7e699a6648d7c1c708a1284ac850ad020418 标题 使用#表示一级标题，##表示二级标题，以此类推，有6个标题。 注：# 后面保持空格 目录列表 (TOC) 输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。 引用 单行式 使用 &gt; 来插入块引用。例如： 1&gt; hello world! 演示： hello world! 多行式 123&gt; hello world!hello world!hello world! 或者 123&gt; hello world!&gt; hello world!&gt; hello world! 演示 相同的结果 hello world! hello world! hello world! 多层嵌套 12345678910&gt; aaaaaaaaa&gt; &gt; &gt; bbbbbbbbb&gt; &gt; &gt; &gt; &gt; cccccccccc&gt; &gt; &gt; &gt; &gt;&gt; &gt;&gt;&gt; 演示 aaaaaaaaa bbbbbbbbb cccccccccc 语义标记 描述 效果 代码 斜体 斜体 *斜体* 斜体 斜体 _斜体_ 加粗 加粗 **加粗** 加粗+斜体 加粗+斜体 ***加粗+斜体*** 加粗+斜体 加粗+斜体 **_加粗+斜体_** 删除线 删除线 ~~删除线~~ 斜体 在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义： 1\* 加粗 (强调) 使用两个*号或者两个_包裹的内容将会被加粗。例如 12**使用两个*号加粗内容**__使用两个下划线加粗内容__ 将会输出 使用两个号加粗内容* 使用两个下划线加粗内容 Typroa 推荐使用两个*号。 删除线 GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用~~包裹的文本将会具有删除的样式，例如~删除文本~将产生删除文本的样式。 转义 markdown支持在以下字符前面插入反斜杠 123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 插入之后，将不再解析这些字符，而是原样输出。 高亮 高亮使用==包裹，例如：==高亮==将产生==高亮== 下标 下标使用~包裹，例如：H~2~O将产生H~2~O, 即水的分子式。 上标 上标使用^包裹，例如：y^2^=4将产生表达式y^2^ = 4 插入表情:happy: 使用:happy:输入表情:happy:,使用:sad:输入表情:sad:,使用:cry:输入表情:cry:等。以此类推！ 下划线 用HTML的语法&lt;u&gt;Underline&lt;/u&gt;将产生下划线&lt;u&gt;Underline&lt;/u&gt;. 水平分割线 使用***或者---，然后回车，来产生水平分割线。 注释 我们可以对某一个词语进行注释。例如 12某些人用过了才知道[^注释][^注释]:Somebody that I used to know. 将产生： 某些人用过了才知道[^注释] [^注释]: Somebody that I used to know. 把鼠标放在注释上，将会有提示内容。 列表 注：序列.后 保持空格 无序列表 输入+, -, *创建无序的列表，使用任意数字开头，创建有序列表，例如： 1234**无序的列表*** one* two* three 无序的列表 one two three 有序列表 1234**有序的列表**1. one2. two3. three 有序的列表 one two three 序表嵌套 1234561. one 1. one-1 2. two-22. two * two-1 * two-2 演示 one one-1 two-2 two two-1 two-2 层级列表 1234* 总目录 * 一级目录 * 二级目录 * 三级目录 说明：层级列表一般只支持三级列表，第一级实心圆点，第二级空心圆点，第三级以后都是实心方点。要实现层级列表，每下一级都要比上一级多输入2个空格或者一个Tab，而且第一级前面不要超过3个空格. 演示 总目录 一级目录 二级目录 三级目录 序表嵌套代码块 注：换行+两个Tab 12* one var a = 10; // 与上行保持空行并递进缩进 演示： one 1var a = 10; 任务列表 使用如下的代码创建任务列表，在[ ]中输入x表示完成，也可以通过点击选择完成或者没完成。 123- [ ] 吃饭- [ ] 逛街- [ ] 看电影 [x] 吃饭 [x] 逛街 [x] 看电影 代码 行内标记 使用`包裹的内容将会以代码样式显示，例如 1使用`printf()` 则会产生 printf() 样式。 代码块 注：与上行距离一空行，根据不同的语言配置不同的代码着色 输入`12345678例如：``` ~~~java public Class HelloWorld&#123; System.out.println(&quot;Hello World!&quot;); &#125; 12345678910 将会产生 ~~~java public Class HelloWorld&#123; System.out.println("Hello World!"); &#125; ~~~例如： 12345var num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num); 演示 12345var num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num); ## 插入图片 我们可以通过拖拉的方式，将本地文件夹中的图片或者网络上的图片插入。 ![drag and drop image](http://typora.io/img/drag-img.gif) --- --- ## 超链接 **Markdown支持两种形式的链接语法：行内式和参考式，行内式一般用的比较多。** ### 行内式： **语法：** 12[打开百度](https://www.baidu.com)[打开百度](https://www.baidu.com "打开百度") 说明:[]里写链接文字，()里写链接地址, ()中的” “中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。`[链接文字](链接地址 &quot;链接标题&quot;)`这样的形式。链接地址与链接标题前有一个空格。 **展示效果:** [打开百度](https://www.baidu.com/) [打开百度](https://www.baidu.com &quot;打开百度&quot;) ### 参考式: 参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 **语法:** 12345我经常浏览的几个网站[Google][1]、[Baidu][2]、[51CTO][3]和看视频的网站[爱奇艺][4]感觉都是很不错的网站。[1]:http://www.google.com "google"[2]:http://www.baidu.com "Baidu"[3]:http://www.51cto.com "51cto"[4]:http://www.aiqiyi.com "aiqiyi" **展示效果：** 我经常浏览的几个网站[Google](http://www.google.com/&quot;google&quot;)、[Baidu](http://www.baidu.com/&quot;Baidu&quot;)、[51CTO](http://www.51cto.com/&quot;51cto&quot;)和看视频的网站[爱奇艺](http://www.aiqiyi.com/&quot;aiqiyi&quot;)感觉都是很不错的网站。 ### 自动连接： **语法：** 12&lt;https://www.baidu.com&gt;&lt;xxx@outlook.com&gt; 说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。 **展示效果：** &lt;https://www.baidu.com&gt; &lt;xxx@outlook.com&gt; ### 锚点 网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。 注意：Markdown Extra 只支持在标题后插入锚点，其它地方无效 #### 页内超链接: **语法：** 12## 引用&#123;#index&#125; 跳转到[引用]&#123;#index&#125; ## 表格 注：`:`代表对齐方式 ， **`:` 与` |` 之间不要有空格** 12345|姓名|性别|毕业学校|工资||:---|:---:|:---:|---:||杨洋|男|重庆交通大学|3200||峰哥|男|贵州大学|5000||坑货|女|北京大学|2000| 将产生: | 姓名 | 性别 | 毕业学校 | 工资 | | :--- | :--: | :----: | ---: | | 杨洋 | 男 | 重庆交通大学 | 3200 | | 峰哥 | 男 | 贵州大学 | 5000 | | 坑货 | 女 | 北京大学 | 2000 | 其中代码的第二行指定对齐的方式，第一个是左对齐，第二个和第三个是居中，最后一个是右对齐。 ### 特殊表格 注：一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的 所以常规的做法是使用HTML标签，但是这样的编写效率极低。 但是有了这款工具的话，所有问题都迎刃而解。 在线生成HTML代码 [Tables Generator](http://www.tablesgenerator.com/) (国外的站) ![img](https:////upload-images.jianshu.io/upload_images/6912209-46aac2b114b995ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp) ​ &lt;u&gt;Tables Generator&lt;/u&gt; **演示** ![img](https:////upload-images.jianshu.io/upload_images/6912209-5e14abef7e65830d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/409/format/webp) ## 内嵌CSS样式 **代码** 1&lt;p style="color: #AD5D0F;font-size: 30px; font-family: '宋体';"&gt;内联样式&lt;/p&gt; **演示** &lt;p style=&quot;color: #AD5D0F;font-size: 30px; font-family: '宋体';&quot;&gt;内联样式&lt;/p&gt; ## 数学公式 ### 数学表达式 要启用这个功能，首先到`Preference`-&gt;`Editor`中启用。然后使用`$`符号包裹Tex命令。 例如： `$lim_{x \to \infty} \ exp(-x)=0$`将产生如下的数学表达式： $\lim_{x \to \infty} \exp(-x)=0$ `$$ x \href{why-equal.html}{=} y^2 + 1 $$`将产生如下的数学表达式： $$ x \href{why-equal.html}{=} y^2 + 1 ​$$ `$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $`将产生如下的数学表达式： $ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. ​$]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-theme-matery]]></title>
    <url>%2F2019%2F02%2F17%2Fhexo-theme-matery%2F</url>
    <content type="text"><![CDATA[hexo-theme-matery English Document | 演示示例 | QQ 交流群: 926552981 这是一个采用 Material Design 和响应式设计的 Hexo 博客主题。 特性 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 下载 当你看到这里的时候，应该已经有一个自己的 Hexo 博客了。如果还没有的话，不妨使用 Hexo 和 Markdown 来写博客和文章。 点击 这里 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。 当然你也可以在你的 themes 文件夹下使用 Git clone 命令来下载: 1git clone https://github.com/blinkfox/hexo-theme-matery.git 配置 切换主题 修改 Hexo 根目录下的 _config.yml 的 theme 的值：theme: hexo-theme-matery _config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 新建分类 categories 页 categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page "categories" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： 123456---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"--- 新建标签 tags 页 tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page "tags" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： 123456---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"--- 新建关于我 about 页 about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page "about" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： 123456---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"--- 新建友情连接 friends 页（可选的） friends 页是用来展示友情连接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page "friends" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： 123456---title: friendsdate: 2018-12-12 21:25:30type: "friends"layout: "friends"--- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： 12345678910111213141516171819[&#123; "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg", "name": "码酱", "introduction": "我不是大佬，只是在追寻大佬的脚步", "url": "http://luokangyuan.com/", "title": "前去学习"&#125;, &#123; "avatar": "http://image.luokangyuan.com/4027734.jpeg", "name": "闪烁之狐", "introduction": "编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬", "url": "https://blinkfox.github.io/", "title": "前去学习"&#125;, &#123; "avatar": "http://image.luokangyuan.com/avatar.jpg", "name": "ja_rome", "introduction": "平凡的脚步也可以走出伟大的行程", "url": "ttps://me.csdn.net/jlh912008548", "title": "前去学习"&#125;] 代码高亮 由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： 1npm i -S hexo-prism-plugin 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下： 12345678highlight: enable: falseprism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 搜索 本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： 1npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123search: path: search.xml field: post 中文链接转拼音（可选的） 如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 安装命令如下： 1npm i hexo-permalink-pinyin --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123permalink_pinyin: enable: true separator: '-' # default: '-' 注：除了此插件外，hexo-abbrlink 插件也可以生成非中文的链接。 文章字数统计插件（可选的） 如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。 安装命令如下： 1npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，激活以下配置项即可： 12345wordCount: enable: false # 将这个值设置为 true 即可. postWordCount: true min2read: true totalCount: true 添加 RSS 订阅支持（可选的） 本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下： 1npm install hexo-generator-feed --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456789feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。 修改页脚 页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 修改社交链接 在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： 123&lt;a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"&gt; &lt;i class="fa fa-github"&gt;&lt;/i&gt;&lt;/a&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fa-facebook Twitter: fa-twitter Google-plus: fa-google-plus Linkedin: fa-linkedin Tumblr: fa-tumblr Medium: fa-medium Slack: fa-slack 新浪微博: fa-weibo 微信: fa-wechat QQ: fa-qq 注意: 本主题中使用的 Font Awesome 版本为 4.7.0。 修改打赏的二维码图片 在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 配置音乐播放器（可选的） 要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。 首先，在你的博客 source 目录下的 _data 目录（没有的话就新建一个）中新建 musics.json 文件，文件内容如下所示： 12345678910111213141516[&#123; "name": "五月雨变奏电音", "artist": "AnimeVibe", "url": "http://xxx.com/music1.mp3", "cover": "http://xxx.com/music-cover1.png"&#125;, &#123; "name": "Take me hand", "artist": "DAISHI DANCE,Cecile Corbel", "url": "/medias/music/music2.mp3", "cover": "/medias/music/cover2.png"&#125;, &#123; "name": "Shape of You", "artist": "J.Fla", "url": "http://xxx.com/music3.mp3", "cover": "http://xxx.com/music-cover3.png"&#125;] 注：以上 JSON 中的属性：name、artist、url、cover 分别表示音乐的名称、作者、音乐文件地址、音乐封面。 然后，在主题的 _config.yml 配置文件中激活配置即可： 1234567891011121314# 是否在首页显示音乐.music: enable: true showTitle: false title: 听听音乐 fixed: false # 是否开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'list' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 listMaxHeight: # 列表最大高度 文章 Front-matter 示例 以下为文章 Front-matter 的示例和说明，所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 123456789101112131415161718---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇 # 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpgimg: /source/images/xxx.jpg# 如果top值为true，则会是首页推荐文章top: true# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行mathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags: - Typora - Markdown--- 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 效果截图 自定制修改 在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分： 菜单 我的梦想 首页的音乐播放器和视频播放器配置 是否显示推荐文章名称和按钮配置 favicon 和 Logo 个人信息 TOC 目录 文章打赏信息 复制文章内容时追加版权信息 MathJax 文章字数统计、阅读时长 点击页面的'爱心'效果 我的项目 我的技能 我的相册 Gitalk、Gitment、Valine 和 disqus 评论配置 不蒜子统计和谷歌分析（Google Analytics） 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图 我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方： 修改主题颜色 在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： 1234567891011121314151617/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color &#123; background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);&#125;/* 和背景颜色相同的文字颜色，目前仅在首页一个地方使用到，你也可以将此样式应用到其他地方. */.text-color &#123; color: #0f9d58 !important;&#125;@-webkit-keyframes rainbow &#123; /* 动态切换背景颜色. */&#125;@keyframes rainbow &#123; /* 动态切换背景颜色. */&#125; 修改 banner 图和文章特色图 你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： 1$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[@[TOC] Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora For Markdown 语法]]></title>
    <url>%2F2019%2F02%2F16%2Ftypora-for-markdown-yu-fa%2F</url>
    <content type="text"><![CDATA[#Typora For Markdown 语法 @[TOC] ###数学表达式 要启用这个功能，首先到Preference-&gt;Editor中启用。然后使用$符号包裹Tex命令，例如：$lim_{x \to \infty} \ exp(-x)=0$将产生如下的数学表达式： $\lim_{x \to \infty} \exp(-x)=0$ ###下标 下标使用~包裹，例如：H~2~O将产生H~2~O, 即水的分子式。 ###上标 上标使用^包裹，例如：y^2^=4将产生表达式y^2^ = 4 ###插入表情:happy: 使用:happy:输入表情:happy:,使用:sad:输入表情:sad:,使用:cry:输入表情:cry:等。以此类推！ 下划线 用HTML的语法&lt;u&gt;Underline&lt;/u&gt;将产生下划线&lt;u&gt;Underline&lt;/u&gt;. 删除线 GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用~~包裹的文本将会具有删除的样式，例如~删除文本~将产生删除文本的样式。 代码 使用`包裹的内容将会以代码样式显示，例如 1使用`printf()` 则会产生printf()样式。 输入`12* 123public Class HelloWorld&#123; System.out.println("Hello World!");&#125; 1234567将会产生~~~javapublic Class HelloWorld&#123; System.out.println("Hello World!");&#125; 强调 使用两个*号或者两个_包裹的内容将会被强调。例如 12**使用两个*号强调内容**__使用两个下划线强调内容__ 将会输出 使用两个号强调内容* 使用两个下划线强调内容 Typroa 推荐使用两个*号。 斜体 在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义： 1\* 插入图片 我们可以通过拖拉的方式，将本地文件夹中的图片或者网络上的图片插入。 插入URL连接 使用尖括号包裹的url将产生一个连接，例如：&lt;www.baidu.com&gt;将产生连接:&lt;www.baidu.com&gt;. 如果是标准的url，则会自动产生连接，例如:www.google.com 目录列表Table of Contents（TOC） 输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。 水平分割线 使用***或者---，然后回车，来产生水平分割线。 标注 我们可以对某一个词语进行标注。例如 12某些人用过了才知道[^注释][^注释]:Somebody that I used to know. 将产生： 某些人用过了才知道[^注释] [^注释]: Somebody that I used to know. 把鼠标放在注释上，将会有提示内容。 表格 12345|姓名|性别|毕业学校|工资||:---|:---:|:---:|---:||杨洋|男|重庆交通大学|3200||峰哥|男|贵州大学|5000||坑货|女|北京大学|2000| 将产生: 姓名 性别 毕业学校 工资 杨洋 男 重庆交通大学 3200 峰哥 男 贵州大学 5000 坑货 女 北京大学 2000 其中代码的第二行指定对齐的方式，第一个是左对齐，第二个和第三个是居中，最后一个是右对齐。 数学表达式块 输入两个美元符号，然后回车，就可以输入数学表达式块了。例如： 1$$\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 = \begin&#123;vmatrix&#125; \mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\\end&#123;vmatrix&#125;$$ 将会产生: $$\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \\end{vmatrix}​$$ $$f(x) = a_1x^n + a_2x^{n-1} + a_3x^{n-2}$$ 任务列表 使用如下的代码创建任务列表，在[]中输入x表示完成，也可以通过点击选择完成或者没完成。 123- [ ] 吃饭- [ ] 逛街- [ ] 看电影 [x] 吃饭 [x] 逛街​ [x] 看电影 列表 输入+, -, *,创建无序的列表，使用任意数字开头，创建有序列表，例如： 1234**无序的列表*** tfboys* 杨洋* 我爱你 无序的列表 tfboys 杨洋 我爱你 1234**有序的列表**1. 苹果6. 香蕉10. 我都不喜欢 有序的列表 苹果 香蕉 我都不喜欢 块引用 使用&gt;来插入块引用。例如： 1&gt;这是一个块引用！ 将产生： 这是一个块引用！ 标题 使用#表示一级标题，##表示二级标题，以此类推，有6个标题。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text]]></title>
    <url>%2F2019%2F02%2F16%2Ftext%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
</search>
