<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【数据结构】数据结构（C语言版）严蔚敏版代码实现]]></title>
    <url>%2F2019%2F06%2F06%2FAll-In-One%2F</url>
    <content type="text"><![CDATA[数据结构（C语言版）专题整理自：这里 第一章 绪论 第二章 线性表 第三章 栈 第三章 队列 第四章 串 第五章 数组和广义表 第六章 树]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】第六章 树]]></title>
    <url>%2F2019%2F06%2F06%2FTree%2F</url>
    <content type="text"><![CDATA[目录 @[TOC] 树和二叉树 二叉树（二叉链表存储）相关类型定义 12345678typedef char TElemType; //假设二叉树元素均为字符typedef struct BiTNode&#123; TElemType data; //结点元素 struct BiTNode* lchild; //左孩子指针 struct BiTNode* rchild; //右孩子指针 &#125;BiTNode; //二叉树结点 typedef BiTNode* BiTree; //指向二叉树结点的指针 栈元素类型 1234typedef BiTree SElemType_Sq; //重定义栈元素类型 #include "../../▲03 栈和队列/01 SequenceStack/SequenceStack.c" //**▲03 栈和队列**// 要用到栈的类型定义 存储当前结点信息，按树结构打印树的时候使用 123456typedef struct &#123; BiTree left; //当前结点的左指针 BiTree right; //当前结点的右指针 int n; //当前结点的次序 &#125;Node; 构造空二叉树T (初始化二叉树) 1234void InitBiTree(BiTree *T)&#123; *T = NULL;&#125; 清空二叉树T 1234567891011121314void ClearBiTree(BiTree *T)&#123; if(*T) //二叉树不为空 &#123; if((*T)-&gt;lchild) //清空左树 ClearBiTree(&amp;((*T)-&gt;lchild)); if((*T)-&gt;rchild) //清空右树 ClearBiTree(&amp;((*T)-&gt;rchild)); free(*T); //释放根结点 *T = NULL; //置空树指针 &#125; &#125; 销毁二叉树T 1234void DestroyBiTree(BiTree *T)&#123; //二叉树无法销毁 &#125; 判断二叉树T是否为空 1234Status BiTreeEmpty(BiTree T)&#123; return T==NULL ? TRUE : ERROR;&#125; 按先序序列构造二叉树_1 1234567891011121314151617181920Status CreateBiTree(FILE *fp, BiTree *T)&#123; char ch; Scanf(fp, "%c", &amp;ch); if(ch == '^') *T = NULL; else &#123; *T = (BiTree)malloc(sizeof(BiTNode)); if(!(*T)) exit(OVERFLOW); (*T)-&gt;data = ch; CreateBiTree(fp, &amp;(*T)-&gt;lchild); CreateBiTree(fp, &amp;(*T)-&gt;rchild); &#125; return OK;&#125; 按先序序列构造二叉树_2 123456789101112131415161718BiTree f(FILE *fp, BiTree *T)&#123; char ch; Scanf(fp, "%c", &amp;ch); if(ch == '^') *T = NULL; else &#123; *T = (BiTree)malloc(sizeof(BiTNode)); if(!(*T)) exit(OVERFLOW); (*T)-&gt;data = ch; CreateBiTree(fp, &amp;(*T)-&gt;lchild); CreateBiTree(fp, &amp;(*T)-&gt;rchild); &#125;&#125; 返回二叉树长度（按完全二叉树计算） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int BiTreeLength(BiTree T)&#123; Node node[100]; //存储结点信息 int i, len; i = len = 0; if(T) &#123; node[i].left = T-&gt;lchild; node[i].right = T-&gt;rchild; node[i].n = 1; if(node[i].n&gt;len) len = node[i].n; while(i&gt;=0) &#123; while(node[i].left) //访问左子树 &#123; node[i+1].left = node[i].left-&gt;lchild; node[i+1].right = node[i].left-&gt;rchild; node[i+1].n = 2*node[i].n; node[i].left = NULL; i++; if(node[i].n&gt;len) len = node[i].n; &#125; if(node[i].right) //左子树为空时访问右子树 &#123; node[i+1].left = node[i].right-&gt;lchild; node[i+1].right = node[i].right-&gt;rchild; node[i+1].n = 2*node[i].n+1; node[i].right = NULL; i++; if(node[i].n&gt;len) len = node[i].n; &#125; if(node[i].left==NULL &amp;&amp; node[i].right==NULL) i--; &#125; &#125; return len;&#125; 返回二叉树深度（层数） 1234567891011121314int BiTreeDepth(BiTree T)&#123; int LD, RD; if(T==NULL) return 0; //空树深度为0 else &#123; LD = BiTreeDepth(T-&gt;lchild); //求左子树深度 RD = BiTreeDepth(T-&gt;rchild); //求右子树深度 return (LD&gt;=RD?LD:RD)+1; &#125;&#125; 用e返回二叉树的根结点值 12345678910Status Root(BiTree T, TElemType *e)&#123; if(!T) return ERROR; else &#123; *e = T-&gt;data; return OK; &#125;&#125; 返回某结点的值，p为结点指针 1234TElemType Value(BiTree p)&#123; return p-&gt;data;&#125; 为某结点赋值，p为结点指针 1234void Assign(BiTree p, TElemType value)&#123; p-&gt;data = value;&#125; 返回某结点的双亲结点值 12345678910111213141516171819202122232425262728293031323334353637TElemType Parent(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(T==NULL || (T!=NULL &amp;&amp; e==T-&gt;data)) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].lchild) &#123; if(node[i].lchild-&gt;data==e) return node[i].data; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].rchild) &#123; if(node[i].rchild-&gt;data==e) return node[i].data; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return '\0'; &#125; 返回某结点的左孩子结点值 1234567891011121314151617181920212223242526272829303132333435363738394041TElemType LeftChild(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(!T) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].data!=e &amp;&amp; node[i].lchild) &#123; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].data==e) &#123; if(node[i].lchild) return node[i].lchild-&gt;data; else return '\0'; &#125; if(node[i].rchild) &#123; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL &amp;&amp; node[i].data!=e) i--; &#125; if(i&lt;0) return '\0'; &#125; 返回某结点的右孩子结点值 12345678910111213141516171819202122232425262728293031323334353637383940TElemType RightChild(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(!T) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].data!=e &amp;&amp; node[i].lchild) &#123; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].data==e) &#123; if(node[i].rchild) return node[i].rchild-&gt;data; else return '\0'; &#125; if(node[i].rchild) &#123; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return '\0';&#125; 返回某结点的左兄弟结点值 12345678910111213141516171819202122232425262728293031323334353637383940414243TElemType LeftSibling(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(T==NULL || (T!=NULL &amp;&amp; e==T-&gt;data)) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].rchild) &#123; if(node[i].rchild-&gt;data==e) &#123; if(node[i].lchild) return node[i].lchild-&gt;data; else return '\0'; &#125; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild) &#123; if(node[i].lchild-&gt;data==e) return '\0'; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return '\0';&#125; 返回某结点的右兄弟结点值 123456789101112131415161718192021222324252627282930313233343536373839404142TElemType RightSibling(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(T==NULL || (T!=NULL &amp;&amp; e==T-&gt;data)) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].lchild) &#123; if(node[i].lchild-&gt;data==e) &#123; if(node[i].rchild) return node[i].rchild-&gt;data; else return '\0'; &#125; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].rchild) &#123; if(node[i].rchild-&gt;data==e) return '\0'; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return '\0';&#125; 获取指向结点e的指针_1 12345678910111213141516171819202122232425262728293031323334353637383940BiTree LocationBiTree_1(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(T==NULL) return NULL; if(T-&gt;data==e) return T; node[i] = *T; while(i&gt;=0) &#123; while(node[i].lchild) &#123; if(node[i].lchild-&gt;data==e) return node[i].lchild; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].rchild) &#123; if(node[i].rchild-&gt;data==e) return node[i].rchild; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return NULL;&#125; 获取指向结点e的指针_2 1234567891011121314151617181920BiTree LocationBiTree_2(BiTree T, TElemType e)&#123; BiTree p = NULL; if(T) &#123; if(T-&gt;data==e) p = T; else &#123; if(p=LocationBiTree_2(T-&gt;lchild, e)) return p; if(p=LocationBiTree_2(T-&gt;rchild, e)) return p; &#125; &#125; return p;&#125; 将树T0插入到树T中成为结点e的子树，LR为插入标记，T0只有左子树 1234567891011121314Status InsertBiTree(BiTree T, TElemType e, BiTree T0, int LR)&#123; BiTree p = LocationBiTree_1(T, e); if(p) &#123; T0-&gt;rchild = LR ? p-&gt;rchild : p-&gt;lchild; LR ? (p-&gt;rchild=T0) : (p-&gt;lchild=T0); return OK; &#125; return ERROR; &#125; 删除e结点的左子树或右子树，LR为删除标记 12345678910111213Status DeleteBiTree(BiTree T, TElemType e, int LR)&#123; BiTree p = LocationBiTree_2(T, e); if(p) &#123; LR ? ClearBiTree(&amp;(p-&gt;rchild)) : ClearBiTree(&amp;(p-&gt;lchild)); return OK; &#125; return ERROR;&#125; 层序遍历二叉树_1（利用数组实现） 1234567891011121314151617181920void LevelOrderTraverse_1(BiTree T, void(Visit)(TElemType))&#123; int i, j; BiTree p[100]; //树指针数组 i = j = 0; if(T) p[j++] = T; while(i&lt;j) &#123; Visit(p[i]-&gt;data); if(p[i]-&gt;lchild) p[j++] = p[i]-&gt;lchild; if(p[i]-&gt;rchild) p[j++] = p[i]-&gt;rchild; i++; &#125;&#125; 层序遍历二叉树_2（利用队列实现） 1234567891011121314151617181920212223Status LevelOrderTraverse_2(BiTree T, Status (*visit)(TElemType e))&#123; BiTree p; LinkQueue Q; InitQueue(Q); p = T; while (p || !QueueEmpty(Q)) &#123; if (p) &#123; visit(p-&gt;data); if (p-&gt;lchild) EnQueue(Q, p-&gt;lchild); if (p-&gt;rchild) EnQueue(Q, p-&gt;rchild); if (!QueueEmpty(Q)) DeQueue(Q, p); else //队列为空时，退出while循环 break; &#125; &#125; return OK;&#125; 先序遍历二叉树_1（递归） 123456789void PreOrderTraverse_1(BiTree T, void(Visit)(TElemType))&#123; if(T) &#123; Visit(T-&gt;data); PreOrderTraverse_1(T-&gt;lchild, Visit); PreOrderTraverse_1(T-&gt;rchild, Visit); &#125;&#125; 先序遍历二叉树_2（递归） 1234567891011121314Status PreOrderTraverse_2(BiTree T, Status(Visit)(TElemType))&#123; if(T) &#123; if(Visit(T-&gt;data)) &#123; PreOrderTraverse_2(T-&gt;lchild, Visit); PreOrderTraverse_2(T-&gt;rchild, Visit); &#125; return OK; &#125; else return ERROR;&#125; 先序遍历二叉树_1（非递归） 123456789101112131415161718192021222324252627282930313233void PreOrderTraverse_3(BiTree T)&#123; SqStack S; SElemType_Sq e; if(!BiTreeEmpty(T)) &#123; InitStack_Sq(&amp;S); Push_Sq(&amp;S, T); while(!StackEmpty_Sq(S)) &#123; GetTop_Sq(S, &amp;e); printf("%c ", e-&gt;data); if(e-&gt;lchild) Push_Sq(&amp;S, e-&gt;lchild); else &#123; while(!StackEmpty_Sq(S)) &#123; Pop_Sq(&amp;S, &amp;e); if(e-&gt;rchild) &#123; Push_Sq(&amp;S, e-&gt;rchild); break; &#125; &#125; &#125; &#125; &#125;&#125; 先序遍历二叉树_2（非递归） 1234567891011121314151617181920212223Status PreOrderTraverse_4(BiTree T, Status (*visit)(TElemType e))&#123; SqStack S; BiTree p; InitStack(S); p = T; while (p || !StackEmpty(S)) &#123; if (p) //访问根指针，左指针进栈 &#123; if (ERROR == visit(p-&gt;data)) return ERROR; Push(S, p); p = p-&gt;lchild; &#125; else &#123; Pop(S, p); p = p-&gt;rchild; &#125; &#125; return OK;&#125; 中序遍历二叉树_1（递归） 123456789void InOrderTraverse_1(BiTree T, void(Visit)(TElemType))&#123; if(T) &#123; InOrderTraverse_1(T-&gt;lchild, Visit); Visit(T-&gt;data); InOrderTraverse_1(T-&gt;rchild, Visit); &#125;&#125; 中序遍历二叉树_2（非递归） 12345678910111213141516171819202122232425Status InOrderTraverse_2(BiTree T, Status(Visit)(TElemType))&#123; SqStack S; SElemType_Sq p; InitStack_Sq(&amp;S); Push_Sq(&amp;S, T); while(!StackEmpty_Sq(S)) &#123; while(GetTop_Sq(S, &amp;p) &amp;&amp; p) //栈顶元素不为空 Push_Sq(&amp;S, p-&gt;lchild); //向左走到尽头 Pop_Sq(&amp;S, &amp;p); //空指针退栈 if(!StackEmpty_Sq(S)) //访问结点，向右一步 &#123; Pop_Sq(&amp;S, &amp;p); if(!Visit(p-&gt;data)) return ERROR; Push_Sq(&amp;S, p-&gt;rchild); &#125; &#125; return OK; &#125; 中序遍历二叉树_3（非递归） 12345678910111213141516171819202122232425Status InOrderTraverse_3(BiTree T, Status(Visit)(TElemType))&#123; SqStack S; SElemType_Sq p; InitStack_Sq(&amp;S); p = T; while(p || !StackEmpty_Sq(S)) &#123; if(p) &#123; Push_Sq(&amp;S, p); p = p-&gt;lchild; &#125; else &#123; Pop_Sq(&amp;S, &amp;p); if(!Visit(p-&gt;data)) return ERROR; p = p-&gt;rchild; &#125; &#125; return OK; &#125; 后序遍历二叉树（递归） 123456789void PostOrderTraverse(BiTree T, void(Visit)(TElemType))&#123; if(T) &#123; PostOrderTraverse(T-&gt;lchild, Visit); PostOrderTraverse(T-&gt;rchild, Visit); Visit(T-&gt;data); &#125;&#125; 后序遍历二叉树_1（非递归） 123456789101112131415161718192021222324252627282930313233343536373839404142434445void PostOrderTraverse_1(BiTree T)&#123; SqStack S; BiTree p; SElemType_Sq e; int StackMark[100] = &#123;&#125;; //模拟栈，设置各结点访问标记 int k; InitStack_Sq(&amp;S); p = T; k = -1; while(1) &#123; while(p) &#123; Push_Sq(&amp;S, p); k++; StackMark[k] = 1; p = p-&gt;lchild; &#125; while(!p &amp;&amp; !StackEmpty_Sq(S)) //p为空但栈不为空 &#123; GetTop_Sq(S, &amp;p); if(StackMark[k]==1) //已访问过一次，当前是第二次访问 &#123; StackMark[k] = 2; p = p-&gt;rchild; &#125; else //已访问过两次，当前是第三次访问 &#123; printf("%c ", p-&gt;data); Pop_Sq(&amp;S, &amp;e); StackMark[k] = 0; k--; p = NULL; &#125; &#125; if(StackEmpty_Sq(S)) break; &#125; &#125; 后序遍历二叉树_2（非递归） 12345678910111213141516171819202122232425262728293031323334353637Status PostOrderTraverse_2(BiTree T, Status (*visit)(TElemType e))&#123; SqStack S; InitStack(S); BiTree p; int Tag[20]; //标志栈 int t = 1; p = T; while (p || !StackEmpty(S)) &#123; while (p) //向左走到尽头 &#123; Push(S, p); p = p-&gt;lchild; Tag[t++] = 0; &#125; while (!StackEmpty(S) &amp;&amp; 1 == Tag[t-1]) //结点标志为1表示右子树已经访问过 &#123; Pop(S, p); t--; if (ERROR == visit(p-&gt;data)) return ERROR; &#125; if (!StackEmpty(S)) //结点标志为0，则访问右子树，并将结点标志置为1 &#123; Tag[t-1] = 1; GetTop(S, p); p = p-&gt;rchild; &#125; else break; &#125; return OK;&#125; 按二叉树的结构打印树 12345678910111213141516171819202122232425262728293031323334353637383940414243void PrintTree(BiTree T)&#123; int row, col; int i, j, m, l, r; BiTNode a[100][100] = &#123;&#125;; //用一个足够大的矩阵按原样存储树 if(T) &#123; row = BiTreeDepth(T); //总行数 col = pow(2, row) - 1; //总列数 for(i=1; i&lt;=row-1; i++) &#123; for(j=1; j&lt;=pow(2, i-1); j++) &#123; m = (2*j-1)*pow(2, row-i); //当前行结点相对位序 l = (4*j-3)*pow(2, row-i-1); //下一行结点相对位序 r = (4*j-1)*pow(2, row-i-1); if(i==1) //初始化 a[i][m] = *T; if(a[i][m].lchild) //下一行 a[i+1][l] = *(a[i][m].lchild); if(a[i][m].rchild) //下一行 a[i+1][r] = *(a[i][m].rchild); &#125; &#125; for(i=1; i&lt;=row; i++) &#123; for(j=1; j&lt;=col; j++) &#123; if(a[i][j].data) printf("%c", a[i][j].data); else printf(" "); &#125; printf("\n"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】第五章 数组和广义表]]></title>
    <url>%2F2019%2F06%2F06%2FArray-and-List%2F</url>
    <content type="text"><![CDATA[目录 @[TOC] 数组和广义表 类型定义 1#define MAXSIZE 400 //假设非零元个数的最大值为400 三元组顺序表(稀疏矩阵)类型定义 123456789101112typedef int MElemType_TSq;typedef struct&#123; int i, j; //该非零元的行下标和列下标 MElemType_TSq e;&#125;Triple;typedef struct&#123; Triple data[MAXSIZE+1]; //非零元三元组表，data[0]未用 int mu, nu, tu; //矩阵的行数、列数和非零元个数&#125;TSMatrix; 创建n个矩阵 12345678910111213141516171819202122232425Status CreateSMatrix_T(FILE *fp, int n, ...)&#123; int count, k; TSMatrix *M; if(n&lt;1) return ERROR; va_list ap; va_start(ap, n); for(count=1; count&lt;=n; count++) &#123; M = va_arg(ap, TSMatrix*); Scanf(fp, "%d%d%d", &amp;((*M).mu), &amp;((*M).nu), &amp;((*M).tu)); for(k=1; k&lt;=(*M).tu; k++) Scanf(fp, "%d%d%d", &amp;((*M).data[k].i), &amp;((*M).data[k].j), &amp;((*M).data[k].e)); &#125; va_end(ap); return OK; &#125; 销毁矩阵 123456void DestroySMatrix_T(TSMatrix *M)&#123; (*M).mu = 0; (*M).nu = 0; (*M).tu = 0;&#125; 输出矩阵 1234567891011121314151617181920void PrintSMatrix_T(TSMatrix M)&#123; int r, c; int k = 1; for(r=1; r&lt;=M.mu; r++) &#123; for(c=1; c&lt;=M.nu; c++) &#123; if(r==M.data[k].i &amp;&amp; c==M.data[k].j) &#123; printf("%3d ", M.data[k].e); k++; &#125; else printf(" 0 "); &#125; printf("\n"); &#125; &#125; 矩阵的复制 1234void CopySMatrix_T(TSMatrix M, TSMatrix *T)&#123; (*T) = M; //结构可以直接复制 &#125; 矩阵的加法Q = M + N 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980Status AddSMatri_T(TSMatrix M, TSMatrix N, TSMatrix *Q)&#123; int m, n, k; if(M.mu!=N.mu || M.nu!=N.nu) &#123; printf("两矩阵不能相加！！\n"); return ERROR; &#125; Q-&gt;mu = M.mu; Q-&gt;nu = M.nu; Q-&gt;tu = 0; m = n = k = 1; while(m&lt;=M.tu &amp;&amp; n&lt;=N.tu) //依次遍历M与N的三元组 &#123; if(M.data[m].i&lt;N.data[n].i) &#123; Q-&gt;data[k] = M.data[m]; m++; &#125; else if(M.data[m].i&gt;N.data[n].i) &#123; Q-&gt;data[k] = N.data[n]; n++; &#125; else //M.data[m].i==N.data[n].i &#123; if(M.data[m].j&lt;N.data[n].j) &#123; Q-&gt;data[k] = M.data[m]; m++; &#125; else if(M.data[m].j&gt;N.data[n].j) &#123; Q-&gt;data[k] = N.data[n]; n++; &#125; else //M.data[m].j==N.data[n].j &#123; if(M.data[m].e+N.data[n].e) &#123; Q-&gt;data[k].i = M.data[m].i; Q-&gt;data[k].j = M.data[m].j; Q-&gt;data[k].e = M.data[m].e + N.data[n].e; m++; n++; &#125; else &#123; m++; n++; continue; &#125; &#125; &#125; k++; Q-&gt;tu++; &#125; while(m&lt;=M.tu) &#123; Q-&gt;data[k] = M.data[m]; m++; k++; Q-&gt;tu++; &#125; while(n&lt;=N.tu) &#123; Q-&gt;data[k] = N.data[n]; n++; k++; Q-&gt;tu++; &#125; return OK;&#125; 矩阵的减法Q = M - N 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586Status SubSMatrix_T(TSMatrix M, TSMatrix N, TSMatrix *Q)&#123; int m, n, k; if(M.mu!=N.mu || M.nu!=N.nu) &#123; printf("两矩阵不能相减！！\n"); return ERROR; &#125; Q-&gt;mu = M.mu; Q-&gt;nu = M.nu; Q-&gt;tu = 0; m = n = k = 1; while(m&lt;=M.tu &amp;&amp; n&lt;=N.tu) &#123; if(M.data[m].i&lt;N.data[n].i) &#123; Q-&gt;data[k] = M.data[m]; m++; &#125; else if(M.data[m].i&gt;N.data[n].i) &#123; Q-&gt;data[k].i = N.data[n].i; Q-&gt;data[k].j = N.data[n].j; Q-&gt;data[k].e = -N.data[n].e; n++; &#125; else //M.data[m].i==N.data[n].i &#123; if(M.data[m].j&lt;N.data[n].j) &#123; Q-&gt;data[k] = M.data[m]; m++; &#125; else if(M.data[m].j&gt;N.data[n].j) &#123; Q-&gt;data[k].i = N.data[n].i; Q-&gt;data[k].j = N.data[n].j; Q-&gt;data[k].e = -N.data[n].e; n++; &#125; else //M.data[m].j==N.data[n].j &#123; if(M.data[m].e-N.data[n].e) &#123; Q-&gt;data[k].i = M.data[m].i; Q-&gt;data[k].j = M.data[m].j; Q-&gt;data[k].e = M.data[m].e - N.data[n].e; m++; n++; &#125; else &#123; m++; n++; continue; &#125; &#125; &#125; k++; Q-&gt;tu++; &#125; while(m&lt;=M.tu) &#123; Q-&gt;data[k] = M.data[m]; m++; k++; Q-&gt;tu++; &#125; while(n&lt;=N.tu) &#123; Q-&gt;data[k].i = N.data[n].i; Q-&gt;data[k].j = N.data[n].j; Q-&gt;data[k].e = -N.data[n].e;; n++; k++; Q-&gt;tu++; &#125; return OK; &#125; 矩阵的乘法Q = M * N 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Status MultSMatrix_T(TSMatrix M, TSMatrix N, TSMatrix *Q)&#123; int m, n, i, j, k; MElemType_TSq c, c1, c2; if(M.nu!=N.mu) //M列数等于N行数 &#123; printf("两矩阵不能相乘！！\n"); return ERROR; &#125; Q-&gt;mu = M.mu; //Q初始化 Q-&gt;nu = N.nu; Q-&gt;tu = 0; if(M.tu*N.tu) //Q是非零矩阵 &#123; for(i=1; i&lt;=M.mu; i++) //传统矩阵乘法 &#123; for(j=1; j&lt;=N.nu; j++) &#123; c = 0; for(k=1; k&lt;=M.nu; k++) &#123; c1 = 0; for(m=1; m&lt;=M.tu; m++) //依次寻找位于指定位置的M三元组 &#123; if(M.data[m].i==i &amp;&amp; M.data[m].j==k) &#123; c1 = M.data[m].e; break; &#125; &#125; c2 = 0; for(n=1; n&lt;=N.tu; n++) //依次寻找位于指定位置的N三元组 &#123; if(N.data[n].i==k &amp;&amp; N.data[n].j==j) &#123; c2 = N.data[n].e; break; &#125; &#125; if(c1 &amp;&amp; c2) c += c1 * c2; &#125; if(c) &#123; Q-&gt;tu++; Q-&gt;data[Q-&gt;tu].i = i; Q-&gt;data[Q-&gt;tu].j = j; Q-&gt;data[Q-&gt;tu].e = c; &#125; &#125; &#125; &#125; return OK;&#125; 矩阵转置 1234567891011121314151617181920212223242526void TransposeSMatrix_T(TSMatrix M, TSMatrix *T)&#123; int p, q, col; T-&gt;mu = M.nu; T-&gt;nu = M.mu; T-&gt;tu = M.tu; if(T-&gt;tu) &#123; q = 1; //q用于T中非零元计数 for(col=1; col&lt;=M.nu; ++col) //col代表M的列，T的行 &#123; for(p=1; p&lt;=M.tu; ++p) //p用于M中非零元计数 &#123; if(M.data[p].j==col) &#123; T-&gt;data[q].i = M.data[p].j; //M的列变为T的行 T-&gt;data[q].j = M.data[p].i; //M的行变为T的列 T-&gt;data[q].e = M.data[p].e; //每个三元组值不变 ++q; &#125; &#125; &#125; &#125;&#125; 矩阵快速转置 123456789101112131415161718192021222324252627282930313233void FastTransposeSMatrix_T(TSMatrix M, TSMatrix *T)&#123; int col, t, p, q; int num[M.nu]; //num[col]表示M第col列中非零元的个数 int copt[M.nu]; //copt[col]表示M第col列第一个非零元在T-&gt;data中恰当的位置 T-&gt;mu = M.nu; T-&gt;nu = M.mu; T-&gt;tu = M.tu; if(T-&gt;tu) &#123; for(col=1; col&lt;=M.nu; ++col) num[col] = 0; //初始化数组num for(t=1; t&lt;=M.tu; ++t) //t遍历M中三元组 num[M.data[t].j]++; //统计M中每列非零元个数 copt[1] = 1; for(col=2; col&lt;=M.nu; ++col) copt[col] = copt[col-1] + num[col-1]; for(p=1; p&lt;=M.tu; ++p) //依次扫描M中的三元组 &#123; col = M.data[p].j; //col为M中第p个三元组中元素的列 q = copt[col]; //q为当前三元组元素在T中应放置的位置 T-&gt;data[q].i = M.data[p].j; T-&gt;data[q].j = M.data[p].i; T-&gt;data[q].e = M.data[p].e; ++copt[col]; //再遇到此列元素时位置增一 &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>数组和广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】第四章 串]]></title>
    <url>%2F2019%2F06%2F06%2FString%2F</url>
    <content type="text"><![CDATA[目录 @[TOC] 串 类型定义 123456/* 串的堆存储表示 */typedef struct&#123; char *ch; //若是非空串，则按串长分配存储区，否则ch为NULL int length;&#125;HString; 初始化S为空串 12345void InitString_H(HString *S)&#123; (*S).ch = NULL; (*S).length = 0;&#125; 生成一个其值等于常量chars的串T 123456789101112131415161718192021222324Status StrAssign_H(HString *T, char *chars)&#123; int i, j; InitString_H(T); i = strlen(chars); if(!i) return ERROR; else &#123; (*T).ch = (char*)malloc(i*sizeof(char)); if(!((*T).ch)) exit(OVERFLOW); for(j=0; j&lt;i; j++) (*T).ch[j] = chars[j]; (*T).length = i; &#125; return OK;&#125; 由串S复制得到串T 1234567891011121314151617181920Status StrCopy_H(HString *T, HString S)&#123; int i; InitString_H(T); if(StrEmpty_H(S)) return ERROR; (*T).ch = (char*)malloc(S.length*sizeof(char)); if(!(*T).ch) exit(OVERFLOW); for(i=0; i&lt;S.length; i++) (*T).ch[i] = S.ch[i]; (*T).length = S.length; return OK;&#125; 若S为空串，返回TRUE,否则返回FALSE 1234567Status StrEmpty_H(HString S)&#123; if(S.length==0 &amp;&amp; S.ch==NULL) return TRUE; else return FALSE;&#125; 若S&gt;T，返回值&gt;0；若S&lt;T，返回值&lt;0；否则，返回值=0 123456789101112Status StrCompare_H(HString S, HString T)&#123; int i; for(i=0; i&lt;S.length&amp;&amp;i&lt;T.length; i++) &#123; if(S.ch[i]!=T.ch[i]) return S.ch[i]-T.ch[i]; &#125; return S.length-T.length;&#125; 求串长 1234567int StrLength_H(HString S)&#123; if(StrEmpty_H(S)) return 0; else return S.length;&#125; 清空串S 123456789101112Status ClearString_H(HString *S)&#123; if((*S).ch) &#123; free((*S).ch); (*S).ch = NULL; &#125; (*S).length = 0; return OK;&#125; 用T返回由S1和S2联接而成的新串 1234567891011121314151617181920Status Concat_H(HString *T, HString S1, HString S2)&#123; int i; InitString_H(T); (*T).length = S1.length + S2.length; (*T).ch = (char*)malloc((*T).length*sizeof(char)); if(!(*T).ch) exit(OVERFLOW); for(i=0; i&lt;S1.length; i++) (*T).ch[i] = S1.ch[i]; for(i=0; i&lt;S2.length; i++) (*T).ch[S1.length+i] = S2.ch[i]; return OK;&#125; 用Sub返回串S的第pos个字符起长度为len的子串 1234567891011121314151617181920212223242526Status SubString_H(HString *Sub, HString S, int pos, int len)&#123; int i; InitString_H(Sub); if(StrEmpty_H(S)) return ERROR; if(pos&lt;1 || pos&gt;S.length || len&lt;0 || pos+len-1&gt;S.length) return ERROR; if(len) //非空子串 &#123; (*Sub).ch = (char*)malloc(len*sizeof(char)); if(!(*Sub).ch) exit(OVERFLOW); for(i=0; i&lt;len; i++) (*Sub).ch[i] = S.ch[i+pos-1]; (*Sub).length = len; &#125; return OK;&#125; 返回T在S中第pos个字符后第一次出现的位置，不存在则返回0 1234567891011121314151617181920212223242526int Index_H(HString S, HString T, int pos)&#123; int s, t, i; HString Sub; InitString_H(&amp;Sub); if(pos&gt;0) &#123; s = S.length; t = T.length; i = pos; while(i+t-1&lt;=s) &#123; SubString_H(&amp;Sub, S, i, t); if(StrCompare_H(Sub, T)) i++; else return i; &#125; &#125; return 0;&#125; 用V替换主串S中出现的所有与T相等的不重叠的子串 12345678910111213141516171819202122Status Replace_H(HString *S, HString T, HString V)&#123; int i; if(StrEmpty_H(T)) return ERROR; i = Index_H(*S, T, 1); while(i!=0) &#123; StrDelete_H(S, i, StrLength_H(T)); StrInsert_H(S, i, V); i += StrLength_H(V); i = Index_H(*S, T, i); &#125; return OK;&#125; 在串S的第pos个字符之前插入串T 1234567891011121314151617181920212223242526Status StrInsert_H(HString *S, int pos, HString T)&#123; int i; if(pos&lt;1 || pos&gt;(*S).length+1) return ERROR; if(StrEmpty_H(T)) return ERROR; else &#123; (*S).ch = (char*)realloc((*S).ch, ((*S).length+T.length)*sizeof(char)); if(!(*S).ch) exit(OVERFLOW); for(i=(*S).length-1; i&gt;=pos-1; i--) //为插入T而腾出位置 (*S).ch[i+T.length] = (*S).ch[i]; for(i=0; i&lt;T.length; i++) (*S).ch[pos-1+i] = T.ch[i]; //插入T (*S).length += T.length; &#125; return OK; &#125; 从串S中删除第pos个字符起长度为len的子串 12345678910111213141516171819Status StrDelete_H(HString *S, int pos, int len)&#123; int i; if(StrEmpty_H(*S)) return ERROR; if(pos&lt;1 || pos+len-1&gt;(*S).length ||len&lt;0) return ERROR; for(i=pos-1; i+len&lt;=(*S).length; i++) (*S).ch[i] = (*S).ch[i+len]; (*S).length -= len; (*S).ch = (char*)realloc((*S).ch, (*S).length*sizeof(char)); //缩小分配的空间 return OK;&#125; 销毁串S 1234void DestroyString_H(HString *S)&#123; //堆串不能被销毁&#125; 输出串S 12345678910void StrPrint_H(HString S)&#123; int i; if(StrEmpty_H(S)) printf("S为空串，不可输出！"); for(i=0; i&lt;S.length; i++) printf("%c", S.ch[i]);&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】第三章 队列]]></title>
    <url>%2F2019%2F06%2F06%2FQueue%2F</url>
    <content type="text"><![CDATA[目录 @[TOC] 非循环队列 类型定义 12345678910111213typedef int QElemType_L;typedef struct QNode &#123; QElemType_L data; struct QNode *next;&#125;QNode,* QueuePtr;typedef struct&#123; QueuePtr front; //头指针 QueuePtr rear; //尾指针 &#125;LinkQueue; //队列的链式存储表示 非循环队列的初始化 1234567891011121314151617181920212223Status InitQueue_L(LinkQueue &amp;Q)&#123; Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); if(!Q.front) exit(OVERFLOW); Q.front-&gt;next = NULL; return OK;&#125;//*******************Status InitQueue_L(LinkQueue *Q)&#123; (*Q).front = (*Q).rear = (QueuePtr)malloc(sizeof(QNode)); if(!(*Q).front) exit(OVERFLOW); (*Q).front-&gt;next = NULL; return OK;&#125; 清空队列 1234567891011121314151617181920212223242526272829void ClearQueue_L(LinkQueue &amp;Q)&#123; Q.rear = Q.front-&gt;next; while(Q.rear) &#123; Q.front-&gt;next = Q.rear-&gt;next; free(Q.rear); Q.rear = Q.front-&gt;next; &#125; Q.rear = Q.front;&#125;//*******************void ClearQueue_L(LinkQueue *Q)&#123; (*Q).rear = (*Q).front-&gt;next; while((*Q).rear) &#123; (*Q).front-&gt;next = (*Q).rear-&gt;next; free((*Q).rear); (*Q).rear = (*Q).front-&gt;next; &#125; (*Q).rear = (*Q).front;&#125; 销毁队列 123456789101112131415161718192021void DestroyQueue_L(LinkQueue &amp;Q)&#123; while(Q.front) &#123; Q.rear = Q.front-&gt;next; free(Q.front); Q.front = Q.rear; &#125;&#125;//*******************void DestroyQueue_L(LinkQueue *Q)&#123; while((*Q).front) &#123; (*Q).rear = (*Q).front-&gt;next; free((*Q).front); (*Q).front = (*Q).rear; &#125;&#125; 判断队列是否为空 1234567Status QueueEmpty_L(LinkQueue Q)&#123; if(Q.front==Q.rear) return TRUE; else return FALSE;&#125; 计算队列的长度 12345678910111213int QueueLength_L(LinkQueue Q)&#123; int count = 0; QueuePtr p = Q.front; while(p!=Q.rear) &#123; count++; p = p-&gt;next; &#125; return count;&#125; 得到队头元素 123456789101112131415161718192021222324252627Status GetHead_L(LinkQueue Q, QElemType_L &amp;e)&#123; QueuePtr p; if(Q.front==Q.rear) return ERROR; p = Q.front-&gt;next; e = p-&gt;data; return OK;&#125; //*******************Status GetHead_L(LinkQueue Q, QElemType_L *e)&#123; QueuePtr p; if(Q.front==Q.rear) return ERROR; p = Q.front-&gt;next; *e = p-&gt;data; return OK;&#125; 入队 1234567891011121314151617181920212223242526272829303132333435Status EnQueue_L(LinkQueue &amp;Q, QElemType_L e)&#123; QueuePtr p; p = (QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-&gt;data = e; p-&gt;next = NULL; Q.rear-&gt;next = p; Q.rear=p; return OK;&#125; //*******************Status EnQueue_L(LinkQueue *Q, QElemType_L e)&#123; QueuePtr p; p = (QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-&gt;data = e; p-&gt;next = NULL; (*Q).rear-&gt;next = p; (*Q).rear=p; return OK;&#125; 出队 123456789101112131415161718192021222324252627282930313233343536373839Status DeQueue_L(LinkQueue &amp;Q, QElemType_L &amp;e)&#123; QueuePtr p; if(Q.front==Q.rear) return ERROR; p = Q.front-&gt;next; e = p-&gt;data; Q.front-&gt;next = p-&gt;next; if(Q.rear==p) Q.rear = Q.front; free(p); return OK;&#125; //*******************Status DeQueue_L(LinkQueue *Q, QElemType_L *e)&#123; QueuePtr p; if((*Q).front==(*Q).rear) return ERROR; p = (*Q).front-&gt;next; *e = p-&gt;data; (*Q).front-&gt;next = p-&gt;next; if((*Q).rear==p) (*Q).rear = (*Q).front; free(p); return OK;&#125; 遍历非循环队列 123456789101112void QueueTraverse_L(LinkQueue Q, void (Visit)(QElemType_L))&#123; QueuePtr p; p = Q.front-&gt;next; while(p) &#123; Visit(p-&gt;data); p = p-&gt;next; &#125;&#125; 循环队列（不设头指针） 假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针） 类型定义 123456789101112typedef int QElemType_L;typedef struct QNode &#123; QElemType_L data; struct QNode *next;&#125;QNode,* QueuePtr;typedef struct&#123; QueuePtr rear; //尾指针 &#125;LinkQueue; //队列的链式存储表示 循环队列初始化 1234567891011Status InitQueue_L(LinkQueue *Q) //队列初始化 &#123; (*Q).rear = (QueuePtr)malloc(sizeof(QNode)); if(!(*Q).rear) exit(OVERFLOW); (*Q).rear-&gt;next = (*Q).rear; //初次创建的(*Q).rear为头结点，且next指向 //自身，达到循环效果。 return OK;&#125; 入队 123456789101112131415Status EnQueue_L(LinkQueue *Q, QElemType e) //入队 &#123; QueuePtr p; p = (QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-&gt;data = e; p-&gt;next = (*Q).rear-&gt;next; //入队后新结点的next始终指向头结点，构成循环队列 (*Q).rear-&gt;next = p; //每次都在队尾入队 (*Q).rear = p; return OK;&#125; 出队 1234567891011121314151617181920Status DeQueue_L(LinkQueue *Q, QElemType *e) //出队 &#123; QueuePtr h, p; h = (*Q).rear-&gt;next; if(h-&gt;next==(*Q).rear-&gt;next) return ERROR; p = h-&gt;next; *e = p-&gt;data; h-&gt;next = p-&gt;next; //当队列只有一个元素时，头结点的next指向自身 if(p==(*Q).rear) //队列只有一个元素 (*Q).rear = h; //rear指向头结点 free(p); return OK;&#125; 遍历循环队列 1234567void Output_L(LinkQueue Q)&#123; QueuePtr p; for(p=Q.rear-&gt;next-&gt;next; p!=Q.rear-&gt;next; p=p-&gt;next) printf("%d ", p-&gt;data);&#125; 循环队列（设头指针） 设置一个标志域tag，并以tag的值为0和1来区分，尾指针和头指针值相同时的队列状态是“空”还是“满”。 类型定义 123456789typedef int QElemType;typedef struct&#123; QElemType *base; int front; int rear; int tag; //0表示空，1表示满 &#125;SqQueue; 队列初始化 123456789Status InitQueue_L(SqQueue *Q)&#123; (*Q).base = (QElemType *)malloc(MAXQSIZE*sizeof(QElemType)); if(!((*Q).base)) exit(OVERFLOW); (*Q).front = (*Q).rear = 0; (*Q).tag = 0;&#125; 入队 12345678910111213Status EnQueue_L(SqQueue *Q, QElemType e)&#123; if((*Q).rear==(*Q).front &amp;&amp; (*Q).tag==1) //队列满 return ERROR; (*Q).base[(*Q).rear] = e; (*Q).rear = ((*Q).rear+1)%MAXQSIZE; if((*Q).rear==(*Q).front) //入队后队满 (*Q).tag = 1; return OK;&#125; 出队 12345678910111213Status DeQueue_L(SqQueue *Q, QElemType *e)&#123; if((*Q).front==(*Q).rear &amp;&amp; (*Q).tag==0) //队列空 return ERROR; *e = (*Q).base[(*Q).front]; (*Q).front = ((*Q).front+1)%MAXQSIZE; if((*Q).rear==(*Q).front) //出队后队空 (*Q).tag = 0; return OK;&#125; 遍历队列 1234567void Output_L(SqQueue Q)&#123; int i; for(i=Q.front; i!=Q.rear; i=(i+1)%MAXQSIZE) printf("%d ", Q.base[i]);&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】第三章 栈]]></title>
    <url>%2F2019%2F06%2F06%2FStack%2F</url>
    <content type="text"><![CDATA[目录 @[TOC] 顺序栈 类型定义 1234567891011#define STACK_INIT_SIZE 100 //顺序栈存储空间的初始分配量#define STACKINCREMENT 10 //顺序栈存储空间的分配增量typedef int SElemType_Sq;typedef struct&#123; SElemType_Sq *base; //在栈构造之前和销毁之后，base的值为NULL SElemType_Sq *top; //栈顶指针 int stacksize; //当前已分配的存储空间，以元素为单位 &#125;SqStack; 栈的初始化 12345678910111213141516171819202122232425Status InitStack_Sq(SqStack &amp;S)&#123; S.base = (SElemType_Sq *)malloc(STACK_INIT_SIZE*sizeof(SElemType_Sq)); if(!S.base) exit(OVERFLOW); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK;&#125; //*******************Status InitStack_Sq(SqStack *S)&#123; (*S).base = (SElemType_Sq *)malloc(STACK_INIT_SIZE*sizeof(SElemType_Sq)); if(!(*S).base) exit(OVERFLOW); (*S).top = (*S).base; (*S).stacksize = STACK_INIT_SIZE; return OK;&#125; 销毁栈 1234567891011121314151617181920212223Status DestroyStack_Sq(SqStack &amp;S)&#123; free(S.base); S.base = NULL; S.top = NULL; S.stacksize = 0; return OK;&#125; //*******************Status DestroyStack_Sq(SqStack *S)&#123; free((*S).base); (*S).base = NULL; (*S).top = NULL; (*S).stacksize = 0; return OK;&#125; 清空栈 123456789101112131415Status ClearStack_Sq(SqStack &amp;S)&#123; S.top = S.base; return OK;&#125; //*******************Status ClearStack_Sq(SqStack *S)&#123; (*S).top = (*S).base; return OK;&#125; 判断栈是否为空 1234567Status StackEmpty_Sq(SqStack S)&#123; if(S.top==S.base) return TRUE; else return FALSE;&#125; 计算栈的长度 1234int StackLength_Sq(SqStack S)&#123; return S.top - S.base;&#125; 得到栈顶元素 1234567891011121314151617181920212223Status GetTop_Sq(SqStack S, SElemType_Sq &amp;e)&#123; if(S.top==S.base) return ERROR; e = *(S.top - 1); //并不破坏栈 return OK;&#125; //*******************Status GetTop_Sq(SqStack S, SElemType_Sq *e)&#123; if(S.top==S.base) return ERROR; *e = *(S.top - 1); //并不破坏栈 return OK;&#125; 入栈 1234567891011121314151617181920212223242526272829303132333435Status Push_Sq(SqStack &amp;S, SElemType_Sq e)&#123; if(S.top-S.base&gt;=S.stacksize) //栈满，追加存储空间 &#123; S.base = (SElemType_Sq *)realloc(S.base, (S.stacksize+STACKINCREMENT)*sizeof(SElemType_Sq)); if(!S.base) exit(OVERFLOW); //存储分配失败 S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; &#125; *(S.top) = e; //进栈先赋值，栈顶指针再自增 (S.top)++; return OK;&#125; //*******************Status Push_Sq(SqStack *S, SElemType_Sq e)&#123; if((*S).top-(*S).base&gt;=(*S).stacksize) //栈满，追加存储空间 &#123; (*S).base = (SElemType_Sq *)realloc((*S).base, ((*S).stacksize+STACKINCREMENT)*sizeof(SElemType_Sq)); if(!(*S).base) exit(OVERFLOW); //存储分配失败 (*S).top = (*S).base + (*S).stacksize; (*S).stacksize += STACKINCREMENT; &#125; *(S-&gt;top) = e; //进栈先赋值，栈顶指针再自增 (S-&gt;top)++; return OK;&#125; 出栈 1234567891011121314151617181920212223Status Pop_Sq(SqStack &amp;S, SElemType_Sq &amp;e)&#123; if(S.top==S.base) return ERROR; S.top--; //出栈栈顶指针先递减，再赋值 e = *(S.top); return OK;&#125; //*******************Status Pop_Sq(SqStack *S, SElemType_Sq *e)&#123; if((*S).top==(*S).base) return ERROR; (*S).top--; //出栈栈顶指针先递减，再赋值 *e = *((*S).top); return OK;&#125; 遍历栈中元素 123456789Status StackTraverse_Sq(SqStack S, void(Visit)(SElemType_Sq))&#123; //遍历不应该破坏栈 SElemType_Sq *p = S.base; while(p&lt;S.top) Visit(*p++); return OK;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】第二章 线性表]]></title>
    <url>%2F2019%2F06%2F06%2FList%2F</url>
    <content type="text"><![CDATA[目录 @[TOC] 顺序线性表（数组） 类型定义 12345typedef struct&#123; ElemType data[MAXSIZE]; /* 数组，存储数据元素 */ int length; /* 线性表当前长度 */&#125;SqList; 初始化顺序线性表 12345Status InitList(SqList *L) &#123; L-&gt;length=0; return OK;&#125; 判断顺序表是否为空 1234567Status ListEmpty(SqList L)&#123; if(L.length==0) return TRUE; else return FALSE;&#125; 清空顺序表 12345Status ClearList(SqList *L)&#123; L-&gt;length=0; return OK;&#125; 计算顺序表的长度 1234int ListLength(SqList L)&#123; return L.length;&#125; 用e返回L中第i个数据元素的值 12345678Status GetElem(SqList L,int i,ElemType *e)&#123; if(L.length==0 || i&lt;1 || i&gt;L.length) return ERROR; *e=L.data[i-1]; return OK;&#125; 返回L中第1个与e满足关系的数据元素的位序 123456789101112131415int LocateElem(SqList L,ElemType e)&#123; int i; if (L.length==0) return 0; for(i=0;i&lt;L.length;i++) &#123; if (L.data[i]==e) break; &#125; if(i&gt;=L.length) return 0; return i+1;&#125; 在L中第i个位置之前插入新的数据元素e 123456789101112131415161718Status ListInsert(SqList *L,int i,ElemType e)&#123; int k; if (L-&gt;length==MAXSIZE) /* 顺序线性表已经满 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length+1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */ return ERROR; if (i&lt;=L-&gt;length) /* 若插入数据位置不在表尾 */ &#123; for(k=L-&gt;length-1;k&gt;=i-1;k--) /* 将要插入位置之后的数据元素向后移动一位 */ L-&gt;data[k+1]=L-&gt;data[k]; &#125; L-&gt;data[i-1]=e; /* 将新元素插入 */ L-&gt;length++; return OK;&#125; 删除L的第i个数据元素，并用e返回其值 12345678910111213141516Status ListDelete(SqList *L,int i,ElemType *e) &#123; int k; if (L-&gt;length==0) /* 线性表为空 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length) /* 删除位置不正确 */ return ERROR; *e=L-&gt;data[i-1]; if (i&lt;L-&gt;length) /* 如果删除不是最后位置 */ &#123; for(k=i;k&lt;L-&gt;length;k++)/* 将删除位置后继元素前移 */ L-&gt;data[k-1]=L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; 遍历顺序线性表 12345678Status ListTraverse(SqList L)&#123; int i; for(i=0;i&lt;L.length;i++) visit(L.data[i]); printf("\n"); return OK;&#125; 合并La、Lb两个顺序线性表 12345678910111213void unionL(SqList *La,SqList Lb)&#123; int La_len,Lb_len,i; ElemType e; La_len=ListLength(*La); Lb_len=ListLength(Lb); for (i=1;i&lt;=Lb_len;i++) &#123; GetElem(Lb,i,&amp;e); if (!LocateElem(*La,e)) ListInsert(La,++La_len,e); &#125;&#125; 静态链表（数组） 类型定义 12345typedef struct &#123; ElemType data; int cur; /* 游标(Cursor) ，为0时表示无指向 */&#125; Component,StaticLinkList[MAXSIZE]; 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针 12345678Status InitList(StaticLinkList space) &#123; int i; for (i=0; i&lt;MAXSIZE-1; i++) space[i].cur = i+1; space[MAXSIZE-1].cur = 0; /* 目前静态链表为空，最后一个元素的cur为0 */ return OK;&#125; 若备用空间链表非空，则返回分配的结点下标，否则返回0 12345678910int Malloc_SSL(StaticLinkList space) &#123; int i = space[0].cur; /* 当前数组第一个元素的cur存的值 */ /* 就是要返回的第一个备用空闲的下标 */ if (space[0]. cur) space[0]. cur = space[i].cur; /* 由于要拿出一个分量来使用了， */ /* 所以我们就得把它的下一个 */ /* 分量用来做备用 */ return i;&#125; 将下标为k的空闲结点回收到备用链表 12345void Free_SSL(StaticLinkList space, int k) &#123; space[k].cur = space[0].cur; /* 把第一个元素的cur值赋给要删除的分量cur */ space[0].cur = k; /* 把要删除的分量下标赋值给第一个元素的cur */&#125; 计算静态链表的长度 1234567891011int ListLength(StaticLinkList L)&#123; int j=0; int i=L[MAXSIZE-1].cur; while(i) &#123; i=L[i].cur; j++; &#125; return j;&#125; 在L中第i个元素之前插入新的数据元素e 123456789101112131415161718Status ListInsert(StaticLinkList L, int i, ElemType e) &#123; int j, k, l; k = MAXSIZE - 1; /* 注意k首先是最后一个元素的下标 */ if (i &lt; 1 || i &gt; ListLength(L) + 1) return ERROR; j = Malloc_SSL(L); /* 获得空闲分量的下标 */ if (j) &#123; L[j].data = e; /* 将数据赋值给此分量的data */ for(l = 1; l &lt;= i - 1; l++) /* 找到第i个元素之前的位置 */ k = L[k].cur; L[j].cur = L[k].cur; /* 把第i个元素之前的cur赋值给新元素的cur */ L[k].cur = j; /* 把新元素的下标赋值给第i个元素之前元素的ur */ return OK; &#125; return ERROR; &#125; 删除在L中第i个数据元素 12345678910111213Status ListDelete(StaticLinkList L, int i) &#123; int j, k; if (i &lt; 1 || i &gt; ListLength(L)) return ERROR; k = MAXSIZE - 1; for (j = 1; j &lt;= i - 1; j++) k = L[k].cur; j = L[k].cur; L[k].cur = L[j].cur; Free_SSL(L, j); return OK; &#125; 遍历静态链表 1234567891011121314Status ListTraverse(StaticLinkList L)&#123; int j=0; int i=L[MAXSIZE-1].cur; while(i) &#123; visit(L[i].data); i=L[i].cur; j++; &#125; return j; printf("\n"); return OK;&#125; 非循环单向线性表 类型定义 1234567891011#define LIST_INIT_SIZE 100 //顺序表存储空间的初始分配量 #define LISTINCREMENT 10 //顺序表存储空间的分配增量typedef int LElemType_Sq;typedef struct&#123; LElemType_Sq *elem; //存储空间基址（指向第一个结点的指针） int length; //当前顺序表长度 int listsize; //当前分配的存储容量 &#125;SqList; 初始化线性表 1234567891011Status InitList_Sq(SqList *L)&#123; (*L).elem = (LElemType_Sq*)malloc(LIST_INIT_SIZE*sizeof(LElemType_Sq)); if(!(*L).elem) exit(OVERFLOW); //分配内存失败 (*L).length = 0; //初始化顺序表长度为0 (*L).listsize = LIST_INIT_SIZE; //顺序表初始内存分配量 return OK; //初始化成功 &#125; 清空线性表 1234void ClearList_Sq(SqList *L)&#123; (*L).length = 0;&#125; 销毁线性表 12345678void DestroyList_Sq(SqList *L)&#123; free((*L).elem); (*L).elem = NULL; //释放内存后置空指针 (*L).length = 0; (*L).listsize = 0;&#125; 判断线性表是否为空 1234Status ListEmpty_Sq(SqList L)&#123; return L.length==0 ? TRUE : FALSE;&#125; 计算线性表的长度 1234int ListLength_Sq(SqList L)&#123; return L.length; &#125; 用e接收顺序表L中第i个元素 123456789Status GetElem_Sq(SqList L, int i, LElemType_Sq *e)&#123; if(i&lt;1 || i&gt;L.length) return ERROR; //i值不合法 else *e = L.elem[i-1]; return OK;&#125; 返回顺序表L中首个与e满足Compare关系的元素位序 123456789101112int LocateElem_Sq(SqList L, LElemType_Sq e, Status(Compare)(LElemType_Sq, LElemType_Sq))&#123; int i = 1; //i的初值为第一个元素的位序 while(i&lt;=L.length &amp;&amp; !Compare(e, L.elem[i-1])) ++i; if(i&lt;=L.length) return i; else return 0; &#125; 用pre_e接收cur_e的前驱 123456789101112131415161718Status PriorElem_Sq(SqList L, LElemType_Sq cur_e, LElemType_Sq *pre_e)&#123; int i = 1; if(L.elem[0]!=cur_e) //第一个结点无前驱 &#123; while(i&lt;L.length &amp;&amp; L.elem[i]!=cur_e) ++i; if(i&lt;L.length) &#123; *pre_e = L.elem[i-1]; return OK; &#125; &#125; return ERROR;&#125; 用next_e接收cur_e的后继 123456789101112131415Status NextElem_Sq(SqList L, LElemType_Sq cur_e, LElemType_Sq *next_e)&#123; int i = 0; while(i&lt;L.length &amp;&amp; L.elem[i]!=cur_e) ++i; if(i&lt;L.length-1) //最后一个结点无后继 &#123; *next_e = L.elem[i+1]; return OK; &#125; return ERROR;&#125; 在顺序表L的第i个位置上插入e 12345678910111213141516171819202122232425262728Status ListInsert_Sq(SqList *L, int i, LElemType_Sq e)&#123; LElemType_Sq *newbase; LElemType_Sq *p, *q; if(i&lt;1 || i&gt;(*L).length+1) return ERROR; //i值不合法 if((*L).length &gt;= (*L).listsize) //若存储空间已满，需开辟新空间 &#123; newbase = (LElemType_Sq*)realloc((*L).elem, ((*L).listsize+LISTINCREMENT)*sizeof(LElemType_Sq)); if(!newbase) exit(OVERFLOW); (*L).elem = newbase; (*L).listsize += LISTINCREMENT; &#125; q = &amp;(*L).elem[i-1]; //q为插入位置 for(p=&amp;(*L).elem[(*L).length-1]; p&gt;=q; --p) *(p+1) = *p; //插入位置及之后的元素右移 *q = e; //插入e (*L).length++; //表长增1 return OK; &#125; 删除顺序表L上第i个位置的元素，并用e返回 123456789101112131415161718Status ListDelete_Sq(SqList *L, int i, LElemType_Sq *e)&#123; LElemType_Sq *p, *q; if(i&lt;1 || i&gt;(*L).length) return ERROR; //i值不合法 p = &amp;(*L).elem[i-1]; //p为被删除元素的位置 *e = *p; q = (*L).elem+(*L).length-1; //表尾元素位置 for(++p; p&lt;=q; ++p) *(p-1) = *p; //被删元素之后的元素左移 (*L).length--; //表长减1 return OK;&#125; 用visit函数访问顺序表L 123456789Status ListTraverse_Sq(SqList L, void(Visit)(LElemType_Sq))&#123; int i; for(i=0; i&lt;L.length; i++) Visit(L.elem[i]); return OK;&#125;]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数据结构】第一章 绪论]]></title>
    <url>%2F2019%2F06%2F06%2FPreface%2F</url>
    <content type="text"><![CDATA[目录 @[TOC] 预定义常量和类型 1234567891011//函数结果状态代码#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2//Status是函数的类型，其值是函数结果状态代码typedef int Status;typedef int ElemType; Visit遍历函数 12345Status Visit(ElemType c)&#123; printf("%d ",c); return OK;&#125; 自定义Scanf函数 自定义的数据录入函数，用于从文件fp中读取格式化的输入。 与fscanf不同之处在于此函数只会读取西文字符，对于中文字符，则会跳过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100int Scanf(FILE *fp, char *format, ...)&#123; int *i; char *ch, *s; float *f; int count, k, len, n; int tmp; va_list ap; len = strlen(format); va_start(ap, format); for(count=0,k=2; k&lt;=len; k=k+2) &#123; while((tmp=getc(fp))!=EOF) //跳过所有非西文字符 &#123; if((tmp&gt;=0 &amp;&amp; tmp&lt;=127)) &#123; ungetc(tmp, fp); //遇到首个西文字符，将此西文字符放入输入流 break; &#125; &#125; if(tmp==EOF) break; if(format[k-1]=='c') //读取字符 &#123; ch = va_arg(ap, char*); if(tmp!=EOF) count += fscanf(fp, "%c", ch); &#125; if(format[k-1]=='d') //读取整型 &#123; i = va_arg(ap, int*); while((tmp=getc(fp))!=EOF) &#123; if((tmp&gt;='0' &amp;&amp; tmp&lt;='9') || tmp=='-' || tmp=='+') &#123; ungetc(tmp, fp); break; &#125; &#125; if(tmp!=EOF) count += fscanf(fp, "%d", i); &#125; if(format[k-1]=='f') //读取浮点型 &#123; f = va_arg(ap, float*); while((tmp=getc(fp))!=EOF) &#123; if((tmp&gt;='0' &amp;&amp; tmp&lt;='9') || tmp=='-' || tmp=='+'|| tmp=='.' ) &#123; ungetc(tmp, fp); break; &#125; &#125; if(tmp!=EOF) count += fscanf(fp, "%f", f); &#125; if(format[k-1]=='s') //读取字符串 &#123; s = va_arg(ap, char*); while((tmp=getc(fp))!=EOF &amp;&amp; (!isprint(tmp) || tmp==' ')) ; n = 0; if(!feof(fp)) &#123; ungetc(tmp, fp); while((tmp=getc(fp))!=EOF) &#123; if(isprint(tmp) &amp;&amp; tmp!=' ') s[n++] = tmp; else break; &#125; ungetc(tmp, fp); &#125; s[n] = '\0'; count++; &#125; &#125; va_end(ap); return count;&#125; 形参部分可以使用省略号 ==C++==允许定义形参个数和类型不确定的函数。例如，C语言中的标准函数printf便使用这种机制。在声明不确定形参的函数时，==形参部分可以使用省略号“…”代替。==“…”告诉编译器，在函数调用时不检查形参类型是否与实参类型相同，也不检查参数个数。 即省略参数：用省略号…表示, ==省略号出现的地方可以有任意个任意类型的参数。==例如常用的printf函数： int printf (const char *format, …); 引用 &lt;stdarg.h&gt; 头文件 例如： void ConnectData(int i,...); 在上面的代码中，编译器只检查第一个参数是否为整型，而不对其他参数进行检查。 对于可变参数的函数，需要进行特殊的处理。首先需要==引用 &lt;stdarg.h&gt; 头文件==，然后利用==va_list类型和va_start、va_arg、va_end== 3个宏读取传递到函数中的参数值。 1#include &lt;stdarg.h&gt; //提供宏va_list、va_start、va_arg、va_end 这几个宏的定义如下（在 ANSI C 中）： 123type va_arg( va_list arg_ptr, type );void va_end( va_list arg_ptr );void va_start( va_list arg_ptr, prev_param ); va_start函数 va_start函数将参数arg_ptr设置为可变参数列表的第一个参数。参数arg_ptr的类型必须为va_list。参数prev_param是在可变参数列表之前的那一个参数。（也就是说在 ANSI C 中，如果一个函数有可变参数，那么在该可变参数前必须有一个明确定义的参数，否则无法调用函数 va_start ，例如函数 int add(int i,...）是合法的，而函数 int add(...)是不合法的。） va_arg函数 va_arg函数将返回 arg_ptr 所指位置的值，并将 arg_ptr 指向下一个参数 va_end函数 检索完所有参数后，va_end将指针重置为NULL。]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>绪论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法简易指南]]></title>
    <url>%2F2019%2F02%2F23%2FMarkdown%2F</url>
    <content type="text"><![CDATA[注：本站使用Typora软件编辑 目录 @[TOC] 目录列表 输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。 标题 使用#表示一级标题，##表示二级标题，以此类推，有6个标题。 注：# 后面保持空格 引用 单行式 使用 &gt; 来插入块引用。例如： 1&gt; hello world! 演示： hello world! 多行式 123&gt; hello world!hello world!hello world! 或者 123&gt; hello world!&gt; hello world!&gt; hello world! 演示 相同的结果 hello world! hello world! hello world! 多层嵌套 12345678910&gt; aaaaaaaaa&gt; &gt; &gt; bbbbbbbbb&gt; &gt; &gt; &gt; &gt; cccccccccc&gt; &gt; &gt; &gt; &gt;&gt; &gt;&gt;&gt; 演示 aaaaaaaaa bbbbbbbbb cccccccccc 语义标记 描述 效果 代码 斜体 斜体 *斜体* 斜体 斜体 _斜体_ 加粗 加粗 **加粗** 加粗+斜体 加粗+斜体 ***加粗+斜体*** 加粗+斜体 加粗+斜体 **_加粗+斜体_** 删除线 删除线 ~~删除线~~ 斜体 在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义： 1\* 加粗 (强调) 使用两个*号或者两个_包裹的内容将会被加粗。例如 12**使用两个*号加粗内容**__使用两个下划线加粗内容__ 将会输出 使用两个号加粗内容* 使用两个下划线加粗内容 Typroa 推荐使用两个*号。 删除线 GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用~~包裹的文本将会具有删除的样式，例如~删除文本~将产生删除文本的样式。 转义 markdown支持在以下字符前面插入反斜杠 123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 插入之后，将不再解析这些字符，而是原样输出。 高亮 高亮使用==包裹，例如：==高亮==将产生==高亮== 下标 下标使用~包裹，例如：H~2~O将产生H~2~O, 即水的分子式。 上标 上标使用^包裹，例如：y^2^=4将产生表达式y^2^ = 4 插入表情:happy: 使用:happy:输入表情:happy:,使用:sad:输入表情:sad:,使用:cry:输入表情:cry:等。以此类推！ 下划线 用HTML的语法&lt;u&gt;Underline&lt;/u&gt;将产生下划线&lt;u&gt;Underline&lt;/u&gt;. 水平分割线 使用***或者---，然后回车，来产生水平分割线。 注释 我们可以对某一个词语进行注释。例如 12某些人用过了才知道[^注释][^注释]:Somebody that I used to know. 将产生： 某些人用过了才知道[^注释] [^注释]: Somebody that I used to know. 把鼠标放在注释上，将会有提示内容。 列表 注：序列.后 保持空格 无序列表 输入+, -, *创建无序的列表，使用任意数字开头，创建有序列表，例如： 1234**无序的列表*** one* two* three 演示 无序的列表 one two three 有序列表 1234**有序的列表**1. one2. two3. three 演示 有序的列表 one two three 序表嵌套 1234561. one 1. one-1 2. two-22. two * two-1 * two-2 演示 one one-1 two-2 two two-1 two-2 层级列表 1234* 总目录 * 一级目录 * 二级目录 * 三级目录 说明：层级列表一般只支持三级列表，第一级实心圆点，第二级空心圆点，第三级以后都是实心方点。要实现层级列表，每下一级都要比上一级多输入2个空格或者一个Tab，而且第一级前面不要超过3个空格. 演示 总目录 一级目录 二级目录 三级目录 序表嵌套代码块 注：换行+两个Tab 12* one var a = 10; // 与上行保持空行并递进缩进 演示 one 1var a = 10; 任务列表 使用如下的代码创建任务列表，在[ ]中输入x表示完成，也可以通过点击选择完成或者没完成。 123- [ ] 吃饭- [ ] 逛街- [ ] 看电影 演示 [x] 吃饭 [x] 逛街 [x] 看电影 代码 行内标记 使用`包裹的内容将会以代码样式显示，例如 1使用`printf()` 则会产生 printf() 样式。 代码块 注：与上行距离一空行，根据不同的语言配置不同的代码着色 输入```或者~~~然后回车，可以输入代码块，并且可以选择代码的语言。 例如： 12345~~~javapublic Class HelloWorld&#123; System.out.println("Hello World!");&#125;~~~ 演示 123public Class HelloWorld&#123; System.out.println("Hello World!");&#125; 例如： 1234567~~~javascriptvar num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num);~~~ 演示 12345var num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num); 插入图片 我们可以通过拖拉的方式，将本地文件夹中的图片或者网络上的图片插入。 超链接 Markdown支持两种形式的链接语法：行内式和参考式，行内式一般用的比较多。 行内式 语法: 12[打开百度](https://www.baidu.com)[打开百度](https://www.baidu.com "打开百度") 说明:[]里写链接文字，()里写链接地址, ()中的” “中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 &quot;链接标题&quot;)这样的形式。链接地址与链接标题前有一个空格。 展示效果 打开百度 打开百度 参考式 参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法: 12345我经常浏览的几个网站[Google][1]、[Baidu][2]、[51CTO][3]和看视频的网站[爱奇艺][4]感觉都是很不错的网站。[1]:http://www.google.com "google"[2]:http://www.baidu.com "Baidu"[3]:http://www.51cto.com "51cto"[4]:http://www.aiqiyi.com "aiqiyi" 展示效果 我经常浏览的几个网站Google、Baidu、51CTO和看视频的网站爱奇艺感觉都是很不错的网站。 自动连接 语法: 12&lt;https://www.baidu.com&gt;&lt;xxx@outlook.com&gt; 说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。 展示效果 https://www.baidu.com xxx@outlook.com 锚点 网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。 注意：Markdown Extra 只支持在标题后插入锚点，其它地方无效 表格 注：:代表对齐方式 ， : 与| 之间不要有空格 12345|姓名|性别|毕业学校|工资||:---|:---:|:---:|---:||杨洋|男|重庆交通大学|3200||峰哥|男|贵州大学|5000||坑货|女|北京大学|2000| 将产生: 姓名 性别 毕业学校 工资 杨洋 男 重庆交通大学 3200 峰哥 男 贵州大学 5000 坑货 女 北京大学 2000 其中代码的第二行指定对齐的方式，第一个是左对齐，第二个和第三个是居中，最后一个是右对齐。 特殊表格 注：一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的 所以常规的做法是使用HTML标签，但是这样的编写效率极低。 但是有了这款工具的话，所有问题都迎刃而解。 在线生成HTML代码 Tables Generator (国外的站) ​ &lt;u&gt;Tables Generator&lt;/u&gt; 演示 内嵌CSS样式 代码 1&lt;p style="color: #AD5D0F;font-size: 30px; font-family: '宋体';"&gt;内联样式&lt;/p&gt; 演示 &lt;p style=&quot;color: #AD5D0F;font-size: 30px; font-family: '宋体';&quot;&gt;内联样式&lt;/p&gt; 数学公式 注：本站默认关闭数学公式渲染效果 数学表达式 要启用这个功能，首先到Preference-&gt;Editor中启用。然后使用$符号包裹Tex命令。 例如： $lim_{x \to \infty} \ exp(-x)=0$将产生如下的数学表达式： $\lim_{x \to \infty} \exp(-x)=0$ $$ x \href{why-equal.html}{=} y^2 + 1 $$将产生如下的数学表达式： $$ x \href{why-equal.html}{=} y^2 + 1 ​$$ $ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $将产生如下的数学表达式： $ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $ 参考资料： https://ouweiya.gitbooks.io/markdown/index.html https://www.jianshu.com/p/b03a8d7b1719 https://segmentfault.com/markdown#articleHeader4 https://wizardforcel.gitbooks.io/markdown-simple-world/0.html https://coding.net/help/doc/project/markdown.html https://guo365.github.io/study/Markdown.html https://yuedu.baidu.com/ebook/f2ec7e699a6648d7c1c708a1284ac850ad020418]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
