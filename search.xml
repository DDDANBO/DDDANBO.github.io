<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F04%2F14%2Fzong-zhang%2F</url>
    <content type="text"><![CDATA[[TOC] 第一章 常用算法杂项第二章 C语言程序设计第三章 数据结构基本操作预定义常量和类型1234567891011//函数结果状态代码#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2//Status是函数的类型，其值是函数结果状态代码typedef int Status;typedef int ElemType; Visit遍历函数12345Status Visit(ElemType c)&#123; printf("%d ",c); return OK;&#125; 自定义Scanf函数 自定义的数据录入函数，用于从文件fp中读取格式化的输入。与fscanf不同之处在于此函数只会读取西文字符，对于中文字符，则会跳过。 形参部分可以使用省略号 ==C++==允许定义形参个数和类型不确定的函数。例如，C语言中的标准函数printf便使用这种机制。在声明不确定形参的函数时，==形参部分可以使用省略号“…”代替。==“…”告诉编译器，在函数调用时不检查形参类型是否与实参类型相同，也不检查参数个数。 即省略参数：用省略号…表示, ==省略号出现的地方可以有任意个任意类型的参数。==例如常用的printf函数：int printf (const char *format, …); 引用 &lt;stdarg.h&gt; 头文件的va_list、va_start、va_arg、va_end 例如： void ConnectData(int i,…); 在上面的代码中，编译器只检查第一个参数是否为整型，而不对其他参数进行检查。 对于可变参数的函数，需要进行特殊的处理。首先需要==引用 &lt;stdarg.h&gt; 头文件==，然后利用va_list类型和va_start、va_arg、va_end 3个宏读取传递到函数中的参数值。 12&gt; #include &lt;stdarg.h&gt; //提供宏va_list、va_start、va_arg、va_end&gt; 这几个宏的定义如下（在 ANSI C 中）： 1234&gt; type va_arg( va_list arg_ptr, type );&gt; void va_end( va_list arg_ptr );&gt; void va_start( va_list arg_ptr, prev_param ); &gt; va_start函数 va_start函数将参数arg_ptr设置为可变参数列表的第一个参数。参数arg_ptr的类型必须为va_list。参数prev_param是在可变参数列表之前的那一个参数。（也就是说在 ANSI C 中，如果一个函数有可变参数，那么在该可变参数前必须有一个明确定义的参数，否则无法调用函数 va_start ，例如函数 int add(int i,…）是合法的，而函数 int add(…)是不合法的。） va_arg函数 va_arg函数将返回 arg_ptr 所指位置的值，并将 arg_ptr 指向下一个参数 va_end函数 检索完所有参数后，va_end将指针重置为NULL。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100int Scanf(FILE *fp, char *format, ...)&#123; int *i; char *ch, *s; float *f; int count, k, len, n; int tmp; va_list ap; len = strlen(format); va_start(ap, format); for(count=0,k=2; k&lt;=len; k=k+2) &#123; while((tmp=getc(fp))!=EOF) //跳过所有非西文字符 &#123; if((tmp&gt;=0 &amp;&amp; tmp&lt;=127)) &#123; ungetc(tmp, fp); //遇到首个西文字符，将此西文字符放入输入流 break; &#125; &#125; if(tmp==EOF) break; if(format[k-1]=='c') //读取字符 &#123; ch = va_arg(ap, char*); if(tmp!=EOF) count += fscanf(fp, "%c", ch); &#125; if(format[k-1]=='d') //读取整型 &#123; i = va_arg(ap, int*); while((tmp=getc(fp))!=EOF) &#123; if((tmp&gt;='0' &amp;&amp; tmp&lt;='9') || tmp=='-' || tmp=='+') &#123; ungetc(tmp, fp); break; &#125; &#125; if(tmp!=EOF) count += fscanf(fp, "%d", i); &#125; if(format[k-1]=='f') //读取浮点型 &#123; f = va_arg(ap, float*); while((tmp=getc(fp))!=EOF) &#123; if((tmp&gt;='0' &amp;&amp; tmp&lt;='9') || tmp=='-' || tmp=='+'|| tmp=='.' ) &#123; ungetc(tmp, fp); break; &#125; &#125; if(tmp!=EOF) count += fscanf(fp, "%f", f); &#125; if(format[k-1]=='s') //读取字符串 &#123; s = va_arg(ap, char*); while((tmp=getc(fp))!=EOF &amp;&amp; (!isprint(tmp) || tmp==' ')) ; n = 0; if(!feof(fp)) &#123; ungetc(tmp, fp); while((tmp=getc(fp))!=EOF) &#123; if(isprint(tmp) &amp;&amp; tmp!=' ') s[n++] = tmp; else break; &#125; ungetc(tmp, fp); &#125; s[n] = '\0'; count++; &#125; &#125; va_end(ap); return count;&#125; 顺序线性表（数组）类型定义12345typedef struct&#123; ElemType data[MAXSIZE]; /* 数组，存储数据元素 */ int length; /* 线性表当前长度 */&#125;SqList; 初始化顺序线性表12345Status InitList(SqList *L) &#123; L-&gt;length=0; return OK;&#125; 判断顺序表是否为空1234567Status ListEmpty(SqList L)&#123; if(L.length==0) return TRUE; else return FALSE;&#125; 清空顺序表12345Status ClearList(SqList *L)&#123; L-&gt;length=0; return OK;&#125; 计算顺序表的长度1234int ListLength(SqList L)&#123; return L.length;&#125; 用e返回L中第i个数据元素的值12345678Status GetElem(SqList L,int i,ElemType *e)&#123; if(L.length==0 || i&lt;1 || i&gt;L.length) return ERROR; *e=L.data[i-1]; return OK;&#125; 返回L中第1个与e满足关系的数据元素的位序123456789101112131415int LocateElem(SqList L,ElemType e)&#123; int i; if (L.length==0) return 0; for(i=0;i&lt;L.length;i++) &#123; if (L.data[i]==e) break; &#125; if(i&gt;=L.length) return 0; return i+1;&#125; 在L中第i个位置之前插入新的数据元素e123456789101112131415161718Status ListInsert(SqList *L,int i,ElemType e)&#123; int k; if (L-&gt;length==MAXSIZE) /* 顺序线性表已经满 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length+1)/* 当i比第一位置小或者比最后一位置后一位置还要大时 */ return ERROR; if (i&lt;=L-&gt;length) /* 若插入数据位置不在表尾 */ &#123; for(k=L-&gt;length-1;k&gt;=i-1;k--) /* 将要插入位置之后的数据元素向后移动一位 */ L-&gt;data[k+1]=L-&gt;data[k]; &#125; L-&gt;data[i-1]=e; /* 将新元素插入 */ L-&gt;length++; return OK;&#125; 删除L的第i个数据元素，并用e返回其值12345678910111213141516Status ListDelete(SqList *L,int i,ElemType *e) &#123; int k; if (L-&gt;length==0) /* 线性表为空 */ return ERROR; if (i&lt;1 || i&gt;L-&gt;length) /* 删除位置不正确 */ return ERROR; *e=L-&gt;data[i-1]; if (i&lt;L-&gt;length) /* 如果删除不是最后位置 */ &#123; for(k=i;k&lt;L-&gt;length;k++)/* 将删除位置后继元素前移 */ L-&gt;data[k-1]=L-&gt;data[k]; &#125; L-&gt;length--; return OK;&#125; 遍历顺序线性表12345678Status ListTraverse(SqList L)&#123; int i; for(i=0;i&lt;L.length;i++) visit(L.data[i]); printf("\n"); return OK;&#125; 合并La、Lb两个顺序线性表12345678910111213void unionL(SqList *La,SqList Lb)&#123; int La_len,Lb_len,i; ElemType e; La_len=ListLength(*La); Lb_len=ListLength(Lb); for (i=1;i&lt;=Lb_len;i++) &#123; GetElem(Lb,i,&amp;e); if (!LocateElem(*La,e)) ListInsert(La,++La_len,e); &#125;&#125; 静态链表（数组）类型定义12345typedef struct &#123; ElemType data; int cur; /* 游标(Cursor) ，为0时表示无指向 */&#125; Component,StaticLinkList[MAXSIZE]; 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，”0”表示空指针12345678Status InitList(StaticLinkList space) &#123; int i; for (i=0; i&lt;MAXSIZE-1; i++) space[i].cur = i+1; space[MAXSIZE-1].cur = 0; /* 目前静态链表为空，最后一个元素的cur为0 */ return OK;&#125; 若备用空间链表非空，则返回分配的结点下标，否则返回012345678910int Malloc_SSL(StaticLinkList space) &#123; int i = space[0].cur; /* 当前数组第一个元素的cur存的值 */ /* 就是要返回的第一个备用空闲的下标 */ if (space[0]. cur) space[0]. cur = space[i].cur; /* 由于要拿出一个分量来使用了， */ /* 所以我们就得把它的下一个 */ /* 分量用来做备用 */ return i;&#125; 将下标为k的空闲结点回收到备用链表12345void Free_SSL(StaticLinkList space, int k) &#123; space[k].cur = space[0].cur; /* 把第一个元素的cur值赋给要删除的分量cur */ space[0].cur = k; /* 把要删除的分量下标赋值给第一个元素的cur */&#125; 计算静态链表的长度1234567891011int ListLength(StaticLinkList L)&#123; int j=0; int i=L[MAXSIZE-1].cur; while(i) &#123; i=L[i].cur; j++; &#125; return j;&#125; 在L中第i个元素之前插入新的数据元素e123456789101112131415161718Status ListInsert(StaticLinkList L, int i, ElemType e) &#123; int j, k, l; k = MAXSIZE - 1; /* 注意k首先是最后一个元素的下标 */ if (i &lt; 1 || i &gt; ListLength(L) + 1) return ERROR; j = Malloc_SSL(L); /* 获得空闲分量的下标 */ if (j) &#123; L[j].data = e; /* 将数据赋值给此分量的data */ for(l = 1; l &lt;= i - 1; l++) /* 找到第i个元素之前的位置 */ k = L[k].cur; L[j].cur = L[k].cur; /* 把第i个元素之前的cur赋值给新元素的cur */ L[k].cur = j; /* 把新元素的下标赋值给第i个元素之前元素的ur */ return OK; &#125; return ERROR; &#125; 删除在L中第i个数据元素12345678910111213Status ListDelete(StaticLinkList L, int i) &#123; int j, k; if (i &lt; 1 || i &gt; ListLength(L)) return ERROR; k = MAXSIZE - 1; for (j = 1; j &lt;= i - 1; j++) k = L[k].cur; j = L[k].cur; L[k].cur = L[j].cur; Free_SSL(L, j); return OK; &#125; 遍历静态链表1234567891011121314Status ListTraverse(StaticLinkList L)&#123; int j=0; int i=L[MAXSIZE-1].cur; while(i) &#123; visit(L[i].data); i=L[i].cur; j++; &#125; return j; printf("\n"); return OK;&#125; 非循环单向线性表类型定义123456789101112#define LIST_INIT_SIZE 100 //顺序表存储空间的初始分配量 #define LISTINCREMENT 10 //顺序表存储空间的分配增量typedef int LElemType_Sq;typedef struct&#123; LElemType_Sq *elem; //存储空间基址（指向第一个结点的指针） int length; //当前顺序表长度 int listsize; //当前分配的存储容量 &#125;SqList; 初始化线性表1234567891011Status InitList_Sq(SqList *L)&#123; (*L).elem = (LElemType_Sq*)malloc(LIST_INIT_SIZE*sizeof(LElemType_Sq)); if(!(*L).elem) exit(OVERFLOW); //分配内存失败 (*L).length = 0; //初始化顺序表长度为0 (*L).listsize = LIST_INIT_SIZE; //顺序表初始内存分配量 return OK; //初始化成功 &#125; 清空线性表1234void ClearList_Sq(SqList *L)&#123; (*L).length = 0;&#125; 销毁线性表12345678void DestroyList_Sq(SqList *L)&#123; free((*L).elem); (*L).elem = NULL; //释放内存后置空指针 (*L).length = 0; (*L).listsize = 0;&#125; 判断线性表是否为空1234Status ListEmpty_Sq(SqList L)&#123; return L.length==0 ? TRUE : FALSE;&#125; 计算线性表的长度1234int ListLength_Sq(SqList L)&#123; return L.length; &#125; 用e接收顺序表L中第i个元素123456789Status GetElem_Sq(SqList L, int i, LElemType_Sq *e)&#123; if(i&lt;1 || i&gt;L.length) return ERROR; //i值不合法 else *e = L.elem[i-1]; return OK;&#125; 返回顺序表L中首个与e满足Compare关系的元素位序123456789101112int LocateElem_Sq(SqList L, LElemType_Sq e, Status(Compare)(LElemType_Sq, LElemType_Sq))&#123; int i = 1; //i的初值为第一个元素的位序 while(i&lt;=L.length &amp;&amp; !Compare(e, L.elem[i-1])) ++i; if(i&lt;=L.length) return i; else return 0; &#125; 用pre_e接收cur_e的前驱123456789101112131415161718Status PriorElem_Sq(SqList L, LElemType_Sq cur_e, LElemType_Sq *pre_e)&#123; int i = 1; if(L.elem[0]!=cur_e) //第一个结点无前驱 &#123; while(i&lt;L.length &amp;&amp; L.elem[i]!=cur_e) ++i; if(i&lt;L.length) &#123; *pre_e = L.elem[i-1]; return OK; &#125; &#125; return ERROR;&#125; 用next_e接收cur_e的后继123456789101112131415Status NextElem_Sq(SqList L, LElemType_Sq cur_e, LElemType_Sq *next_e)&#123; int i = 0; while(i&lt;L.length &amp;&amp; L.elem[i]!=cur_e) ++i; if(i&lt;L.length-1) //最后一个结点无后继 &#123; *next_e = L.elem[i+1]; return OK; &#125; return ERROR;&#125; 在顺序表L的第i个位置上插入e12345678910111213141516171819202122232425262728Status ListInsert_Sq(SqList *L, int i, LElemType_Sq e)&#123; LElemType_Sq *newbase; LElemType_Sq *p, *q; if(i&lt;1 || i&gt;(*L).length+1) return ERROR; //i值不合法 if((*L).length &gt;= (*L).listsize) //若存储空间已满，需开辟新空间 &#123; newbase = (LElemType_Sq*)realloc((*L).elem, ((*L).listsize+LISTINCREMENT)*sizeof(LElemType_Sq)); if(!newbase) exit(OVERFLOW); (*L).elem = newbase; (*L).listsize += LISTINCREMENT; &#125; q = &amp;(*L).elem[i-1]; //q为插入位置 for(p=&amp;(*L).elem[(*L).length-1]; p&gt;=q; --p) *(p+1) = *p; //插入位置及之后的元素右移 *q = e; //插入e (*L).length++; //表长增1 return OK; &#125; 删除顺序表L上第i个位置的元素，并用e返回123456789101112131415161718Status ListDelete_Sq(SqList *L, int i, LElemType_Sq *e)&#123; LElemType_Sq *p, *q; if(i&lt;1 || i&gt;(*L).length) return ERROR; //i值不合法 p = &amp;(*L).elem[i-1]; //p为被删除元素的位置 *e = *p; q = (*L).elem+(*L).length-1; //表尾元素位置 for(++p; p&lt;=q; ++p) *(p-1) = *p; //被删元素之后的元素左移 (*L).length--; //表长减1 return OK;&#125; 用visit函数访问顺序表L123456789Status ListTraverse_Sq(SqList L, void(Visit)(LElemType_Sq))&#123; int i; for(i=0; i&lt;L.length; i++) Visit(L.elem[i]); return OK;&#125; 单向循环链表顺序栈类型定义123456789101112#define STACK_INIT_SIZE 100 //顺序栈存储空间的初始分配量#define STACKINCREMENT 10 //顺序栈存储空间的分配增量typedef int SElemType_Sq;typedef struct&#123; SElemType_Sq *base; //在栈构造之前和销毁之后，base的值为NULL SElemType_Sq *top; //栈顶指针 int stacksize; //当前已分配的存储空间，以元素为单位 &#125;SqStack; 栈的初始化12345678910111213141516171819202122232425Status InitStack_Sq(SqStack &amp;S)&#123; S.base = (SElemType_Sq *)malloc(STACK_INIT_SIZE*sizeof(SElemType_Sq)); if(!S.base) exit(OVERFLOW); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return OK;&#125; //*******************Status InitStack_Sq(SqStack *S)&#123; (*S).base = (SElemType_Sq *)malloc(STACK_INIT_SIZE*sizeof(SElemType_Sq)); if(!(*S).base) exit(OVERFLOW); (*S).top = (*S).base; (*S).stacksize = STACK_INIT_SIZE; return OK;&#125; 销毁栈1234567891011121314151617181920212223Status DestroyStack_Sq(SqStack &amp;S)&#123; free(S.base); S.base = NULL; S.top = NULL; S.stacksize = 0; return OK;&#125; //*******************Status DestroyStack_Sq(SqStack *S)&#123; free((*S).base); (*S).base = NULL; (*S).top = NULL; (*S).stacksize = 0; return OK;&#125; 清空栈123456789101112131415Status ClearStack_Sq(SqStack &amp;S)&#123; S.top = S.base; return OK;&#125; //*******************Status ClearStack_Sq(SqStack *S)&#123; (*S).top = (*S).base; return OK;&#125; 判断栈是否为空123456789Status StackEmpty_Sq(SqStack S)&#123; if(S.top==S.base) return TRUE; else return FALSE;&#125; //******************* 计算栈的长度123456int StackLength_Sq(SqStack S)&#123; return S.top - S.base;&#125; //******************* 得到栈顶元素1234567891011121314151617181920212223Status GetTop_Sq(SqStack S, SElemType_Sq &amp;e)&#123; if(S.top==S.base) return ERROR; e = *(S.top - 1); //并不破坏栈 return OK;&#125; //*******************Status GetTop_Sq(SqStack S, SElemType_Sq *e)&#123; if(S.top==S.base) return ERROR; *e = *(S.top - 1); //并不破坏栈 return OK;&#125; 入栈1234567891011121314151617181920212223242526272829303132333435Status Push_Sq(SqStack &amp;S, SElemType_Sq e)&#123; if(S.top-S.base&gt;=S.stacksize) //栈满，追加存储空间 &#123; S.base = (SElemType_Sq *)realloc(S.base, (S.stacksize+STACKINCREMENT)*sizeof(SElemType_Sq)); if(!S.base) exit(OVERFLOW); //存储分配失败 S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; &#125; *(S.top) = e; //进栈先赋值，栈顶指针再自增 (S.top)++; return OK;&#125; //*******************Status Push_Sq(SqStack *S, SElemType_Sq e)&#123; if((*S).top-(*S).base&gt;=(*S).stacksize) //栈满，追加存储空间 &#123; (*S).base = (SElemType_Sq *)realloc((*S).base, ((*S).stacksize+STACKINCREMENT)*sizeof(SElemType_Sq)); if(!(*S).base) exit(OVERFLOW); //存储分配失败 (*S).top = (*S).base + (*S).stacksize; (*S).stacksize += STACKINCREMENT; &#125; *(S-&gt;top) = e; //进栈先赋值，栈顶指针再自增 (S-&gt;top)++; return OK;&#125; 出栈1234567891011121314151617181920212223Status Pop_Sq(SqStack &amp;S, SElemType_Sq &amp;e)&#123; if(S.top==S.base) return ERROR; S.top--; //出栈栈顶指针先递减，再赋值 e = *(S.top); return OK;&#125; //*******************Status Pop_Sq(SqStack *S, SElemType_Sq *e)&#123; if((*S).top==(*S).base) return ERROR; (*S).top--; //出栈栈顶指针先递减，再赋值 *e = *((*S).top); return OK;&#125; 遍历栈中元素1234567891011Status StackTraverse_Sq(SqStack S, void(Visit)(SElemType_Sq))&#123; //遍历不应该破坏栈 SElemType_Sq *p = S.base; while(p&lt;S.top) Visit(*p++); return OK;&#125;//******************* 非循环队列类型定义12345678910111213typedef int QElemType_L;typedef struct QNode &#123; QElemType_L data; struct QNode *next;&#125;QNode,* QueuePtr;typedef struct&#123; QueuePtr front; //头指针 QueuePtr rear; //尾指针 &#125;LinkQueue; //队列的链式存储表示 非循环队列的初始化1234567891011121314151617181920212223Status InitQueue_L(LinkQueue &amp;Q)&#123; Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); if(!Q.front) exit(OVERFLOW); Q.front-&gt;next = NULL; return OK;&#125;//*******************Status InitQueue_L(LinkQueue *Q)&#123; (*Q).front = (*Q).rear = (QueuePtr)malloc(sizeof(QNode)); if(!(*Q).front) exit(OVERFLOW); (*Q).front-&gt;next = NULL; return OK;&#125; 清空队列1234567891011121314151617181920212223242526272829void ClearQueue_L(LinkQueue &amp;Q)&#123; Q.rear = Q.front-&gt;next; while(Q.rear) &#123; Q.front-&gt;next = Q.rear-&gt;next; free(Q.rear); Q.rear = Q.front-&gt;next; &#125; Q.rear = Q.front;&#125;//*******************void ClearQueue_L(LinkQueue *Q)&#123; (*Q).rear = (*Q).front-&gt;next; while((*Q).rear) &#123; (*Q).front-&gt;next = (*Q).rear-&gt;next; free((*Q).rear); (*Q).rear = (*Q).front-&gt;next; &#125; (*Q).rear = (*Q).front;&#125; 销毁队列123456789101112131415161718192021void DestroyQueue_L(LinkQueue &amp;Q)&#123; while(Q.front) &#123; Q.rear = Q.front-&gt;next; free(Q.front); Q.front = Q.rear; &#125;&#125;//*******************void DestroyQueue_L(LinkQueue *Q)&#123; while((*Q).front) &#123; (*Q).rear = (*Q).front-&gt;next; free((*Q).front); (*Q).front = (*Q).rear; &#125;&#125; 判断队列是否为空123456789Status QueueEmpty_L(LinkQueue Q)&#123; if(Q.front==Q.rear) return TRUE; else return FALSE;&#125; //******************* 计算队列的长度123456789101112131415int QueueLength_L(LinkQueue Q)&#123; int count = 0; QueuePtr p = Q.front; while(p!=Q.rear) &#123; count++; p = p-&gt;next; &#125; return count;&#125; //******************* 得到队头元素123456789101112131415161718192021222324252627Status GetHead_L(LinkQueue Q, QElemType_L &amp;e)&#123; QueuePtr p; if(Q.front==Q.rear) return ERROR; p = Q.front-&gt;next; e = p-&gt;data; return OK;&#125; //*******************Status GetHead_L(LinkQueue Q, QElemType_L *e)&#123; QueuePtr p; if(Q.front==Q.rear) return ERROR; p = Q.front-&gt;next; *e = p-&gt;data; return OK;&#125; 入队1234567891011121314151617181920212223242526272829303132333435Status EnQueue_L(LinkQueue &amp;Q, QElemType_L e)&#123; QueuePtr p; p = (QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-&gt;data = e; p-&gt;next = NULL; Q.rear-&gt;next = p; Q.rear=p; return OK;&#125; //*******************Status EnQueue_L(LinkQueue *Q, QElemType_L e)&#123; QueuePtr p; p = (QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-&gt;data = e; p-&gt;next = NULL; (*Q).rear-&gt;next = p; (*Q).rear=p; return OK;&#125; 出队123456789101112131415161718192021222324252627282930313233343536373839Status DeQueue_L(LinkQueue &amp;Q, QElemType_L &amp;e)&#123; QueuePtr p; if(Q.front==Q.rear) return ERROR; p = Q.front-&gt;next; e = p-&gt;data; Q.front-&gt;next = p-&gt;next; if(Q.rear==p) Q.rear = Q.front; free(p); return OK;&#125; //*******************Status DeQueue_L(LinkQueue *Q, QElemType_L *e)&#123; QueuePtr p; if((*Q).front==(*Q).rear) return ERROR; p = (*Q).front-&gt;next; *e = p-&gt;data; (*Q).front-&gt;next = p-&gt;next; if((*Q).rear==p) (*Q).rear = (*Q).front; free(p); return OK;&#125; 遍历非循环队列1234567891011121314void QueueTraverse_L(LinkQueue Q, void (Visit)(QElemType_L))&#123; QueuePtr p; p = Q.front-&gt;next; while(p) &#123; Visit(p-&gt;data); p = p-&gt;next; &#125;&#125;//******************* 循环队列（不设头指针） 假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针） 类型定义123456789101112typedef int QElemType_L;typedef struct QNode &#123; QElemType_L data; struct QNode *next;&#125;QNode,* QueuePtr;typedef struct&#123; QueuePtr rear; //尾指针 &#125;LinkQueue; //队列的链式存储表示 循环队列初始化1234567891011Status InitQueue_L(LinkQueue *Q) //队列初始化 &#123; (*Q).rear = (QueuePtr)malloc(sizeof(QNode)); if(!(*Q).rear) exit(OVERFLOW); (*Q).rear-&gt;next = (*Q).rear; //初次创建的(*Q).rear为头结点，且next指向 //自身，达到循环效果。 return OK;&#125; 入队123456789101112131415Status EnQueue_L(LinkQueue *Q, QElemType e) //入队 &#123; QueuePtr p; p = (QueuePtr)malloc(sizeof(QNode)); if(!p) exit(OVERFLOW); p-&gt;data = e; p-&gt;next = (*Q).rear-&gt;next; //入队后新结点的next始终指向头结点，构成循环队列 (*Q).rear-&gt;next = p; //每次都在队尾入队 (*Q).rear = p; return OK;&#125; 出队1234567891011121314151617181920Status DeQueue_L(LinkQueue *Q, QElemType *e) //出队 &#123; QueuePtr h, p; h = (*Q).rear-&gt;next; if(h-&gt;next==(*Q).rear-&gt;next) return ERROR; p = h-&gt;next; *e = p-&gt;data; h-&gt;next = p-&gt;next; //当队列只有一个元素时，头结点的next指向自身 if(p==(*Q).rear) //队列只有一个元素 (*Q).rear = h; //rear指向头结点 free(p); return OK;&#125; 遍历循环队列1234567void Output_L(LinkQueue Q)&#123; QueuePtr p; for(p=Q.rear-&gt;next-&gt;next; p!=Q.rear-&gt;next; p=p-&gt;next) printf("%d ", p-&gt;data);&#125; 循环队列（设头指针） 设置一个标志域tag，并以tag的值为0和1来区分，尾指针和头指针值相同时的队列状态是“空”还是“满”。 类型定义123456789typedef int QElemType;typedef struct&#123; QElemType *base; int front; int rear; int tag; //0表示空，1表示满 &#125;SqQueue; 队列初始化123456789Status InitQueue_L(SqQueue *Q)&#123; (*Q).base = (QElemType *)malloc(MAXQSIZE*sizeof(QElemType)); if(!((*Q).base)) exit(OVERFLOW); (*Q).front = (*Q).rear = 0; (*Q).tag = 0;&#125; 入队12345678910111213Status EnQueue_L(SqQueue *Q, QElemType e)&#123; if((*Q).rear==(*Q).front &amp;&amp; (*Q).tag==1) //队列满 return ERROR; (*Q).base[(*Q).rear] = e; (*Q).rear = ((*Q).rear+1)%MAXQSIZE; if((*Q).rear==(*Q).front) //入队后队满 (*Q).tag = 1; return OK;&#125; 出队12345678910111213Status DeQueue_L(SqQueue *Q, QElemType *e)&#123; if((*Q).front==(*Q).rear &amp;&amp; (*Q).tag==0) //队列空 return ERROR; *e = (*Q).base[(*Q).front]; (*Q).front = ((*Q).front+1)%MAXQSIZE; if((*Q).rear==(*Q).front) //出队后队空 (*Q).tag = 0; return OK;&#125; 遍历队列1234567void Output_L(SqQueue Q)&#123; int i; for(i=Q.front; i!=Q.rear; i=(i+1)%MAXQSIZE) printf("%d ", Q.base[i]);&#125; 堆串类型定义123456/* 串的堆存储表示 */typedef struct&#123; char *ch; //若是非空串，则按串长分配存储区，否则ch为NULL int length;&#125;HString; 初始化S为空串12345void InitString_H(HString *S)&#123; (*S).ch = NULL; (*S).length = 0;&#125; 生成一个其值等于常量chars的串T123456789101112131415161718192021222324Status StrAssign_H(HString *T, char *chars)&#123; int i, j; InitString_H(T); i = strlen(chars); if(!i) return ERROR; else &#123; (*T).ch = (char*)malloc(i*sizeof(char)); if(!((*T).ch)) exit(OVERFLOW); for(j=0; j&lt;i; j++) (*T).ch[j] = chars[j]; (*T).length = i; &#125; return OK;&#125; 由串S复制得到串T1234567891011121314151617181920Status StrCopy_H(HString *T, HString S)&#123; int i; InitString_H(T); if(StrEmpty_H(S)) return ERROR; (*T).ch = (char*)malloc(S.length*sizeof(char)); if(!(*T).ch) exit(OVERFLOW); for(i=0; i&lt;S.length; i++) (*T).ch[i] = S.ch[i]; (*T).length = S.length; return OK;&#125; 若S为空串，返回TRUE,否则返回FALSE1234567Status StrEmpty_H(HString S)&#123; if(S.length==0 &amp;&amp; S.ch==NULL) return TRUE; else return FALSE;&#125; 若S&gt;T，返回值&gt;0；若S&lt;T，返回值&lt;0；否则，返回值=0123456789101112Status StrCompare_H(HString S, HString T)&#123; int i; for(i=0; i&lt;S.length&amp;&amp;i&lt;T.length; i++) &#123; if(S.ch[i]!=T.ch[i]) return S.ch[i]-T.ch[i]; &#125; return S.length-T.length;&#125; 求串长1234567int StrLength_H(HString S)&#123; if(StrEmpty_H(S)) return 0; else return S.length;&#125; 清空串S123456789101112Status ClearString_H(HString *S)&#123; if((*S).ch) &#123; free((*S).ch); (*S).ch = NULL; &#125; (*S).length = 0; return OK;&#125; 用T返回由S1和S2联接而成的新串1234567891011121314151617181920Status Concat_H(HString *T, HString S1, HString S2)&#123; int i; InitString_H(T); (*T).length = S1.length + S2.length; (*T).ch = (char*)malloc((*T).length*sizeof(char)); if(!(*T).ch) exit(OVERFLOW); for(i=0; i&lt;S1.length; i++) (*T).ch[i] = S1.ch[i]; for(i=0; i&lt;S2.length; i++) (*T).ch[S1.length+i] = S2.ch[i]; return OK;&#125; 用Sub返回串S的第pos个字符起长度为len的子串1234567891011121314151617181920212223242526Status SubString_H(HString *Sub, HString S, int pos, int len)&#123; int i; InitString_H(Sub); if(StrEmpty_H(S)) return ERROR; if(pos&lt;1 || pos&gt;S.length || len&lt;0 || pos+len-1&gt;S.length) return ERROR; if(len) //非空子串 &#123; (*Sub).ch = (char*)malloc(len*sizeof(char)); if(!(*Sub).ch) exit(OVERFLOW); for(i=0; i&lt;len; i++) (*Sub).ch[i] = S.ch[i+pos-1]; (*Sub).length = len; &#125; return OK;&#125; 返回T在S中第pos个字符后第一次出现的位置，不存在则返回01234567891011121314151617181920212223242526int Index_H(HString S, HString T, int pos)&#123; int s, t, i; HString Sub; InitString_H(&amp;Sub); if(pos&gt;0) &#123; s = S.length; t = T.length; i = pos; while(i+t-1&lt;=s) &#123; SubString_H(&amp;Sub, S, i, t); if(StrCompare_H(Sub, T)) i++; else return i; &#125; &#125; return 0;&#125; 用V替换主串S中出现的所有与T相等的不重叠的子串12345678910111213141516171819202122Status Replace_H(HString *S, HString T, HString V)&#123; int i; if(StrEmpty_H(T)) return ERROR; i = Index_H(*S, T, 1); while(i!=0) &#123; StrDelete_H(S, i, StrLength_H(T)); StrInsert_H(S, i, V); i += StrLength_H(V); i = Index_H(*S, T, i); &#125; return OK;&#125; 在串S的第pos个字符之前插入串T1234567891011121314151617181920212223242526Status StrInsert_H(HString *S, int pos, HString T)&#123; int i; if(pos&lt;1 || pos&gt;(*S).length+1) return ERROR; if(StrEmpty_H(T)) return ERROR; else &#123; (*S).ch = (char*)realloc((*S).ch, ((*S).length+T.length)*sizeof(char)); if(!(*S).ch) exit(OVERFLOW); for(i=(*S).length-1; i&gt;=pos-1; i--) //为插入T而腾出位置 (*S).ch[i+T.length] = (*S).ch[i]; for(i=0; i&lt;T.length; i++) (*S).ch[pos-1+i] = T.ch[i]; //插入T (*S).length += T.length; &#125; return OK; &#125; 从串S中删除第pos个字符起长度为len的子串12345678910111213141516171819Status StrDelete_H(HString *S, int pos, int len)&#123; int i; if(StrEmpty_H(*S)) return ERROR; if(pos&lt;1 || pos+len-1&gt;(*S).length ||len&lt;0) return ERROR; for(i=pos-1; i+len&lt;=(*S).length; i++) (*S).ch[i] = (*S).ch[i+len]; (*S).length -= len; (*S).ch = (char*)realloc((*S).ch, (*S).length*sizeof(char)); //缩小分配的空间 return OK;&#125; 销毁串S1234void DestroyString_H(HString *S)&#123; //堆串不能被销毁&#125; 输出串S12345678910void StrPrint_H(HString S)&#123; int i; if(StrEmpty_H(S)) printf("S为空串，不可输出！"); for(i=0; i&lt;S.length; i++) printf("%c", S.ch[i]);&#125; 数组和广义表类型定义1#define MAXSIZE 400 //假设非零元个数的最大值为400 三元组顺序表(稀疏矩阵)类型定义123456789101112typedef int MElemType_TSq;typedef struct&#123; int i, j; //该非零元的行下标和列下标 MElemType_TSq e;&#125;Triple;typedef struct&#123; Triple data[MAXSIZE+1]; //非零元三元组表，data[0]未用 int mu, nu, tu; //矩阵的行数、列数和非零元个数&#125;TSMatrix; 创建n个矩阵12345678910111213141516171819202122232425Status CreateSMatrix_T(FILE *fp, int n, ...)&#123; int count, k; TSMatrix *M; if(n&lt;1) return ERROR; va_list ap; va_start(ap, n); for(count=1; count&lt;=n; count++) &#123; M = va_arg(ap, TSMatrix*); Scanf(fp, "%d%d%d", &amp;((*M).mu), &amp;((*M).nu), &amp;((*M).tu)); for(k=1; k&lt;=(*M).tu; k++) Scanf(fp, "%d%d%d", &amp;((*M).data[k].i), &amp;((*M).data[k].j), &amp;((*M).data[k].e)); &#125; va_end(ap); return OK; &#125; 销毁矩阵123456void DestroySMatrix_T(TSMatrix *M)&#123; (*M).mu = 0; (*M).nu = 0; (*M).tu = 0;&#125; 输出矩阵1234567891011121314151617181920void PrintSMatrix_T(TSMatrix M)&#123; int r, c; int k = 1; for(r=1; r&lt;=M.mu; r++) &#123; for(c=1; c&lt;=M.nu; c++) &#123; if(r==M.data[k].i &amp;&amp; c==M.data[k].j) &#123; printf("%3d ", M.data[k].e); k++; &#125; else printf(" 0 "); &#125; printf("\n"); &#125; &#125; 矩阵的复制1234void CopySMatrix_T(TSMatrix M, TSMatrix *T)&#123; (*T) = M; //结构可以直接复制 &#125; 矩阵的加法Q = M + N1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980Status AddSMatri_T(TSMatrix M, TSMatrix N, TSMatrix *Q)&#123; int m, n, k; if(M.mu!=N.mu || M.nu!=N.nu) &#123; printf("两矩阵不能相加！！\n"); return ERROR; &#125; Q-&gt;mu = M.mu; Q-&gt;nu = M.nu; Q-&gt;tu = 0; m = n = k = 1; while(m&lt;=M.tu &amp;&amp; n&lt;=N.tu) //依次遍历M与N的三元组 &#123; if(M.data[m].i&lt;N.data[n].i) &#123; Q-&gt;data[k] = M.data[m]; m++; &#125; else if(M.data[m].i&gt;N.data[n].i) &#123; Q-&gt;data[k] = N.data[n]; n++; &#125; else //M.data[m].i==N.data[n].i &#123; if(M.data[m].j&lt;N.data[n].j) &#123; Q-&gt;data[k] = M.data[m]; m++; &#125; else if(M.data[m].j&gt;N.data[n].j) &#123; Q-&gt;data[k] = N.data[n]; n++; &#125; else //M.data[m].j==N.data[n].j &#123; if(M.data[m].e+N.data[n].e) &#123; Q-&gt;data[k].i = M.data[m].i; Q-&gt;data[k].j = M.data[m].j; Q-&gt;data[k].e = M.data[m].e + N.data[n].e; m++; n++; &#125; else &#123; m++; n++; continue; &#125; &#125; &#125; k++; Q-&gt;tu++; &#125; while(m&lt;=M.tu) &#123; Q-&gt;data[k] = M.data[m]; m++; k++; Q-&gt;tu++; &#125; while(n&lt;=N.tu) &#123; Q-&gt;data[k] = N.data[n]; n++; k++; Q-&gt;tu++; &#125; return OK;&#125; 矩阵的减法Q = M - N1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586Status SubSMatrix_T(TSMatrix M, TSMatrix N, TSMatrix *Q)&#123; int m, n, k; if(M.mu!=N.mu || M.nu!=N.nu) &#123; printf("两矩阵不能相减！！\n"); return ERROR; &#125; Q-&gt;mu = M.mu; Q-&gt;nu = M.nu; Q-&gt;tu = 0; m = n = k = 1; while(m&lt;=M.tu &amp;&amp; n&lt;=N.tu) &#123; if(M.data[m].i&lt;N.data[n].i) &#123; Q-&gt;data[k] = M.data[m]; m++; &#125; else if(M.data[m].i&gt;N.data[n].i) &#123; Q-&gt;data[k].i = N.data[n].i; Q-&gt;data[k].j = N.data[n].j; Q-&gt;data[k].e = -N.data[n].e; n++; &#125; else //M.data[m].i==N.data[n].i &#123; if(M.data[m].j&lt;N.data[n].j) &#123; Q-&gt;data[k] = M.data[m]; m++; &#125; else if(M.data[m].j&gt;N.data[n].j) &#123; Q-&gt;data[k].i = N.data[n].i; Q-&gt;data[k].j = N.data[n].j; Q-&gt;data[k].e = -N.data[n].e; n++; &#125; else //M.data[m].j==N.data[n].j &#123; if(M.data[m].e-N.data[n].e) &#123; Q-&gt;data[k].i = M.data[m].i; Q-&gt;data[k].j = M.data[m].j; Q-&gt;data[k].e = M.data[m].e - N.data[n].e; m++; n++; &#125; else &#123; m++; n++; continue; &#125; &#125; &#125; k++; Q-&gt;tu++; &#125; while(m&lt;=M.tu) &#123; Q-&gt;data[k] = M.data[m]; m++; k++; Q-&gt;tu++; &#125; while(n&lt;=N.tu) &#123; Q-&gt;data[k].i = N.data[n].i; Q-&gt;data[k].j = N.data[n].j; Q-&gt;data[k].e = -N.data[n].e;; n++; k++; Q-&gt;tu++; &#125; return OK; &#125; 矩阵的乘法Q = M * N12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Status MultSMatrix_T(TSMatrix M, TSMatrix N, TSMatrix *Q)&#123; int m, n, i, j, k; MElemType_TSq c, c1, c2; if(M.nu!=N.mu) //M列数等于N行数 &#123; printf("两矩阵不能相乘！！\n"); return ERROR; &#125; Q-&gt;mu = M.mu; //Q初始化 Q-&gt;nu = N.nu; Q-&gt;tu = 0; if(M.tu*N.tu) //Q是非零矩阵 &#123; for(i=1; i&lt;=M.mu; i++) //传统矩阵乘法 &#123; for(j=1; j&lt;=N.nu; j++) &#123; c = 0; for(k=1; k&lt;=M.nu; k++) &#123; c1 = 0; for(m=1; m&lt;=M.tu; m++) //依次寻找位于指定位置的M三元组 &#123; if(M.data[m].i==i &amp;&amp; M.data[m].j==k) &#123; c1 = M.data[m].e; break; &#125; &#125; c2 = 0; for(n=1; n&lt;=N.tu; n++) //依次寻找位于指定位置的N三元组 &#123; if(N.data[n].i==k &amp;&amp; N.data[n].j==j) &#123; c2 = N.data[n].e; break; &#125; &#125; if(c1 &amp;&amp; c2) c += c1 * c2; &#125; if(c) &#123; Q-&gt;tu++; Q-&gt;data[Q-&gt;tu].i = i; Q-&gt;data[Q-&gt;tu].j = j; Q-&gt;data[Q-&gt;tu].e = c; &#125; &#125; &#125; &#125; return OK;&#125; 矩阵转置1234567891011121314151617181920212223242526void TransposeSMatrix_T(TSMatrix M, TSMatrix *T)&#123; int p, q, col; T-&gt;mu = M.nu; T-&gt;nu = M.mu; T-&gt;tu = M.tu; if(T-&gt;tu) &#123; q = 1; //q用于T中非零元计数 for(col=1; col&lt;=M.nu; ++col) //col代表M的列，T的行 &#123; for(p=1; p&lt;=M.tu; ++p) //p用于M中非零元计数 &#123; if(M.data[p].j==col) &#123; T-&gt;data[q].i = M.data[p].j; //M的列变为T的行 T-&gt;data[q].j = M.data[p].i; //M的行变为T的列 T-&gt;data[q].e = M.data[p].e; //每个三元组值不变 ++q; &#125; &#125; &#125; &#125;&#125; 矩阵快速转置123456789101112131415161718192021222324252627282930313233void FastTransposeSMatrix_T(TSMatrix M, TSMatrix *T)&#123; int col, t, p, q; int num[M.nu]; //num[col]表示M第col列中非零元的个数 int copt[M.nu]; //copt[col]表示M第col列第一个非零元在T-&gt;data中恰当的位置 T-&gt;mu = M.nu; T-&gt;nu = M.mu; T-&gt;tu = M.tu; if(T-&gt;tu) &#123; for(col=1; col&lt;=M.nu; ++col) num[col] = 0; //初始化数组num for(t=1; t&lt;=M.tu; ++t) //t遍历M中三元组 num[M.data[t].j]++; //统计M中每列非零元个数 copt[1] = 1; for(col=2; col&lt;=M.nu; ++col) copt[col] = copt[col-1] + num[col-1]; for(p=1; p&lt;=M.tu; ++p) //依次扫描M中的三元组 &#123; col = M.data[p].j; //col为M中第p个三元组中元素的列 q = copt[col]; //q为当前三元组元素在T中应放置的位置 T-&gt;data[q].i = M.data[p].j; T-&gt;data[q].j = M.data[p].i; T-&gt;data[q].e = M.data[p].e; ++copt[col]; //再遇到此列元素时位置增一 &#125; &#125;&#125; 树和二叉树二叉树（二叉链表存储）相关类型定义12345678typedef char TElemType; //假设二叉树元素均为字符typedef struct BiTNode&#123; TElemType data; //结点元素 struct BiTNode* lchild; //左孩子指针 struct BiTNode* rchild; //右孩子指针 &#125;BiTNode; //二叉树结点 typedef BiTNode* BiTree; //指向二叉树结点的指针 栈元素类型1234typedef BiTree SElemType_Sq; //重定义栈元素类型 #include "../../▲03 栈和队列/01 SequenceStack/SequenceStack.c" //**▲03 栈和队列**// 要用到栈的类型定义 存储当前结点信息，按树结构打印树的时候使用123456typedef struct &#123; BiTree left; //当前结点的左指针 BiTree right; //当前结点的右指针 int n; //当前结点的次序 &#125;Node; 构造空二叉树T (初始化二叉树)1234void InitBiTree(BiTree *T)&#123; *T = NULL;&#125; 清空二叉树T1234567891011121314void ClearBiTree(BiTree *T)&#123; if(*T) //二叉树不为空 &#123; if((*T)-&gt;lchild) //清空左树 ClearBiTree(&amp;((*T)-&gt;lchild)); if((*T)-&gt;rchild) //清空右树 ClearBiTree(&amp;((*T)-&gt;rchild)); free(*T); //释放根结点 *T = NULL; //置空树指针 &#125; &#125; 销毁二叉树T1234void DestroyBiTree(BiTree *T)&#123; //二叉树无法销毁 &#125; 判断二叉树T是否为空1234Status BiTreeEmpty(BiTree T)&#123; return T==NULL ? TRUE : ERROR;&#125; 按先序序列构造二叉树_11234567891011121314151617181920Status CreateBiTree(FILE *fp, BiTree *T)&#123; char ch; Scanf(fp, "%c", &amp;ch); if(ch == '^') *T = NULL; else &#123; *T = (BiTree)malloc(sizeof(BiTNode)); if(!(*T)) exit(OVERFLOW); (*T)-&gt;data = ch; CreateBiTree(fp, &amp;(*T)-&gt;lchild); CreateBiTree(fp, &amp;(*T)-&gt;rchild); &#125; return OK;&#125; 按先序序列构造二叉树_2123456789101112131415161718BiTree f(FILE *fp, BiTree *T)&#123; char ch; Scanf(fp, "%c", &amp;ch); if(ch == '^') *T = NULL; else &#123; *T = (BiTree)malloc(sizeof(BiTNode)); if(!(*T)) exit(OVERFLOW); (*T)-&gt;data = ch; CreateBiTree(fp, &amp;(*T)-&gt;lchild); CreateBiTree(fp, &amp;(*T)-&gt;rchild); &#125;&#125; 返回二叉树长度（按完全二叉树计算）12345678910111213141516171819202122232425262728293031323334353637383940414243444546int BiTreeLength(BiTree T)&#123; Node node[100]; //存储结点信息 int i, len; i = len = 0; if(T) &#123; node[i].left = T-&gt;lchild; node[i].right = T-&gt;rchild; node[i].n = 1; if(node[i].n&gt;len) len = node[i].n; while(i&gt;=0) &#123; while(node[i].left) //访问左子树 &#123; node[i+1].left = node[i].left-&gt;lchild; node[i+1].right = node[i].left-&gt;rchild; node[i+1].n = 2*node[i].n; node[i].left = NULL; i++; if(node[i].n&gt;len) len = node[i].n; &#125; if(node[i].right) //左子树为空时访问右子树 &#123; node[i+1].left = node[i].right-&gt;lchild; node[i+1].right = node[i].right-&gt;rchild; node[i+1].n = 2*node[i].n+1; node[i].right = NULL; i++; if(node[i].n&gt;len) len = node[i].n; &#125; if(node[i].left==NULL &amp;&amp; node[i].right==NULL) i--; &#125; &#125; return len;&#125; 返回二叉树深度（层数）1234567891011121314int BiTreeDepth(BiTree T)&#123; int LD, RD; if(T==NULL) return 0; //空树深度为0 else &#123; LD = BiTreeDepth(T-&gt;lchild); //求左子树深度 RD = BiTreeDepth(T-&gt;rchild); //求右子树深度 return (LD&gt;=RD?LD:RD)+1; &#125;&#125; 用e返回二叉树的根结点值12345678910Status Root(BiTree T, TElemType *e)&#123; if(!T) return ERROR; else &#123; *e = T-&gt;data; return OK; &#125;&#125; 返回某结点的值，p为结点指针1234TElemType Value(BiTree p)&#123; return p-&gt;data;&#125; 为某结点赋值，p为结点指针1234void Assign(BiTree p, TElemType value)&#123; p-&gt;data = value;&#125; 返回某结点的双亲结点值12345678910111213141516171819202122232425262728293031323334353637TElemType Parent(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(T==NULL || (T!=NULL &amp;&amp; e==T-&gt;data)) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].lchild) &#123; if(node[i].lchild-&gt;data==e) return node[i].data; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].rchild) &#123; if(node[i].rchild-&gt;data==e) return node[i].data; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return '\0'; &#125; 返回某结点的左孩子结点值1234567891011121314151617181920212223242526272829303132333435363738394041TElemType LeftChild(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(!T) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].data!=e &amp;&amp; node[i].lchild) &#123; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].data==e) &#123; if(node[i].lchild) return node[i].lchild-&gt;data; else return '\0'; &#125; if(node[i].rchild) &#123; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL &amp;&amp; node[i].data!=e) i--; &#125; if(i&lt;0) return '\0'; &#125; 返回某结点的右孩子结点值12345678910111213141516171819202122232425262728293031323334353637383940TElemType RightChild(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(!T) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].data!=e &amp;&amp; node[i].lchild) &#123; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].data==e) &#123; if(node[i].rchild) return node[i].rchild-&gt;data; else return '\0'; &#125; if(node[i].rchild) &#123; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return '\0';&#125; 返回某结点的左兄弟结点值12345678910111213141516171819202122232425262728293031323334353637383940414243TElemType LeftSibling(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(T==NULL || (T!=NULL &amp;&amp; e==T-&gt;data)) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].rchild) &#123; if(node[i].rchild-&gt;data==e) &#123; if(node[i].lchild) return node[i].lchild-&gt;data; else return '\0'; &#125; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild) &#123; if(node[i].lchild-&gt;data==e) return '\0'; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return '\0';&#125; 返回某结点的右兄弟结点值123456789101112131415161718192021222324252627282930313233343536373839404142TElemType RightSibling(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(T==NULL || (T!=NULL &amp;&amp; e==T-&gt;data)) return '\0'; node[i] = *T; while(i&gt;=0) &#123; while(node[i].lchild) &#123; if(node[i].lchild-&gt;data==e) &#123; if(node[i].rchild) return node[i].rchild-&gt;data; else return '\0'; &#125; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].rchild) &#123; if(node[i].rchild-&gt;data==e) return '\0'; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return '\0';&#125; 获取指向结点e的指针_112345678910111213141516171819202122232425262728293031323334353637383940BiTree LocationBiTree_1(BiTree T, TElemType e)&#123; BiTNode node[100]; int i = 0; if(T==NULL) return NULL; if(T-&gt;data==e) return T; node[i] = *T; while(i&gt;=0) &#123; while(node[i].lchild) &#123; if(node[i].lchild-&gt;data==e) return node[i].lchild; node[i+1] = *(node[i].lchild); node[i].lchild = NULL; i++; &#125; if(node[i].rchild) &#123; if(node[i].rchild-&gt;data==e) return node[i].rchild; node[i+1] = *(node[i].rchild); node[i].rchild = NULL; i++; &#125; if(node[i].lchild==NULL &amp;&amp; node[i].rchild==NULL) i--; &#125; if(i&lt;0) return NULL;&#125; 获取指向结点e的指针_21234567891011121314151617181920BiTree LocationBiTree_2(BiTree T, TElemType e)&#123; BiTree p = NULL; if(T) &#123; if(T-&gt;data==e) p = T; else &#123; if(p=LocationBiTree_2(T-&gt;lchild, e)) return p; if(p=LocationBiTree_2(T-&gt;rchild, e)) return p; &#125; &#125; return p;&#125; 将树T0插入到树T中成为结点e的子树，LR为插入标记，T0只有左子树1234567891011121314Status InsertBiTree(BiTree T, TElemType e, BiTree T0, int LR)&#123; BiTree p = LocationBiTree_1(T, e); if(p) &#123; T0-&gt;rchild = LR ? p-&gt;rchild : p-&gt;lchild; LR ? (p-&gt;rchild=T0) : (p-&gt;lchild=T0); return OK; &#125; return ERROR; &#125; 删除e结点的左子树或右子树，LR为删除标记12345678910111213Status DeleteBiTree(BiTree T, TElemType e, int LR)&#123; BiTree p = LocationBiTree_2(T, e); if(p) &#123; LR ? ClearBiTree(&amp;(p-&gt;rchild)) : ClearBiTree(&amp;(p-&gt;lchild)); return OK; &#125; return ERROR;&#125; 层序遍历二叉树_1（利用数组实现）1234567891011121314151617181920void LevelOrderTraverse_1(BiTree T, void(Visit)(TElemType))&#123; int i, j; BiTree p[100]; //树指针数组 i = j = 0; if(T) p[j++] = T; while(i&lt;j) &#123; Visit(p[i]-&gt;data); if(p[i]-&gt;lchild) p[j++] = p[i]-&gt;lchild; if(p[i]-&gt;rchild) p[j++] = p[i]-&gt;rchild; i++; &#125;&#125; 层序遍历二叉树_2（利用队列实现）1234567891011121314151617181920212223Status LevelOrderTraverse_2(BiTree T, Status (*visit)(TElemType e))&#123; BiTree p; LinkQueue Q; InitQueue(Q); p = T; while (p || !QueueEmpty(Q)) &#123; if (p) &#123; visit(p-&gt;data); if (p-&gt;lchild) EnQueue(Q, p-&gt;lchild); if (p-&gt;rchild) EnQueue(Q, p-&gt;rchild); if (!QueueEmpty(Q)) DeQueue(Q, p); else //队列为空时，退出while循环 break; &#125; &#125; return OK;&#125; 先序遍历二叉树_1（递归）123456789void PreOrderTraverse_1(BiTree T, void(Visit)(TElemType))&#123; if(T) &#123; Visit(T-&gt;data); PreOrderTraverse_1(T-&gt;lchild, Visit); PreOrderTraverse_1(T-&gt;rchild, Visit); &#125;&#125; 先序遍历二叉树_2（递归）1234567891011121314Status PreOrderTraverse_2(BiTree T, Status(Visit)(TElemType))&#123; if(T) &#123; if(Visit(T-&gt;data)) &#123; PreOrderTraverse_2(T-&gt;lchild, Visit); PreOrderTraverse_2(T-&gt;rchild, Visit); &#125; return OK; &#125; else return ERROR;&#125; 先序遍历二叉树_1（非递归）123456789101112131415161718192021222324252627282930313233void PreOrderTraverse_3(BiTree T)&#123; SqStack S; SElemType_Sq e; if(!BiTreeEmpty(T)) &#123; InitStack_Sq(&amp;S); Push_Sq(&amp;S, T); while(!StackEmpty_Sq(S)) &#123; GetTop_Sq(S, &amp;e); printf("%c ", e-&gt;data); if(e-&gt;lchild) Push_Sq(&amp;S, e-&gt;lchild); else &#123; while(!StackEmpty_Sq(S)) &#123; Pop_Sq(&amp;S, &amp;e); if(e-&gt;rchild) &#123; Push_Sq(&amp;S, e-&gt;rchild); break; &#125; &#125; &#125; &#125; &#125;&#125; 先序遍历二叉树_2（非递归）1234567891011121314151617181920212223Status PreOrderTraverse_4(BiTree T, Status (*visit)(TElemType e))&#123; SqStack S; BiTree p; InitStack(S); p = T; while (p || !StackEmpty(S)) &#123; if (p) //访问根指针，左指针进栈 &#123; if (ERROR == visit(p-&gt;data)) return ERROR; Push(S, p); p = p-&gt;lchild; &#125; else &#123; Pop(S, p); p = p-&gt;rchild; &#125; &#125; return OK;&#125; 中序遍历二叉树_1（递归）123456789void InOrderTraverse_1(BiTree T, void(Visit)(TElemType))&#123; if(T) &#123; InOrderTraverse_1(T-&gt;lchild, Visit); Visit(T-&gt;data); InOrderTraverse_1(T-&gt;rchild, Visit); &#125;&#125; 中序遍历二叉树_2（非递归）12345678910111213141516171819202122232425Status InOrderTraverse_2(BiTree T, Status(Visit)(TElemType))&#123; SqStack S; SElemType_Sq p; InitStack_Sq(&amp;S); Push_Sq(&amp;S, T); while(!StackEmpty_Sq(S)) &#123; while(GetTop_Sq(S, &amp;p) &amp;&amp; p) //栈顶元素不为空 Push_Sq(&amp;S, p-&gt;lchild); //向左走到尽头 Pop_Sq(&amp;S, &amp;p); //空指针退栈 if(!StackEmpty_Sq(S)) //访问结点，向右一步 &#123; Pop_Sq(&amp;S, &amp;p); if(!Visit(p-&gt;data)) return ERROR; Push_Sq(&amp;S, p-&gt;rchild); &#125; &#125; return OK; &#125; 中序遍历二叉树_3（非递归）12345678910111213141516171819202122232425Status InOrderTraverse_3(BiTree T, Status(Visit)(TElemType))&#123; SqStack S; SElemType_Sq p; InitStack_Sq(&amp;S); p = T; while(p || !StackEmpty_Sq(S)) &#123; if(p) &#123; Push_Sq(&amp;S, p); p = p-&gt;lchild; &#125; else &#123; Pop_Sq(&amp;S, &amp;p); if(!Visit(p-&gt;data)) return ERROR; p = p-&gt;rchild; &#125; &#125; return OK; &#125; 后序遍历二叉树（递归）123456789void PostOrderTraverse(BiTree T, void(Visit)(TElemType))&#123; if(T) &#123; PostOrderTraverse(T-&gt;lchild, Visit); PostOrderTraverse(T-&gt;rchild, Visit); Visit(T-&gt;data); &#125;&#125; 后序遍历二叉树_1（非递归）123456789101112131415161718192021222324252627282930313233343536373839404142434445void PostOrderTraverse_1(BiTree T)&#123; SqStack S; BiTree p; SElemType_Sq e; int StackMark[100] = &#123;&#125;; //模拟栈，设置各结点访问标记 int k; InitStack_Sq(&amp;S); p = T; k = -1; while(1) &#123; while(p) &#123; Push_Sq(&amp;S, p); k++; StackMark[k] = 1; p = p-&gt;lchild; &#125; while(!p &amp;&amp; !StackEmpty_Sq(S)) //p为空但栈不为空 &#123; GetTop_Sq(S, &amp;p); if(StackMark[k]==1) //已访问过一次，当前是第二次访问 &#123; StackMark[k] = 2; p = p-&gt;rchild; &#125; else //已访问过两次，当前是第三次访问 &#123; printf("%c ", p-&gt;data); Pop_Sq(&amp;S, &amp;e); StackMark[k] = 0; k--; p = NULL; &#125; &#125; if(StackEmpty_Sq(S)) break; &#125; &#125; 后序遍历二叉树_2（非递归）12345678910111213141516171819202122232425262728293031323334353637Status PostOrderTraverse_2(BiTree T, Status (*visit)(TElemType e))&#123; SqStack S; InitStack(S); BiTree p; int Tag[20]; //标志栈 int t = 1; p = T; while (p || !StackEmpty(S)) &#123; while (p) //向左走到尽头 &#123; Push(S, p); p = p-&gt;lchild; Tag[t++] = 0; &#125; while (!StackEmpty(S) &amp;&amp; 1 == Tag[t-1]) //结点标志为1表示右子树已经访问过 &#123; Pop(S, p); t--; if (ERROR == visit(p-&gt;data)) return ERROR; &#125; if (!StackEmpty(S)) //结点标志为0，则访问右子树，并将结点标志置为1 &#123; Tag[t-1] = 1; GetTop(S, p); p = p-&gt;rchild; &#125; else break; &#125; return OK;&#125; 按二叉树的结构打印树12345678910111213141516171819202122232425262728293031323334353637383940414243void PrintTree(BiTree T)&#123; int row, col; int i, j, m, l, r; BiTNode a[100][100] = &#123;&#125;; //用一个足够大的矩阵按原样存储树 if(T) &#123; row = BiTreeDepth(T); //总行数 col = pow(2, row) - 1; //总列数 for(i=1; i&lt;=row-1; i++) &#123; for(j=1; j&lt;=pow(2, i-1); j++) &#123; m = (2*j-1)*pow(2, row-i); //当前行结点相对位序 l = (4*j-3)*pow(2, row-i-1); //下一行结点相对位序 r = (4*j-1)*pow(2, row-i-1); if(i==1) //初始化 a[i][m] = *T; if(a[i][m].lchild) //下一行 a[i+1][l] = *(a[i][m].lchild); if(a[i][m].rchild) //下一行 a[i+1][r] = *(a[i][m].rchild); &#125; &#125; for(i=1; i&lt;=row; i++) &#123; for(j=1; j&lt;=col; j++) &#123; if(a[i][j].data) printf("%c", a[i][j].data); else printf(" "); &#125; printf("\n"); &#125; &#125;&#125; 第四章 数据结构算法描述栈中缀表达式转换成后缀表达式（逆波兰式），并对逆波兰表达式求值 Question-3.21-main.c Question-3.22-main.c]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法介绍 Typora 编辑]]></title>
    <url>%2F2019%2F02%2F23%2Fmarkdown-yu-fa-jie-shao-typora-bian-ji%2F</url>
    <content type="text"><![CDATA[Markdown 语法介绍 (Typora 编辑) 注：部分Markdown语法无法在博客中显示，但在编辑器中能正常显示因显示原因，本文有删减，原文地址：https://blog.csdn.net/qq_43613189/article/details/87887737 [TOC] 参考资料： https://ouweiya.gitbooks.io/markdown/index.html https://www.jianshu.com/p/b03a8d7b1719 https://segmentfault.com/markdown#articleHeader4 https://wizardforcel.gitbooks.io/markdown-simple-world/0.html https://coding.net/help/doc/project/markdown.html https://guo365.github.io/study/Markdown.html https://yuedu.baidu.com/ebook/f2ec7e699a6648d7c1c708a1284ac850ad020418 标题使用#表示一级标题，##表示二级标题，以此类推，有6个标题。注：# 后面保持空格 目录列表 (TOC)输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。 引用单行式使用 &gt; 来插入块引用。例如： 1&gt; hello world! 演示： hello world! 多行式123&gt; hello world!hello world!hello world! 或者 123&gt; hello world!&gt; hello world!&gt; hello world! 演示 相同的结果 hello world!hello world!hello world! 多层嵌套12345678910&gt; aaaaaaaaa&gt; &gt; &gt; bbbbbbbbb&gt; &gt; &gt; &gt; &gt; cccccccccc&gt; &gt; &gt; &gt; &gt;&gt; &gt;&gt;&gt; 演示 aaaaaaaaa bbbbbbbbb cccccccccc 语义标记 描述 效果 代码 斜体 斜体 *斜体* 斜体 _斜体_ _斜体_ 加粗 加粗 **加粗** 加粗+斜体 加粗+斜体 ***加粗+斜体*** 加粗+斜体 加粗+斜体 **_加粗+斜体_** 删除线 删除线 ~~删除线~~ 斜体在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义： 1\* 加粗 (强调) 使用两个*号或者两个_包裹的内容将会被加粗。例如 12**使用两个*号加粗内容**__使用两个下划线加粗内容__ 将会输出 使用两个*号加粗内容 使用两个下划线加粗内容 Typroa 推荐使用两个\号。* 删除线GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用~~包裹的文本将会具有删除的样式，例如~删除文本~将产生删除文本的样式。 转义markdown支持在以下字符前面插入反斜杠 123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 插入之后，将不再解析这些字符，而是原样输出。 高亮高亮使用==包裹，例如：==高亮==将产生==高亮== 下标下标使用~包裹，例如：H~2~O将产生H~2~O, 即水的分子式。 上标上标使用^包裹，例如：y^2^=4将产生表达式y^2^ = 4 插入表情:happy:使用:happy:输入表情:happy:,使用:sad:输入表情:sad:,使用:cry:输入表情:cry:等。以此类推！ 下划线用HTML的语法&lt;u&gt;Underline&lt;/u&gt;将产生下划线Underline. 水平分割线使用***或者---，然后回车，来产生水平分割线。 注释我们可以对某一个词语进行注释。例如 12某些人用过了才知道[^注释][^注释]:Somebody that I used to know. 将产生： 某些人用过了才知道[^注释] [^注释]: Somebody that I used to know. 把鼠标放在注释上，将会有提示内容。 列表注：序列.后 保持空格 无序列表输入+, -, *创建无序的列表，使用任意数字开头，创建有序列表，例如： 1234**无序的列表*** one* two* three 无序的列表 one two three 有序列表1234**有序的列表**1. one2. two3. three 有序的列表 one two three 序表嵌套1234561. one 1. one-1 2. two-22. two * two-1 * two-2 演示 one one-1 two-2 two two-1 two-2 层级列表1234* 总目录 * 一级目录 * 二级目录 * 三级目录 说明：层级列表一般只支持三级列表，第一级实心圆点，第二级空心圆点，第三级以后都是实心方点。要实现层级列表，每下一级都要比上一级多输入2个空格或者一个Tab，而且第一级前面不要超过3个空格. 演示 总目录 一级目录 二级目录 三级目录 序表嵌套代码块 注：换行+两个Tab 12* one var a = 10; // 与上行保持空行并递进缩进 演示： one 1var a = 10; 任务列表使用如下的代码创建任务列表，在[ ]中输入x表示完成，也可以通过点击选择完成或者没完成。 123- [ ] 吃饭- [ ] 逛街- [ ] 看电影 吃饭 逛街 看电影 代码行内标记使用`包裹的内容将会以代码样式显示，例如 1使用`printf()` 则会产生 printf() 样式。 代码块注：与上行距离一空行，根据不同的语言配置不同的代码着色 输入`12345678例如：``` ~~~java public Class HelloWorld&#123; System.out.println(&quot;Hello World!&quot;); &#125; 12345678910 将会产生 ~~~java public Class HelloWorld&#123; System.out.println("Hello World!"); &#125; ~~~例如： 12345var num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num); ` 演示 12345var num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num); 插入图片 我们可以通过拖拉的方式，将本地文件夹中的图片或者网络上的图片插入。 超链接Markdown支持两种形式的链接语法：行内式和参考式，行内式一般用的比较多。 行内式：语法： 12[打开百度](https://www.baidu.com)[打开百度](https://www.baidu.com "打开百度") 说明:[]里写链接文字，()里写链接地址, ()中的” “中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 &quot;链接标题&quot;)这样的形式。链接地址与链接标题前有一个空格。 展示效果: 打开百度 打开百度 参考式:参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法: 12345我经常浏览的几个网站[Google][1]、[Baidu][2]、[51CTO][3]和看视频的网站[爱奇艺][4]感觉都是很不错的网站。[1]:http://www.google.com "google"[2]:http://www.baidu.com "Baidu"[3]:http://www.51cto.com "51cto"[4]:http://www.aiqiyi.com "aiqiyi" 展示效果： 我经常浏览的几个网站Google、Baidu、51CTO和看视频的网站爱奇艺感觉都是很不错的网站。 自动连接：语法： 12&lt;https://www.baidu.com&gt;&lt;xxx@outlook.com&gt; 说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。 展示效果： https://www.baidu.com &#x78;&#120;&#120;&#x40;&#x6f;&#x75;&#116;&#x6c;&#x6f;&#x6f;&#x6b;&#46;&#99;&#111;&#x6d; 锚点网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。 注意：Markdown Extra 只支持在标题后插入锚点，其它地方无效 页内超链接:语法： 12## 引用&#123;#index&#125; 跳转到[引用]&#123;#index&#125; 表格注：:代表对齐方式 ， : 与| 之间不要有空格 12345|姓名|性别|毕业学校|工资||:---|:---:|:---:|---:||杨洋|男|重庆交通大学|3200||峰哥|男|贵州大学|5000||坑货|女|北京大学|2000| 将产生: 姓名 性别 毕业学校 工资 杨洋 男 重庆交通大学 3200 峰哥 男 贵州大学 5000 坑货 女 北京大学 2000 其中代码的第二行指定对齐的方式，第一个是左对齐，第二个和第三个是居中，最后一个是右对齐。 特殊表格注：一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的所以常规的做法是使用HTML标签，但是这样的编写效率极低。但是有了这款工具的话，所有问题都迎刃而解。 在线生成HTML代码 Tables Generator (国外的站) ​ Tables Generator 演示 内嵌CSS样式代码 1&lt;p style="color: #AD5D0F;font-size: 30px; font-family: '宋体';"&gt;内联样式&lt;/p&gt; 演示 内联样式 数学公式数学表达式要启用这个功能，首先到Preference-&gt;Editor中启用。然后使用$符号包裹Tex命令。 例如： $lim_{x \to \infty} \ exp(-x)=0$将产生如下的数学表达式： $\lim_{x \to \infty} \exp(-x)=0$ $$ x \href{why-equal.html}{=} y^2 + 1 $$将产生如下的数学表达式： $$ x \href{why-equal.html}{=} y^2 + 1 ​$$ $ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $将产生如下的数学表达式： $ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. ​$]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-theme-matery]]></title>
    <url>%2F2019%2F02%2F17%2Fhexo-theme-matery%2F</url>
    <content type="text"><![CDATA[hexo-theme-matery English Document | 演示示例 | QQ 交流群: 926552981 这是一个采用 Material Design 和响应式设计的 Hexo 博客主题。 特性 简单漂亮，文章内容美观易读 Material Design 设计 响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现 每天动态切换 Banner 图片 瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替） 时间轴式的归档页 词云的标签页和雷达图的分类页 丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等） 可自定义的数据的友情链接页面 支持文章置顶和文章打赏 支持 MathJax TOC 目录 可设置复制文章内容时追加版权信息 可设置阅读文章时做密码验证 Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk） 集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能 支持在首页的音乐播放和视频播放功能 下载当你看到这里的时候，应该已经有一个自己的 Hexo 博客了。如果还没有的话，不妨使用 Hexo 和 Markdown 来写博客和文章。 点击 这里 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。 当然你也可以在你的 themes 文件夹下使用 Git clone 命令来下载: 1git clone https://github.com/blinkfox/hexo-theme-matery.git 配置切换主题修改 Hexo 根目录下的 _config.yml 的 theme 的值：theme: hexo-theme-matery _config.yml 文件的其它修改建议: 请修改 _config.yml 的 url 的值为你的网站主 URL（如：http://xxx.github.io）。 建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。 如果你是中文用户，则建议修改 language 的值为 zh-CN。 新建分类 categories 页categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page "categories" 编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容： 123456---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"--- 新建标签 tags 页tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page "tags" 编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容： 123456---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"--- 新建关于我 about 页about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page "about" 编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容： 123456---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"--- 新建友情连接 friends 页（可选的）friends 页是用来展示友情连接信息的页面，如果在你的博客 source 目录下还没有 friends/index.md 文件，那么你就需要新建一个，命令如下： 1hexo new page "friends" 编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容： 123456---title: friendsdate: 2018-12-12 21:25:30type: "friends"layout: "friends"--- 同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示： 12345678910111213141516171819[&#123; "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg", "name": "码酱", "introduction": "我不是大佬，只是在追寻大佬的脚步", "url": "http://luokangyuan.com/", "title": "前去学习"&#125;, &#123; "avatar": "http://image.luokangyuan.com/4027734.jpeg", "name": "闪烁之狐", "introduction": "编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬", "url": "https://blinkfox.github.io/", "title": "前去学习"&#125;, &#123; "avatar": "http://image.luokangyuan.com/avatar.jpg", "name": "ja_rome", "introduction": "平凡的脚步也可以走出伟大的行程", "url": "ttps://me.csdn.net/jlh912008548", "title": "前去学习"&#125;] 代码高亮由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 hexo-prism-plugin 的 Hexo 插件来做代码高亮，安装命令如下： 1npm i -S hexo-prism-plugin 然后，修改 Hexo 根目录下 _config.yml 文件中 highlight.enable 的值为 false，并新增 prism 插件相关的配置，主要配置如下： 12345678highlight: enable: falseprism_plugin: mode: 'preprocess' # realtime/preprocess theme: 'tomorrow' line_number: false # default false custom_css: 搜索本主题中还使用到了 hexo-generator-search 的 Hexo 插件来做内容搜索，安装命令如下： 1npm install hexo-generator-search --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123search: path: search.xml field: post 中文链接转拼音（可选的）如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 SEO，且 gitment 评论对中文链接也不支持。我们可以用 hexo-permalink-pinyin Hexo 插件使在生成文章时生成中文拼音的永久链接。 安装命令如下： 1npm i hexo-permalink-pinyin --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123permalink_pinyin: enable: true separator: '-' # default: '-' 注：除了此插件外，hexo-abbrlink 插件也可以生成非中文的链接。 文章字数统计插件（可选的）如果你想要在文章中显示文章字数、阅读时长信息，可以安装 hexo-wordcount插件。 安装命令如下： 1npm i --save hexo-wordcount 然后只需在本主题下的 _config.yml 文件中，激活以下配置项即可： 12345wordCount: enable: false # 将这个值设置为 true 即可. postWordCount: true min2read: true totalCount: true 添加 RSS 订阅支持（可选的）本主题中还使用到了 hexo-generator-feed 的 Hexo 插件来做 RSS，安装命令如下： 1npm install hexo-generator-feed --save 在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项： 123456789feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date 执行 hexo clean &amp;&amp; hexo g 重新生成博客文件，然后在 public 文件夹中即可看到 atom.xml 文件，说明你已经安装成功了。 修改页脚页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。 修改社交链接在主题的 _config.yml 文件中，默认支持 QQ、GitHub 和邮箱的配置，你可以在主题文件的 /layout/_partial/social-link.ejs 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码： 123&lt;a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"&gt; &lt;i class="fa fa-github"&gt;&lt;/i&gt;&lt;/a&gt; 其中，社交图标（如：fa-github）你可以在 Font Awesome 中搜索找到。以下是常用社交图标的标识，供你参考： Facebook: fa-facebook Twitter: fa-twitter Google-plus: fa-google-plus Linkedin: fa-linkedin Tumblr: fa-tumblr Medium: fa-medium Slack: fa-slack 新浪微博: fa-weibo 微信: fa-wechat QQ: fa-qq 注意: 本主题中使用的 Font Awesome 版本为 4.7.0。 修改打赏的二维码图片在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。 配置音乐播放器（可选的）要支持音乐播放，就必须开启音乐的播放配置和音乐数据的文件。 首先，在你的博客 source 目录下的 _data 目录（没有的话就新建一个）中新建 musics.json 文件，文件内容如下所示： 12345678910111213141516[&#123; "name": "五月雨变奏电音", "artist": "AnimeVibe", "url": "http://xxx.com/music1.mp3", "cover": "http://xxx.com/music-cover1.png"&#125;, &#123; "name": "Take me hand", "artist": "DAISHI DANCE,Cecile Corbel", "url": "/medias/music/music2.mp3", "cover": "/medias/music/cover2.png"&#125;, &#123; "name": "Shape of You", "artist": "J.Fla", "url": "http://xxx.com/music3.mp3", "cover": "http://xxx.com/music-cover3.png"&#125;] 注：以上 JSON 中的属性：name、artist、url、cover 分别表示音乐的名称、作者、音乐文件地址、音乐封面。 然后，在主题的 _config.yml 配置文件中激活配置即可： 1234567891011121314# 是否在首页显示音乐.music: enable: true showTitle: false title: 听听音乐 fixed: false # 是否开启吸底模式 autoplay: false # 是否自动播放 theme: '#42b983' loop: 'all' # 音频循环播放, 可选值: 'all', 'one', 'none' order: 'list' # 音频循环顺序, 可选值: 'list', 'random' preload: 'auto' # 预加载，可选值: 'none', 'metadata', 'auto' volume: 0.7 # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 listFolded: false # 列表默认折叠 listMaxHeight: # 列表最大高度 文章 Front-matter 示例以下为文章 Front-matter 的示例和说明，所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。 123456789101112131415161718---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇 # 图片推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如:http://xxx.com/xxx.jpgimg: /source/images/xxx.jpg# 如果top值为true，则会是首页推荐文章top: true# 如果要对文章设置阅读验证密码的话，就可以在设置password的值，该值必须是用SHA256加密后的密码，防止被他人识破password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92# 本文章是否开启mathjax，且需要在主题的_config.yml文件中也需要开启才行mathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags: - Typora - Markdown--- 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 效果截图 自定制修改在本主题的 _config.yml 中可以修改部分自定义信息，有以下几个部分： 菜单 我的梦想 首页的音乐播放器和视频播放器配置 是否显示推荐文章名称和按钮配置 favicon 和 Logo 个人信息 TOC 目录 文章打赏信息 复制文章内容时追加版权信息 MathJax 文章字数统计、阅读时长 点击页面的’爱心’效果 我的项目 我的技能 我的相册 Gitalk、Gitment、Valine 和 disqus 评论配置 不蒜子统计和谷歌分析（Google Analytics） 默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图 我认为个人博客应该都有自己的风格和特色。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 _config.yml 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方： 修改主题颜色在主题文件的 /source/css/matery.css 文件中，搜索 .bg-color 来修改背景颜色： 1234567891011121314151617/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */.bg-color &#123; background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);&#125;/* 和背景颜色相同的文字颜色，目前仅在首页一个地方使用到，你也可以将此样式应用到其他地方. */.text-color &#123; color: #0f9d58 !important;&#125;@-webkit-keyframes rainbow &#123; /* 动态切换背景颜色. */&#125;@keyframes rainbow &#123; /* 动态切换背景颜色. */&#125; 修改 banner 图和文章特色图你可以直接在 /source/medias/banner 文件夹中更换你喜欢的 banner 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 JavaScript 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，banner 切换的代码位置在 /layout/_partial/bg-cover.ejs 文件的 &lt;script&gt;&lt;/script&gt; 代码中： 1$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)'); 在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 _config.yml 做同步修改。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora For Markdown 语法]]></title>
    <url>%2F2019%2F02%2F16%2Ftypora-for-markdown-yu-fa%2F</url>
    <content type="text"><![CDATA[#Typora For Markdown 语法 [TOC] ###数学表达式 要启用这个功能，首先到Preference-&gt;Editor中启用。然后使用$符号包裹Tex命令，例如：$lim_{x \to \infty} \ exp(-x)=0$将产生如下的数学表达式： $\lim_{x \to \infty} \exp(-x)=0$ ###下标 下标使用~包裹，例如：H~2~O将产生H~2~O, 即水的分子式。 ###上标 上标使用^包裹，例如：y^2^=4将产生表达式y^2^ = 4 ###插入表情:happy: 使用:happy:输入表情:happy:,使用:sad:输入表情:sad:,使用:cry:输入表情:cry:等。以此类推！ 下划线用HTML的语法&lt;u&gt;Underline&lt;/u&gt;将产生下划线Underline. 删除线GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用~~包裹的文本将会具有删除的样式，例如~删除文本~将产生删除文本的样式。 代码 使用`包裹的内容将会以代码样式显示，例如 1使用`printf()` 则会产生printf()样式。 输入`12* 123public Class HelloWorld&#123; System.out.println("Hello World!");&#125; 1234567将会产生~~~javapublic Class HelloWorld&#123; System.out.println("Hello World!");&#125; 强调使用两个*号或者两个_包裹的内容将会被强调。例如 12**使用两个*号强调内容**__使用两个下划线强调内容__ 将会输出 使用两个*号强调内容使用两个下划线强调内容Typroa 推荐使用两个*号。 斜体在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义： 1\* 插入图片我们可以通过拖拉的方式，将本地文件夹中的图片或者网络上的图片插入。 ​ ​ 插入URL连接使用尖括号包裹的url将产生一个连接，例如：&lt;www.baidu.com&gt;将产生连接:&lt;www.baidu.com&gt;. 如果是标准的url，则会自动产生连接，例如:www.google.com 目录列表Table of Contents（TOC）输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。 水平分割线使用***或者---，然后回车，来产生水平分割线。 标注我们可以对某一个词语进行标注。例如 12某些人用过了才知道[^注释][^注释]:Somebody that I used to know. 将产生： 某些人用过了才知道[^注释][^注释]: Somebody that I used to know. 把鼠标放在注释上，将会有提示内容。 表格12345|姓名|性别|毕业学校|工资||:---|:---:|:---:|---:||杨洋|男|重庆交通大学|3200||峰哥|男|贵州大学|5000||坑货|女|北京大学|2000| 将产生: 姓名 性别 毕业学校 工资 杨洋 男 重庆交通大学 3200 峰哥 男 贵州大学 5000 坑货 女 北京大学 2000 其中代码的第二行指定对齐的方式，第一个是左对齐，第二个和第三个是居中，最后一个是右对齐。 数学表达式块输入两个美元符号，然后回车，就可以输入数学表达式块了。例如： 1$$\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 = \begin&#123;vmatrix&#125; \mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\\end&#123;vmatrix&#125;$$ 将会产生: $$\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \\end{vmatrix}​$$ $$f(x) = a_1x^n + a_2x^{n-1} + a_3x^{n-2}$$ 任务列表使用如下的代码创建任务列表，在[]中输入x表示完成，也可以通过点击选择完成或者没完成。 123- [ ] 吃饭- [ ] 逛街- [ ] 看电影 吃饭 逛街​ 看电影 列表输入+, -, *,创建无序的列表，使用任意数字开头，创建有序列表，例如： 1234**无序的列表*** tfboys* 杨洋* 我爱你 无序的列表 tfboys 杨洋 我爱你 1234**有序的列表**1. 苹果6. 香蕉10. 我都不喜欢 有序的列表 苹果 香蕉 我都不喜欢 块引用使用&gt;来插入块引用。例如： 1&gt;这是一个块引用！ 将产生： 这是一个块引用！ 标题使用#表示一级标题，##表示二级标题，以此类推，有6个标题。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[text]]></title>
    <url>%2F2019%2F02%2F16%2Ftext%2F</url>
    <content type="text"><![CDATA[Welcome to my blog, enter password to read. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>wechat</tag>
      </tags>
  </entry>
</search>
