<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【数据结构】数据结构（C语言版）严蔚敏版代码实现</title>
      <link href="/2019/06/06/All-In-One/"/>
      <url>/2019/06/06/All-In-One/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据结构（C语言版）专题整理自：<a href="https://github.com/kangjianwei/Data-Structure" target="_blank" rel="noopener">这里</a></p></blockquote><table><thead><tr><th style="text-align:left"><a href="https://dddanbo.cn/2019/06/06/Preface/" target="_blank" rel="noopener"><strong>第一章    绪论</strong></a></th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://dddanbo.cn/2019/06/06/List/" target="_blank" rel="noopener"><strong>第二章    线性表</strong></a></td></tr><tr><td style="text-align:left"><a href="https://dddanbo.cn/2019/06/06/Stack/" target="_blank" rel="noopener"><strong>第三章    栈</strong></a></td></tr><tr><td style="text-align:left"><a href="https://dddanbo.cn/2019/06/06/Queue/" target="_blank" rel="noopener"><strong>第三章    队列</strong></a></td></tr><tr><td style="text-align:left"><a href="https://dddanbo.cn/2019/06/06/String/" target="_blank" rel="noopener"><strong>第四章    串</strong></a></td></tr><tr><td style="text-align:left"><a href="https://dddanbo.cn/2019/06/06/Array-and-List/" target="_blank" rel="noopener"><strong>第五章    数组和广义表</strong></a></td></tr><tr><td style="text-align:left"><a href="https://dddanbo.cn/2019/06/06/Tree/" target="_blank" rel="noopener"><strong>第六章    树</strong></a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】第六章	树</title>
      <link href="/2019/06/06/Tree/"/>
      <url>/2019/06/06/Tree/</url>
      
        <content type="html"><![CDATA[<h1><span id="目录"> 目录</span></h1><p><ul class="markdownIt-TOC"><li><a href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91">树和二叉树</a><ul><li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">二叉树（二叉链表存储）相关类型定义</a><ul><li><a href="#%E6%A0%88%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B">栈元素类型</a></li><li><a href="#%E5%AD%98%E5%82%A8%E5%BD%93%E5%89%8D%E7%BB%93%E7%82%B9%E4%BF%A1%E6%81%AF%E6%8C%89%E6%A0%91%E7%BB%93%E6%9E%84%E6%89%93%E5%8D%B0%E6%A0%91%E7%9A%84%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8">存储当前结点信息，按树结构打印树的时候使用</a></li></ul></li><li><a href="#%E6%9E%84%E9%80%A0%E7%A9%BA%E4%BA%8C%E5%8F%89%E6%A0%91t-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91">构造空二叉树T (初始化二叉树)</a></li><li><a href="#%E6%B8%85%E7%A9%BA%E4%BA%8C%E5%8F%89%E6%A0%91t">清空二叉树T</a></li><li><a href="#%E9%94%80%E6%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91t">销毁二叉树T</a></li><li><a href="#%E5%88%A4%E6%96%AD%E4%BA%8C%E5%8F%89%E6%A0%91t%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA">判断二叉树T是否为空</a></li><li><a href="#%E6%8C%89%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91_1">按先序序列构造二叉树_1</a></li><li><a href="#%E6%8C%89%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91_2">按先序序列构造二叉树_2</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E4%BA%8C%E5%8F%89%E6%A0%91%E9%95%BF%E5%BA%A6%E6%8C%89%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%AE%A1%E7%AE%97">返回二叉树长度（按完全二叉树计算）</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E5%B1%82%E6%95%B0">返回二叉树深度（层数）</a></li><li><a href="#%E7%94%A8e%E8%BF%94%E5%9B%9E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A0%B9%E7%BB%93%E7%82%B9%E5%80%BC">用e返回二叉树的根结点值</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E6%9F%90%E7%BB%93%E7%82%B9%E7%9A%84%E5%80%BCp%E4%B8%BA%E7%BB%93%E7%82%B9%E6%8C%87%E9%92%88">返回某结点的值，p为结点指针</a></li><li><a href="#%E4%B8%BA%E6%9F%90%E7%BB%93%E7%82%B9%E8%B5%8B%E5%80%BCp%E4%B8%BA%E7%BB%93%E7%82%B9%E6%8C%87%E9%92%88">为某结点赋值，p为结点指针</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E6%9F%90%E7%BB%93%E7%82%B9%E7%9A%84%E5%8F%8C%E4%BA%B2%E7%BB%93%E7%82%B9%E5%80%BC">返回某结点的双亲结点值</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E6%9F%90%E7%BB%93%E7%82%B9%E7%9A%84%E5%B7%A6%E5%AD%A9%E5%AD%90%E7%BB%93%E7%82%B9%E5%80%BC">返回某结点的左孩子结点值</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E6%9F%90%E7%BB%93%E7%82%B9%E7%9A%84%E5%8F%B3%E5%AD%A9%E5%AD%90%E7%BB%93%E7%82%B9%E5%80%BC">返回某结点的右孩子结点值</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E6%9F%90%E7%BB%93%E7%82%B9%E7%9A%84%E5%B7%A6%E5%85%84%E5%BC%9F%E7%BB%93%E7%82%B9%E5%80%BC">返回某结点的左兄弟结点值</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E6%9F%90%E7%BB%93%E7%82%B9%E7%9A%84%E5%8F%B3%E5%85%84%E5%BC%9F%E7%BB%93%E7%82%B9%E5%80%BC">返回某结点的右兄弟结点值</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E6%8C%87%E5%90%91%E7%BB%93%E7%82%B9e%E7%9A%84%E6%8C%87%E9%92%88_1">获取指向结点e的指针_1</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E6%8C%87%E5%90%91%E7%BB%93%E7%82%B9e%E7%9A%84%E6%8C%87%E9%92%88_2">获取指向结点e的指针_2</a></li><li><a href="#%E5%B0%86%E6%A0%91t0%E6%8F%92%E5%85%A5%E5%88%B0%E6%A0%91t%E4%B8%AD%E6%88%90%E4%B8%BA%E7%BB%93%E7%82%B9e%E7%9A%84%E5%AD%90%E6%A0%91lr%E4%B8%BA%E6%8F%92%E5%85%A5%E6%A0%87%E8%AE%B0t0%E5%8F%AA%E6%9C%89%E5%B7%A6%E5%AD%90%E6%A0%91">将树T0插入到树T中成为结点e的子树，LR为插入标记，T0只有左子树</a></li><li><a href="#%E5%88%A0%E9%99%A4e%E7%BB%93%E7%82%B9%E7%9A%84%E5%B7%A6%E5%AD%90%E6%A0%91%E6%88%96%E5%8F%B3%E5%AD%90%E6%A0%91lr%E4%B8%BA%E5%88%A0%E9%99%A4%E6%A0%87%E8%AE%B0">删除e结点的左子树或右子树，LR为删除标记</a></li><li><a href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91_1%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0">层序遍历二叉树_1（利用数组实现）</a></li><li><a href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91_2%E5%88%A9%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0">层序遍历二叉树_2（利用队列实现）</a></li><li><a href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91_1%E9%80%92%E5%BD%92">先序遍历二叉树_1（递归）</a></li><li><a href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91_2%E9%80%92%E5%BD%92">先序遍历二叉树_2（递归）</a></li><li><a href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91_1%E9%9D%9E%E9%80%92%E5%BD%92">先序遍历二叉树_1（非递归）</a></li><li><a href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91_2%E9%9D%9E%E9%80%92%E5%BD%92">先序遍历二叉树_2（非递归）</a></li><li><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91_1%E9%80%92%E5%BD%92">中序遍历二叉树_1（递归）</a></li><li><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91_2%E9%9D%9E%E9%80%92%E5%BD%92">中序遍历二叉树_2（非递归）</a></li><li><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91_3%E9%9D%9E%E9%80%92%E5%BD%92">中序遍历二叉树_3（非递归）</a></li><li><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%92%E5%BD%92">后序遍历二叉树（递归）</a></li><li><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91_1%E9%9D%9E%E9%80%92%E5%BD%92">后序遍历二叉树_1（非递归）</a></li><li><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91_2%E9%9D%9E%E9%80%92%E5%BD%92">后序遍历二叉树_2（非递归）</a></li><li><a href="#%E6%8C%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84%E6%89%93%E5%8D%B0%E6%A0%91">按二叉树的结构打印树</a></li></ul></li></ul></p><h2><span id="树和二叉树"> 树和二叉树</span></h2><h3><span id="二叉树二叉链表存储相关类型定义"> 二叉树（二叉链表存储）相关类型定义</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;<span class="comment">//假设二叉树元素均为字符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType data;<span class="comment">//结点元素 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>;</span><span class="comment">//左孩子指针 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">rchild</span>;</span><span class="comment">//右孩子指针 </span></span><br><span class="line">&#125;BiTNode;<span class="comment">//二叉树结点 </span></span><br><span class="line"><span class="keyword">typedef</span> BiTNode* BiTree;<span class="comment">//指向二叉树结点的指针</span></span><br></pre></td></tr></table></figure><h4><span id="栈元素类型"> 栈元素类型</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> BiTree SElemType_Sq;<span class="comment">//重定义栈元素类型 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../../▲03 栈和队列/01 SequenceStack/SequenceStack.c"</span><span class="comment">//**▲03 栈和队列**// </span></span></span><br><span class="line"></span><br><span class="line">要用到栈的类型定义</span><br></pre></td></tr></table></figure><h4><span id="存储当前结点信息按树结构打印树的时候使用"> 存储当前结点信息，按树结构打印树的时候使用</span></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">BiTree left;<span class="comment">//当前结点的左指针 </span></span><br><span class="line">BiTree right;<span class="comment">//当前结点的右指针 </span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//当前结点的次序 </span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><h3><span id="构造空二叉树t-初始化二叉树"> 构造空二叉树T (初始化二叉树)</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*T = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="清空二叉树t"> 清空二叉树T</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(*T) <span class="comment">//二叉树不为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((*T)-&gt;lchild)<span class="comment">//清空左树 </span></span><br><span class="line">ClearBiTree(&amp;((*T)-&gt;lchild));</span><br><span class="line"><span class="keyword">if</span>((*T)-&gt;rchild)<span class="comment">//清空右树 </span></span><br><span class="line">ClearBiTree(&amp;((*T)-&gt;rchild));</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(*T);<span class="comment">//释放根结点 </span></span><br><span class="line"></span><br><span class="line">*T = <span class="literal">NULL</span>;<span class="comment">//置空树指针 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="销毁二叉树t"> 销毁二叉树T</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//二叉树无法销毁 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="判断二叉树t是否为空"> 判断二叉树T是否为空</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BiTreeEmpty</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> T==<span class="literal">NULL</span> ? TRUE : ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="按先序序列构造二叉树_1"> 按先序序列构造二叉树_1</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(FILE *fp, BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">Scanf(fp, <span class="string">"%c"</span>, &amp;ch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'^'</span>)</span><br><span class="line">*T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"><span class="keyword">if</span>(!(*T))</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*T)-&gt;data = ch;</span><br><span class="line">CreateBiTree(fp, &amp;(*T)-&gt;lchild);</span><br><span class="line">CreateBiTree(fp, &amp;(*T)-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="按先序序列构造二叉树_2"> 按先序序列构造二叉树_2</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">f</span><span class="params">(FILE *fp, BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">Scanf(fp, <span class="string">"%c"</span>, &amp;ch);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ch == <span class="string">'^'</span>)</span><br><span class="line">*T = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line"><span class="keyword">if</span>(!(*T))</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">(*T)-&gt;data = ch;</span><br><span class="line">CreateBiTree(fp, &amp;(*T)-&gt;lchild);</span><br><span class="line">CreateBiTree(fp, &amp;(*T)-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="返回二叉树长度按完全二叉树计算"> 返回二叉树长度（按完全二叉树计算）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTreeLength</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node node[<span class="number">100</span>];<span class="comment">//存储结点信息 </span></span><br><span class="line"><span class="keyword">int</span> i, len;</span><br><span class="line"></span><br><span class="line">i = len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T)</span><br><span class="line">&#123;</span><br><span class="line">node[i].left = T-&gt;lchild;</span><br><span class="line">node[i].right = T-&gt;rchild;</span><br><span class="line">node[i].n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(node[i].n&gt;len)</span><br><span class="line">len = node[i].n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(node[i].left)<span class="comment">//访问左子树 </span></span><br><span class="line">&#123;</span><br><span class="line">node[i+<span class="number">1</span>].left = node[i].left-&gt;lchild;</span><br><span class="line">node[i+<span class="number">1</span>].right = node[i].left-&gt;rchild;</span><br><span class="line">node[i+<span class="number">1</span>].n = <span class="number">2</span>*node[i].n;</span><br><span class="line">node[i].left = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(node[i].n&gt;len)</span><br><span class="line">len = node[i].n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].right)<span class="comment">//左子树为空时访问右子树 </span></span><br><span class="line">&#123;</span><br><span class="line">node[i+<span class="number">1</span>].left = node[i].right-&gt;lchild;</span><br><span class="line">node[i+<span class="number">1</span>].right = node[i].right-&gt;rchild;</span><br><span class="line">node[i+<span class="number">1</span>].n = <span class="number">2</span>*node[i].n+<span class="number">1</span>;</span><br><span class="line">node[i].right = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(node[i].n&gt;len)</span><br><span class="line">len = node[i].n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].left==<span class="literal">NULL</span> &amp;&amp; node[i].right==<span class="literal">NULL</span>)</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="返回二叉树深度层数"> 返回二叉树深度（层数）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTreeDepth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> LD, RD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//空树深度为0 </span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LD = BiTreeDepth(T-&gt;lchild);<span class="comment">//求左子树深度 </span></span><br><span class="line">RD = BiTreeDepth(T-&gt;rchild);<span class="comment">//求右子树深度 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (LD&gt;=RD?LD:RD)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="用e返回二叉树的根结点值"> 用e返回二叉树的根结点值</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Root</span><span class="params">(BiTree T, TElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!T)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">*e = T-&gt;data;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="返回某结点的值p为结点指针"> 返回某结点的值，p为结点指针</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TElemType <span class="title">Value</span><span class="params">(BiTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="为某结点赋值p为结点指针"> 为某结点赋值，p为结点指针</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assign</span><span class="params">(BiTree p, TElemType value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p-&gt;data = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="返回某结点的双亲结点值"> 返回某结点的双亲结点值</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TElemType <span class="title">Parent</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTNode node[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span> || (T!=<span class="literal">NULL</span> &amp;&amp; e==T-&gt;data))</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">node[i] = *T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(node[i].lchild)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].lchild-&gt;data==e)</span><br><span class="line"><span class="keyword">return</span> node[i].data;</span><br><span class="line">node[i+<span class="number">1</span>] = *(node[i].lchild);</span><br><span class="line">node[i].lchild = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].rchild)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].rchild-&gt;data==e)</span><br><span class="line"><span class="keyword">return</span> node[i].data;</span><br><span class="line">node[i+<span class="number">1</span>] = *(node[i].rchild);</span><br><span class="line">node[i].rchild = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].lchild==<span class="literal">NULL</span> &amp;&amp; node[i].rchild==<span class="literal">NULL</span>)</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="返回某结点的左孩子结点值"> 返回某结点的左孩子结点值</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TElemType <span class="title">LeftChild</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTNode node[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!T)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">node[i] = *T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(node[i].data!=e &amp;&amp; node[i].lchild)</span><br><span class="line">&#123;</span><br><span class="line">node[i+<span class="number">1</span>] = *(node[i].lchild);</span><br><span class="line">node[i].lchild = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].data==e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].lchild)</span><br><span class="line"><span class="keyword">return</span> node[i].lchild-&gt;data;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].rchild)</span><br><span class="line">&#123;</span><br><span class="line">node[i+<span class="number">1</span>] = *(node[i].rchild);</span><br><span class="line">node[i].rchild = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].lchild==<span class="literal">NULL</span> &amp;&amp; node[i].rchild==<span class="literal">NULL</span> &amp;&amp; node[i].data!=e)</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="返回某结点的右孩子结点值"> 返回某结点的右孩子结点值</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TElemType <span class="title">RightChild</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTNode node[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!T)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">node[i] = *T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(node[i].data!=e &amp;&amp; node[i].lchild)</span><br><span class="line">&#123;</span><br><span class="line">node[i+<span class="number">1</span>] = *(node[i].lchild);</span><br><span class="line">node[i].lchild = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].data==e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].rchild)</span><br><span class="line"><span class="keyword">return</span> node[i].rchild-&gt;data;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].rchild)</span><br><span class="line">&#123;</span><br><span class="line">node[i+<span class="number">1</span>] = *(node[i].rchild);</span><br><span class="line">node[i].rchild = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node[i].lchild==<span class="literal">NULL</span> &amp;&amp; node[i].rchild==<span class="literal">NULL</span>)</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="返回某结点的左兄弟结点值"> 返回某结点的左兄弟结点值</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TElemType <span class="title">LeftSibling</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTNode node[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span> || (T!=<span class="literal">NULL</span> &amp;&amp; e==T-&gt;data))</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">node[i] = *T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(node[i].rchild)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].rchild-&gt;data==e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].lchild)</span><br><span class="line"><span class="keyword">return</span> node[i].lchild-&gt;data;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node[i+<span class="number">1</span>] = *(node[i].rchild);</span><br><span class="line">node[i].rchild = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].lchild)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].lchild-&gt;data==e)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">node[i+<span class="number">1</span>] = *(node[i].lchild);</span><br><span class="line">node[i].lchild = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].lchild==<span class="literal">NULL</span> &amp;&amp; node[i].rchild==<span class="literal">NULL</span>)</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="返回某结点的右兄弟结点值"> 返回某结点的右兄弟结点值</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TElemType <span class="title">RightSibling</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTNode node[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span> || (T!=<span class="literal">NULL</span> &amp;&amp; e==T-&gt;data))</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">node[i] = *T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(node[i].lchild)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].lchild-&gt;data==e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].rchild)</span><br><span class="line"><span class="keyword">return</span> node[i].rchild-&gt;data;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line">node[i+<span class="number">1</span>] = *(node[i].lchild);</span><br><span class="line">node[i].lchild = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].rchild)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].rchild-&gt;data==e)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">node[i+<span class="number">1</span>] = *(node[i].rchild);</span><br><span class="line">node[i].rchild = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].lchild==<span class="literal">NULL</span> &amp;&amp; node[i].rchild==<span class="literal">NULL</span>)</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="获取指向结点e的指针_1"> 获取指向结点e的指针_1</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">LocationBiTree_1</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTNode node[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T-&gt;data==e)</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line"></span><br><span class="line">node[i] = *T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(node[i].lchild)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].lchild-&gt;data==e)</span><br><span class="line"><span class="keyword">return</span> node[i].lchild;</span><br><span class="line">node[i+<span class="number">1</span>] = *(node[i].lchild);</span><br><span class="line">node[i].lchild = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].rchild)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(node[i].rchild-&gt;data==e)</span><br><span class="line"><span class="keyword">return</span> node[i].rchild;</span><br><span class="line">node[i+<span class="number">1</span>] = *(node[i].rchild);</span><br><span class="line">node[i].rchild = <span class="literal">NULL</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(node[i].lchild==<span class="literal">NULL</span> &amp;&amp; node[i].rchild==<span class="literal">NULL</span>)</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="获取指向结点e的指针_2"> 获取指向结点e的指针_2</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">LocationBiTree_2</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;data==e)</span><br><span class="line">p = T;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p=LocationBiTree_2(T-&gt;lchild, e))</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p=LocationBiTree_2(T-&gt;rchild, e))</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="将树t0插入到树t中成为结点e的子树lr为插入标记t0只有左子树"> 将树T0插入到树T中成为结点e的子树，LR为插入标记，T0只有左子树</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InsertBiTree</span><span class="params">(BiTree T, TElemType e, BiTree T0, <span class="keyword">int</span> LR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree p = LocationBiTree_1(T, e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">T0-&gt;rchild = LR ? p-&gt;rchild : p-&gt;lchild;</span><br><span class="line">LR ? (p-&gt;rchild=T0) : (p-&gt;lchild=T0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="删除e结点的左子树或右子树lr为删除标记"> 删除e结点的左子树或右子树，LR为删除标记</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteBiTree</span><span class="params">(BiTree T, TElemType e, <span class="keyword">int</span> LR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree p = LocationBiTree_2(T, e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">LR ? ClearBiTree(&amp;(p-&gt;rchild)) : ClearBiTree(&amp;(p-&gt;lchild));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="层序遍历二叉树_1利用数组实现"> 层序遍历二叉树_1（利用数组实现）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse_1</span><span class="params">(BiTree T, <span class="keyword">void</span>(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">BiTree p[<span class="number">100</span>];<span class="comment">//树指针数组</span></span><br><span class="line"></span><br><span class="line">i = j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T)</span><br><span class="line">p[j++] = T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;j)</span><br><span class="line">&#123;</span><br><span class="line">Visit(p[i]-&gt;data);</span><br><span class="line"><span class="keyword">if</span>(p[i]-&gt;lchild)</span><br><span class="line">p[j++] = p[i]-&gt;lchild;</span><br><span class="line"><span class="keyword">if</span>(p[i]-&gt;rchild)</span><br><span class="line">p[j++] = p[i]-&gt;rchild;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="层序遍历二叉树_2利用队列实现"> 层序遍历二叉树_2（利用队列实现）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LevelOrderTraverse_2</span><span class="params">(BiTree T, Status (*visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BiTree p;</span><br><span class="line">LinkQueue Q;</span><br><span class="line">InitQueue(Q);</span><br><span class="line">p = T;</span><br><span class="line"><span class="keyword">while</span> (p || !QueueEmpty(Q))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line">&#123;</span><br><span class="line">visit(p-&gt;data);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild)</span><br><span class="line">EnQueue(Q, p-&gt;lchild);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;rchild)</span><br><span class="line">EnQueue(Q, p-&gt;rchild);</span><br><span class="line"><span class="keyword">if</span> (!QueueEmpty(Q))</span><br><span class="line">DeQueue(Q, p);</span><br><span class="line"><span class="keyword">else</span><span class="comment">//队列为空时，退出while循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="先序遍历二叉树_1递归"> 先序遍历二叉树_1（递归）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse_1</span><span class="params">(BiTree T, <span class="keyword">void</span>(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T)</span><br><span class="line">&#123;</span><br><span class="line">Visit(T-&gt;data);</span><br><span class="line">PreOrderTraverse_1(T-&gt;lchild, Visit);</span><br><span class="line">PreOrderTraverse_1(T-&gt;rchild, Visit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="先序遍历二叉树_2递归"> 先序遍历二叉树_2（递归）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PreOrderTraverse_2</span><span class="params">(BiTree T, Status(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">&#123;</span><br><span class="line">PreOrderTraverse_2(T-&gt;lchild, Visit);</span><br><span class="line">PreOrderTraverse_2(T-&gt;rchild, Visit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="先序遍历二叉树_1非递归"> 先序遍历二叉树_1（非递归）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse_3</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack S;</span><br><span class="line">SElemType_Sq e;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!BiTreeEmpty(T))</span><br><span class="line">&#123;</span><br><span class="line">InitStack_Sq(&amp;S);</span><br><span class="line">Push_Sq(&amp;S, T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!StackEmpty_Sq(S))</span><br><span class="line">&#123;</span><br><span class="line">GetTop_Sq(S, &amp;e);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, e-&gt;data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(e-&gt;lchild)</span><br><span class="line">Push_Sq(&amp;S, e-&gt;lchild);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(!StackEmpty_Sq(S))</span><br><span class="line">&#123;</span><br><span class="line">Pop_Sq(&amp;S, &amp;e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(e-&gt;rchild)</span><br><span class="line">&#123;</span><br><span class="line">Push_Sq(&amp;S, e-&gt;rchild);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="先序遍历二叉树_2非递归"> 先序遍历二叉树_2（非递归）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PreOrderTraverse_4</span><span class="params">(BiTree T, Status (*visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack S;</span><br><span class="line">BiTree p;</span><br><span class="line">InitStack(S);</span><br><span class="line">p = T;</span><br><span class="line"><span class="keyword">while</span> (p || !StackEmpty(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p)  <span class="comment">//访问根指针，左指针进栈</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ERROR == visit(p-&gt;data))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">Push(S, p);</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Pop(S, p);</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="中序遍历二叉树_1递归"> 中序遍历二叉树_1（递归）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse_1</span><span class="params">(BiTree T, <span class="keyword">void</span>(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T)</span><br><span class="line">&#123;</span><br><span class="line">InOrderTraverse_1(T-&gt;lchild, Visit);</span><br><span class="line">Visit(T-&gt;data);</span><br><span class="line">InOrderTraverse_1(T-&gt;rchild, Visit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="中序遍历二叉树_2非递归"> 中序遍历二叉树_2（非递归）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse_2</span><span class="params">(BiTree T, Status(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack S;</span><br><span class="line">SElemType_Sq p;</span><br><span class="line"></span><br><span class="line">InitStack_Sq(&amp;S);</span><br><span class="line">Push_Sq(&amp;S, T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!StackEmpty_Sq(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(GetTop_Sq(S, &amp;p) &amp;&amp; p)<span class="comment">//栈顶元素不为空</span></span><br><span class="line">Push_Sq(&amp;S, p-&gt;lchild);<span class="comment">//向左走到尽头</span></span><br><span class="line"></span><br><span class="line">Pop_Sq(&amp;S, &amp;p);<span class="comment">//空指针退栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!StackEmpty_Sq(S))<span class="comment">//访问结点，向右一步 </span></span><br><span class="line">&#123;</span><br><span class="line">Pop_Sq(&amp;S, &amp;p);</span><br><span class="line"><span class="keyword">if</span>(!Visit(p-&gt;data))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">Push_Sq(&amp;S, p-&gt;rchild);</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="中序遍历二叉树_3非递归"> 中序遍历二叉树_3（非递归）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse_3</span><span class="params">(BiTree T, Status(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack S;</span><br><span class="line">SElemType_Sq p;</span><br><span class="line"></span><br><span class="line">InitStack_Sq(&amp;S);</span><br><span class="line">p = T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p || !StackEmpty_Sq(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">Push_Sq(&amp;S, p);</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Pop_Sq(&amp;S, &amp;p);</span><br><span class="line"><span class="keyword">if</span>(!Visit(p-&gt;data))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="后序遍历二叉树递归"> 后序遍历二叉树（递归）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T, <span class="keyword">void</span>(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T)</span><br><span class="line">&#123;</span><br><span class="line">PostOrderTraverse(T-&gt;lchild, Visit);</span><br><span class="line">PostOrderTraverse(T-&gt;rchild, Visit);</span><br><span class="line">Visit(T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="后序遍历二叉树_1非递归"> 后序遍历二叉树_1（非递归）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse_1</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack S;</span><br><span class="line">BiTree p;</span><br><span class="line">SElemType_Sq e;</span><br><span class="line"><span class="keyword">int</span> StackMark[<span class="number">100</span>] = &#123;&#125;;<span class="comment">//模拟栈，设置各结点访问标记 </span></span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">InitStack_Sq(&amp;S);</span><br><span class="line">p = T;</span><br><span class="line">k = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">Push_Sq(&amp;S, p);</span><br><span class="line">k++;</span><br><span class="line">StackMark[k] = <span class="number">1</span>;</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!p &amp;&amp; !StackEmpty_Sq(S))<span class="comment">//p为空但栈不为空 </span></span><br><span class="line">&#123;</span><br><span class="line">GetTop_Sq(S, &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(StackMark[k]==<span class="number">1</span>)<span class="comment">//已访问过一次，当前是第二次访问 </span></span><br><span class="line">&#123;</span><br><span class="line">StackMark[k] = <span class="number">2</span>;</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//已访问过两次，当前是第三次访问 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;data);</span><br><span class="line">Pop_Sq(&amp;S, &amp;e);</span><br><span class="line">StackMark[k] = <span class="number">0</span>;</span><br><span class="line">k--;</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(StackEmpty_Sq(S))</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="后序遍历二叉树_2非递归"> 后序遍历二叉树_2（非递归）</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PostOrderTraverse_2</span><span class="params">(BiTree T, Status (*visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SqStack S;</span><br><span class="line">InitStack(S);</span><br><span class="line">BiTree p;</span><br><span class="line"><span class="keyword">int</span> Tag[<span class="number">20</span>];<span class="comment">//标志栈</span></span><br><span class="line"><span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">p = T;</span><br><span class="line"><span class="keyword">while</span> (p || !StackEmpty(S))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (p)  <span class="comment">//向左走到尽头</span></span><br><span class="line">&#123;</span><br><span class="line">Push(S, p);</span><br><span class="line">p = p-&gt;lchild;</span><br><span class="line">Tag[t++] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!StackEmpty(S) &amp;&amp; <span class="number">1</span> == Tag[t<span class="number">-1</span>])  <span class="comment">//结点标志为1表示右子树已经访问过</span></span><br><span class="line">&#123;</span><br><span class="line">Pop(S, p);</span><br><span class="line">t--;</span><br><span class="line"><span class="keyword">if</span> (ERROR == visit(p-&gt;data))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!StackEmpty(S))  <span class="comment">//结点标志为0，则访问右子树，并将结点标志置为1</span></span><br><span class="line">&#123;</span><br><span class="line">Tag[t<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">GetTop(S, p);</span><br><span class="line">p = p-&gt;rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="按二叉树的结构打印树"> 按二叉树的结构打印树</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> row, col;</span><br><span class="line"><span class="keyword">int</span> i, j, m, l, r;</span><br><span class="line">BiTNode a[<span class="number">100</span>][<span class="number">100</span>] = &#123;&#125;;<span class="comment">//用一个足够大的矩阵按原样存储树 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T)</span><br><span class="line">&#123;</span><br><span class="line">row = BiTreeDepth(T);<span class="comment">//总行数</span></span><br><span class="line">col = <span class="built_in">pow</span>(<span class="number">2</span>, row) - <span class="number">1</span>;<span class="comment">//总列数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=row<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=<span class="built_in">pow</span>(<span class="number">2</span>, i<span class="number">-1</span>); j++)</span><br><span class="line">&#123;</span><br><span class="line">m = (<span class="number">2</span>*j<span class="number">-1</span>)*<span class="built_in">pow</span>(<span class="number">2</span>, row-i);<span class="comment">//当前行结点相对位序 </span></span><br><span class="line">l = (<span class="number">4</span>*j<span class="number">-3</span>)*<span class="built_in">pow</span>(<span class="number">2</span>, row-i<span class="number">-1</span>);<span class="comment">//下一行结点相对位序 </span></span><br><span class="line">r = (<span class="number">4</span>*j<span class="number">-1</span>)*<span class="built_in">pow</span>(<span class="number">2</span>, row-i<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>)<span class="comment">//初始化 </span></span><br><span class="line">a[i][m] = *T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[i][m].lchild)<span class="comment">//下一行 </span></span><br><span class="line">a[i+<span class="number">1</span>][l] = *(a[i][m].lchild);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[i][m].rchild)<span class="comment">//下一行 </span></span><br><span class="line">a[i+<span class="number">1</span>][r] = *(a[i][m].rchild);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=row; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=col; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j].data)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, a[i][j].data);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】第五章	数组和广义表</title>
      <link href="/2019/06/06/Array-and-List/"/>
      <url>/2019/06/06/Array-and-List/</url>
      
        <content type="html"><![CDATA[<h1><span id="目录"> 目录</span></h1><p><ul class="markdownIt-TOC"><li><a href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8">数组和广义表</a><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">类型定义</a></li><li><a href="#%E4%B8%89%E5%85%83%E7%BB%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">三元组顺序表(稀疏矩阵)类型定义</a></li><li><a href="#%E5%88%9B%E5%BB%BAn%E4%B8%AA%E7%9F%A9%E9%98%B5">创建n个矩阵</a></li><li><a href="#%E9%94%80%E6%AF%81%E7%9F%A9%E9%98%B5">销毁矩阵</a></li><li><a href="#%E8%BE%93%E5%87%BA%E7%9F%A9%E9%98%B5">输出矩阵</a></li><li><a href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E5%A4%8D%E5%88%B6">矩阵的复制</a></li><li><a href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8A%A0%E6%B3%95q-m-n">矩阵的加法Q = M + N</a></li><li><a href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E5%87%8F%E6%B3%95q-m-n">矩阵的减法Q = M - N</a></li><li><a href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E4%B9%98%E6%B3%95q-m-n">矩阵的乘法Q = M * N</a></li><li><a href="#%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE">矩阵转置</a></li><li><a href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E8%BD%AC%E7%BD%AE">矩阵快速转置</a></li></ul></li></ul></p><h2><span id="数组和广义表"> 数组和广义表</span></h2><h3><span id="类型定义"> 类型定义</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 400<span class="comment">//假设非零元个数的最大值为400</span></span></span><br></pre></td></tr></table></figure><h3><span id="三元组顺序表稀疏矩阵类型定义"> 三元组顺序表(稀疏矩阵)类型定义</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> MElemType_TSq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> i, j;<span class="comment">//该非零元的行下标和列下标 </span></span><br><span class="line">MElemType_TSq e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Triple data[MAXSIZE+<span class="number">1</span>];<span class="comment">//非零元三元组表，data[0]未用</span></span><br><span class="line"><span class="keyword">int</span> mu, nu, tu;<span class="comment">//矩阵的行数、列数和非零元个数</span></span><br><span class="line">&#125;TSMatrix;</span><br></pre></td></tr></table></figure><h3><span id="创建n个矩阵"> 创建n个矩阵</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateSMatrix_T</span><span class="params">(FILE *fp, <span class="keyword">int</span> n, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count, k;</span><br><span class="line">TSMatrix *M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">va_list ap;</span><br><span class="line">va_start(ap, n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(count=<span class="number">1</span>; count&lt;=n; count++)</span><br><span class="line">&#123;</span><br><span class="line">M = va_arg(ap, TSMatrix*);</span><br><span class="line"></span><br><span class="line">Scanf(fp, <span class="string">"%d%d%d"</span>, &amp;((*M).mu), &amp;((*M).nu), &amp;((*M).tu));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;=(*M).tu; k++)</span><br><span class="line">Scanf(fp, <span class="string">"%d%d%d"</span>, &amp;((*M).data[k].i), &amp;((*M).data[k].j), &amp;((*M).data[k].e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">va_end(ap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="销毁矩阵"> 销毁矩阵</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroySMatrix_T</span><span class="params">(TSMatrix *M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*M).mu = <span class="number">0</span>;</span><br><span class="line">(*M).nu = <span class="number">0</span>;</span><br><span class="line">(*M).tu = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="输出矩阵"> 输出矩阵</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSMatrix_T</span><span class="params">(TSMatrix M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(r=<span class="number">1</span>; r&lt;=M.mu; r++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(c=<span class="number">1</span>; c&lt;=M.nu; c++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(r==M.data[k].i &amp;&amp; c==M.data[k].j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%3d "</span>, M.data[k].e);</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"  0 "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="矩阵的复制"> 矩阵的复制</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopySMatrix_T</span><span class="params">(TSMatrix M, TSMatrix *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*T) = M;<span class="comment">//结构可以直接复制 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="矩阵的加法q-m-n"> 矩阵的加法Q = M + N</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">AddSMatri_T</span><span class="params">(TSMatrix M, TSMatrix N, TSMatrix *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, n, k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(M.mu!=N.mu || M.nu!=N.nu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"两矩阵不能相加！！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Q-&gt;mu = M.mu;</span><br><span class="line">Q-&gt;nu = M.nu;</span><br><span class="line">Q-&gt;tu = <span class="number">0</span>;</span><br><span class="line">m = n = k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m&lt;=M.tu &amp;&amp; n&lt;=N.tu)<span class="comment">//依次遍历M与N的三元组 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(M.data[m].i&lt;N.data[n].i)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k] = M.data[m];</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(M.data[m].i&gt;N.data[n].i)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k] = N.data[n];</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//M.data[m].i==N.data[n].i</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(M.data[m].j&lt;N.data[n].j)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k] = M.data[m];</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(M.data[m].j&gt;N.data[n].j)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k] = N.data[n];</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//M.data[m].j==N.data[n].j</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(M.data[m].e+N.data[n].e)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k].i = M.data[m].i;</span><br><span class="line">Q-&gt;data[k].j = M.data[m].j;</span><br><span class="line">Q-&gt;data[k].e = M.data[m].e + N.data[n].e;</span><br><span class="line">m++;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m++;</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k++;</span><br><span class="line">Q-&gt;tu++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m&lt;=M.tu)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k] = M.data[m];</span><br><span class="line">m++;</span><br><span class="line">k++;</span><br><span class="line">Q-&gt;tu++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(n&lt;=N.tu)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k] = N.data[n];</span><br><span class="line">n++;</span><br><span class="line">k++;</span><br><span class="line">Q-&gt;tu++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="矩阵的减法q-m-n"> 矩阵的减法Q = M - N</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SubSMatrix_T</span><span class="params">(TSMatrix M, TSMatrix N, TSMatrix *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, n, k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(M.mu!=N.mu || M.nu!=N.nu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"两矩阵不能相减！！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Q-&gt;mu = M.mu;</span><br><span class="line">Q-&gt;nu = M.nu;</span><br><span class="line">Q-&gt;tu = <span class="number">0</span>;</span><br><span class="line">m = n = k = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m&lt;=M.tu &amp;&amp; n&lt;=N.tu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(M.data[m].i&lt;N.data[n].i)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k] = M.data[m];</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(M.data[m].i&gt;N.data[n].i)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k].i =  N.data[n].i;</span><br><span class="line">Q-&gt;data[k].j =  N.data[n].j;</span><br><span class="line">Q-&gt;data[k].e = -N.data[n].e;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//M.data[m].i==N.data[n].i</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(M.data[m].j&lt;N.data[n].j)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k] = M.data[m];</span><br><span class="line">m++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(M.data[m].j&gt;N.data[n].j)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k].i =  N.data[n].i;</span><br><span class="line">Q-&gt;data[k].j =  N.data[n].j;</span><br><span class="line">Q-&gt;data[k].e = -N.data[n].e;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//M.data[m].j==N.data[n].j</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(M.data[m].e-N.data[n].e)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k].i = M.data[m].i;</span><br><span class="line">Q-&gt;data[k].j = M.data[m].j;</span><br><span class="line">Q-&gt;data[k].e = M.data[m].e - N.data[n].e;</span><br><span class="line">m++;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m++;</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k++;</span><br><span class="line">Q-&gt;tu++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m&lt;=M.tu)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k] = M.data[m];</span><br><span class="line">m++;</span><br><span class="line">k++;</span><br><span class="line">Q-&gt;tu++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(n&lt;=N.tu)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;data[k].i =  N.data[n].i;</span><br><span class="line">Q-&gt;data[k].j =  N.data[n].j;</span><br><span class="line">Q-&gt;data[k].e = -N.data[n].e;;</span><br><span class="line">n++;</span><br><span class="line">k++;</span><br><span class="line">Q-&gt;tu++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="矩阵的乘法q-m-n"> 矩阵的乘法Q = M * N</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">MultSMatrix_T</span><span class="params">(TSMatrix M, TSMatrix N, TSMatrix *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, n, i, j, k;</span><br><span class="line">MElemType_TSq c, c1, c2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(M.nu!=N.mu)<span class="comment">//M列数等于N行数 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"两矩阵不能相乘！！\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Q-&gt;mu = M.mu;<span class="comment">//Q初始化 </span></span><br><span class="line">Q-&gt;nu = N.nu;</span><br><span class="line">Q-&gt;tu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(M.tu*N.tu)<span class="comment">//Q是非零矩阵</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=M.mu; i++)<span class="comment">//传统矩阵乘法 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=N.nu; j++)</span><br><span class="line">&#123;</span><br><span class="line">c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;=M.nu; k++)</span><br><span class="line">&#123;</span><br><span class="line">c1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;=M.tu; m++)<span class="comment">//依次寻找位于指定位置的M三元组 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(M.data[m].i==i &amp;&amp; M.data[m].j==k)</span><br><span class="line">&#123;</span><br><span class="line">c1 = M.data[m].e;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(n=<span class="number">1</span>; n&lt;=N.tu; n++)<span class="comment">//依次寻找位于指定位置的N三元组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(N.data[n].i==k &amp;&amp; N.data[n].j==j)</span><br><span class="line">&#123;</span><br><span class="line">c2 = N.data[n].e;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(c1 &amp;&amp; c2)</span><br><span class="line">c += c1 * c2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(c)</span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;tu++;</span><br><span class="line">Q-&gt;data[Q-&gt;tu].i = i;</span><br><span class="line">Q-&gt;data[Q-&gt;tu].j = j;</span><br><span class="line">Q-&gt;data[Q-&gt;tu].e = c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="矩阵转置"> 矩阵转置</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TransposeSMatrix_T</span><span class="params">(TSMatrix M, TSMatrix *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> p, q, col;</span><br><span class="line"></span><br><span class="line">T-&gt;mu = M.nu;</span><br><span class="line">T-&gt;nu = M.mu;</span><br><span class="line">T-&gt;tu = M.tu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T-&gt;tu)</span><br><span class="line">&#123;</span><br><span class="line">q = <span class="number">1</span>;<span class="comment">//q用于T中非零元计数 </span></span><br><span class="line"><span class="keyword">for</span>(col=<span class="number">1</span>; col&lt;=M.nu; ++col)<span class="comment">//col代表M的列，T的行 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">1</span>; p&lt;=M.tu; ++p)<span class="comment">//p用于M中非零元计数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(M.data[p].j==col)</span><br><span class="line">&#123;</span><br><span class="line">T-&gt;data[q].i = M.data[p].j;<span class="comment">//M的列变为T的行 </span></span><br><span class="line">T-&gt;data[q].j = M.data[p].i;<span class="comment">//M的行变为T的列</span></span><br><span class="line">T-&gt;data[q].e = M.data[p].e;<span class="comment">//每个三元组值不变</span></span><br><span class="line">++q; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="矩阵快速转置"> 矩阵快速转置</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FastTransposeSMatrix_T</span><span class="params">(TSMatrix M, TSMatrix *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> col, t, p, q;</span><br><span class="line"><span class="keyword">int</span> num[M.nu];<span class="comment">//num[col]表示M第col列中非零元的个数 </span></span><br><span class="line"><span class="keyword">int</span> copt[M.nu];<span class="comment">//copt[col]表示M第col列第一个非零元在T-&gt;data中恰当的位置 </span></span><br><span class="line"></span><br><span class="line">T-&gt;mu = M.nu;</span><br><span class="line">T-&gt;nu = M.mu;</span><br><span class="line">T-&gt;tu = M.tu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(T-&gt;tu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(col=<span class="number">1</span>; col&lt;=M.nu; ++col)</span><br><span class="line">num[col] = <span class="number">0</span>;<span class="comment">//初始化数组num</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(t=<span class="number">1</span>; t&lt;=M.tu; ++t)<span class="comment">//t遍历M中三元组</span></span><br><span class="line">num[M.data[t].j]++;<span class="comment">//统计M中每列非零元个数</span></span><br><span class="line"></span><br><span class="line">copt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(col=<span class="number">2</span>; col&lt;=M.nu; ++col)</span><br><span class="line">copt[col] = copt[col<span class="number">-1</span>] + num[col<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">1</span>; p&lt;=M.tu; ++p)<span class="comment">//依次扫描M中的三元组 </span></span><br><span class="line">&#123;</span><br><span class="line">col = M.data[p].j;<span class="comment">//col为M中第p个三元组中元素的列 </span></span><br><span class="line">q = copt[col];<span class="comment">//q为当前三元组元素在T中应放置的位置 </span></span><br><span class="line">T-&gt;data[q].i = M.data[p].j;</span><br><span class="line">T-&gt;data[q].j = M.data[p].i;</span><br><span class="line">T-&gt;data[q].e = M.data[p].e;</span><br><span class="line">++copt[col];<span class="comment">//再遇到此列元素时位置增一 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数组和广义表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】第四章	串</title>
      <link href="/2019/06/06/String/"/>
      <url>/2019/06/06/String/</url>
      
        <content type="html"><![CDATA[<h1><span id="目录"> 目录</span></h1><p><ul class="markdownIt-TOC"><li><a href="#%E4%B8%B2">串</a><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">类型定义</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96s%E4%B8%BA%E7%A9%BA%E4%B8%B2">初始化S为空串</a></li><li><a href="#%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%85%B6%E5%80%BC%E7%AD%89%E4%BA%8E%E5%B8%B8%E9%87%8Fchars%E7%9A%84%E4%B8%B2t">生成一个其值等于常量chars的串T</a></li><li><a href="#%E7%94%B1%E4%B8%B2s%E5%A4%8D%E5%88%B6%E5%BE%97%E5%88%B0%E4%B8%B2t">由串S复制得到串T</a></li><li><a href="#%E8%8B%A5s%E4%B8%BA%E7%A9%BA%E4%B8%B2%E8%BF%94%E5%9B%9Etrue%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9Efalse">若S为空串，返回TRUE,否则返回FALSE</a></li><li><a href="#%E8%8B%A5st%E8%BF%94%E5%9B%9E%E5%80%BC0%E8%8B%A5st%E8%BF%94%E5%9B%9E%E5%80%BC0%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E%E5%80%BC0">若S&gt;T，返回值&gt;0；若S&lt;T，返回值&lt;0；否则，返回值=0</a></li><li><a href="#%E6%B1%82%E4%B8%B2%E9%95%BF">求串长</a></li><li><a href="#%E6%B8%85%E7%A9%BA%E4%B8%B2s">清空串S</a></li><li><a href="#%E7%94%A8t%E8%BF%94%E5%9B%9E%E7%94%B1s1%E5%92%8Cs2%E8%81%94%E6%8E%A5%E8%80%8C%E6%88%90%E7%9A%84%E6%96%B0%E4%B8%B2">用T返回由S1和S2联接而成的新串</a></li><li><a href="#%E7%94%A8sub%E8%BF%94%E5%9B%9E%E4%B8%B2s%E7%9A%84%E7%AC%ACpos%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%B5%B7%E9%95%BF%E5%BA%A6%E4%B8%BAlen%E7%9A%84%E5%AD%90%E4%B8%B2">用Sub返回串S的第pos个字符起长度为len的子串</a></li><li><a href="#%E8%BF%94%E5%9B%9Et%E5%9C%A8s%E4%B8%AD%E7%AC%ACpos%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%90%8E%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%88%99%E8%BF%94%E5%9B%9E0">返回T在S中第pos个字符后第一次出现的位置，不存在则返回0</a></li><li><a href="#%E7%94%A8v%E6%9B%BF%E6%8D%A2%E4%B8%BB%E4%B8%B2s%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%89%80%E6%9C%89%E4%B8%8Et%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E5%AD%90%E4%B8%B2">用V替换主串S中出现的所有与T相等的不重叠的子串</a></li><li><a href="#%E5%9C%A8%E4%B8%B2s%E7%9A%84%E7%AC%ACpos%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E4%B8%B2t">在串S的第pos个字符之前插入串T</a></li><li><a href="#%E4%BB%8E%E4%B8%B2s%E4%B8%AD%E5%88%A0%E9%99%A4%E7%AC%ACpos%E4%B8%AA%E5%AD%97%E7%AC%A6%E8%B5%B7%E9%95%BF%E5%BA%A6%E4%B8%BAlen%E7%9A%84%E5%AD%90%E4%B8%B2">从串S中删除第pos个字符起长度为len的子串</a></li><li><a href="#%E9%94%80%E6%AF%81%E4%B8%B2s">销毁串S</a></li><li><a href="#%E8%BE%93%E5%87%BA%E4%B8%B2s">输出串S</a></li></ul></li></ul></p><h2><span id="串"> 串</span></h2><h3><span id="类型定义"> 类型定义</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串的堆存储表示 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> *ch;<span class="comment">//若是非空串，则按串长分配存储区，否则ch为NULL </span></span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure><h3><span id="初始化s为空串"> 初始化S为空串</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitString_H</span><span class="params">(HString *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*S).ch = <span class="literal">NULL</span>;</span><br><span class="line">(*S).length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="生成一个其值等于常量chars的串t"> 生成一个其值等于常量chars的串T</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrAssign_H</span><span class="params">(HString *T, <span class="keyword">char</span> *chars)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">InitString_H(T);</span><br><span class="line"></span><br><span class="line">i = <span class="built_in">strlen</span>(chars);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!i)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">(*T).ch = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(i*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">if</span>(!((*T).ch))</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">(*T).ch[j] = chars[j];</span><br><span class="line"></span><br><span class="line">(*T).length = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="由串s复制得到串t"> 由串S复制得到串T</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrCopy_H</span><span class="params">(HString *T, HString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">InitString_H(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(StrEmpty_H(S))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">(*T).ch = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(S.length*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">if</span>(!(*T).ch)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;S.length; i++)</span><br><span class="line">(*T).ch[i] = S.ch[i];</span><br><span class="line"></span><br><span class="line">(*T).length = S.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="若s为空串返回true否则返回false"> 若S为空串，返回TRUE,否则返回FALSE</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrEmpty_H</span><span class="params">(HString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.length==<span class="number">0</span> &amp;&amp; S.ch==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="若sgtt返回值gt0若sltt返回值lt0否则返回值0"> 若S&gt;T，返回值&gt;0；若S&lt;T，返回值&lt;0；否则，返回值=0</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrCompare_H</span><span class="params">(HString S, HString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;S.length&amp;&amp;i&lt;T.length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(S.ch[i]!=T.ch[i])</span><br><span class="line"><span class="keyword">return</span> S.ch[i]-T.ch[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> S.length-T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="求串长"> 求串长</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength_H</span><span class="params">(HString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(StrEmpty_H(S))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> S.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="清空串s"> 清空串S</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearString_H</span><span class="params">(HString *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((*S).ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>((*S).ch);</span><br><span class="line">(*S).ch = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(*S).length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="用t返回由s1和s2联接而成的新串"> 用T返回由S1和S2联接而成的新串</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Concat_H</span><span class="params">(HString *T, HString S1, HString S2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">InitString_H(T);</span><br><span class="line"></span><br><span class="line">(*T).length = S1.length + S2.length;</span><br><span class="line"></span><br><span class="line">(*T).ch = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>((*T).length*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">if</span>(!(*T).ch)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;S1.length; i++)</span><br><span class="line">(*T).ch[i] = S1.ch[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;S2.length; i++)</span><br><span class="line">(*T).ch[S1.length+i] = S2.ch[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="用sub返回串s的第pos个字符起长度为len的子串"> 用Sub返回串S的第pos个字符起长度为len的子串</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SubString_H</span><span class="params">(HString *Sub, HString S, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">InitString_H(Sub);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(StrEmpty_H(S))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">1</span> || pos&gt;S.length || len&lt;<span class="number">0</span> || pos+len<span class="number">-1</span>&gt;S.length)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len)<span class="comment">//非空子串</span></span><br><span class="line">&#123;</span><br><span class="line">(*Sub).ch = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">if</span>(!(*Sub).ch)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">(*Sub).ch[i] = S.ch[i+pos<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">(*Sub).length = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="返回t在s中第pos个字符后第一次出现的位置不存在则返回0"> 返回T在S中第pos个字符后第一次出现的位置，不存在则返回0</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_H</span><span class="params">(HString S, HString T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s, t, i;</span><br><span class="line">HString Sub;</span><br><span class="line"></span><br><span class="line">InitString_H(&amp;Sub);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pos&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">s = S.length;</span><br><span class="line">t = T.length;</span><br><span class="line">i = pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i+t<span class="number">-1</span>&lt;=s)</span><br><span class="line">&#123;</span><br><span class="line">SubString_H(&amp;Sub, S, i, t);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(StrCompare_H(Sub, T))</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="用v替换主串s中出现的所有与t相等的不重叠的子串"> 用V替换主串S中出现的所有与T相等的不重叠的子串</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Replace_H</span><span class="params">(HString *S, HString T, HString V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(StrEmpty_H(T))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">i = Index_H(*S, T, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">StrDelete_H(S, i, StrLength_H(T));</span><br><span class="line"></span><br><span class="line">StrInsert_H(S, i, V);</span><br><span class="line"></span><br><span class="line">i += StrLength_H(V);</span><br><span class="line"></span><br><span class="line">i = Index_H(*S, T, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="在串s的第pos个字符之前插入串t"> 在串S的第pos个字符之前插入串T</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrInsert_H</span><span class="params">(HString *S, <span class="keyword">int</span> pos, HString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">1</span> || pos&gt;(*S).length+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(StrEmpty_H(T))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">(*S).ch = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>((*S).ch, ((*S).length+T.length)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">if</span>(!(*S).ch)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=(*S).length<span class="number">-1</span>; i&gt;=pos<span class="number">-1</span>; i--)<span class="comment">//为插入T而腾出位置</span></span><br><span class="line">(*S).ch[i+T.length] = (*S).ch[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;T.length; i++)</span><br><span class="line">(*S).ch[pos<span class="number">-1</span>+i] = T.ch[i]; <span class="comment">//插入T</span></span><br><span class="line"></span><br><span class="line">(*S).length += T.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="从串s中删除第pos个字符起长度为len的子串"> 从串S中删除第pos个字符起长度为len的子串</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrDelete_H</span><span class="params">(HString *S, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(StrEmpty_H(*S))</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pos&lt;<span class="number">1</span> || pos+len<span class="number">-1</span>&gt;(*S).length ||len&lt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=pos<span class="number">-1</span>; i+len&lt;=(*S).length; i++)</span><br><span class="line">(*S).ch[i] = (*S).ch[i+len];</span><br><span class="line"></span><br><span class="line">(*S).length -= len;</span><br><span class="line"></span><br><span class="line">(*S).ch = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>((*S).ch, (*S).length*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//缩小分配的空间 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="销毁串s"> 销毁串S</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyString_H</span><span class="params">(HString *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//堆串不能被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="输出串s"> 输出串S</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrPrint_H</span><span class="params">(HString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(StrEmpty_H(S))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"S为空串，不可输出！"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;S.length; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, S.ch[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】第三章	队列</title>
      <link href="/2019/06/06/Queue/"/>
      <url>/2019/06/06/Queue/</url>
      
        <content type="html"><![CDATA[<h1><span id="目录"> 目录</span></h1><p><ul class="markdownIt-TOC"><li><a href="#%E9%9D%9E%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">非循环队列</a><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">类型定义</a></li><li><a href="#%E9%9D%9E%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">非循环队列的初始化</a></li><li><a href="#%E6%B8%85%E7%A9%BA%E9%98%9F%E5%88%97">清空队列</a></li><li><a href="#%E9%94%80%E6%AF%81%E9%98%9F%E5%88%97">销毁队列</a></li><li><a href="#%E5%88%A4%E6%96%AD%E9%98%9F%E5%88%97%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA">判断队列是否为空</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6">计算队列的长度</a></li><li><a href="#%E5%BE%97%E5%88%B0%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0">得到队头元素</a></li><li><a href="#%E5%85%A5%E9%98%9F">入队</a></li><li><a href="#%E5%87%BA%E9%98%9F">出队</a></li><li><a href="#%E9%81%8D%E5%8E%86%E9%9D%9E%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">遍历非循环队列</a></li></ul></li><li><a href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E4%B8%8D%E8%AE%BE%E5%A4%B4%E6%8C%87%E9%92%88">循环队列（不设头指针）</a><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89-2">类型定义</a></li><li><a href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E5%88%9D%E5%A7%8B%E5%8C%96">循环队列初始化</a></li><li><a href="#%E5%85%A5%E9%98%9F-2">入队</a></li><li><a href="#%E5%87%BA%E9%98%9F-2">出队</a></li><li><a href="#%E9%81%8D%E5%8E%86%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">遍历循环队列</a></li></ul></li><li><a href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E8%AE%BE%E5%A4%B4%E6%8C%87%E9%92%88">循环队列（设头指针）</a><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89-3">类型定义</a></li><li><a href="#%E9%98%9F%E5%88%97%E5%88%9D%E5%A7%8B%E5%8C%96">队列初始化</a></li><li><a href="#%E5%85%A5%E9%98%9F-3">入队</a></li><li><a href="#%E5%87%BA%E9%98%9F-3">出队</a></li><li><a href="#%E9%81%8D%E5%8E%86%E9%98%9F%E5%88%97">遍历队列</a></li></ul></li></ul></p><h2><span id="非循环队列"> 非循环队列</span></h2><h3><span id="类型定义"> 类型定义</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType_L;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType_L data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,* QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueuePtr front;<span class="comment">//头指针 </span></span><br><span class="line">QueuePtr rear;<span class="comment">//尾指针 </span></span><br><span class="line">&#125;LinkQueue;<span class="comment">//队列的链式存储表示</span></span><br></pre></td></tr></table></figure><h3><span id="非循环队列的初始化"> 非循环队列的初始化</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue_L</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!Q.front)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue_L</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*Q).front = (*Q).rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!(*Q).front)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">(*Q).front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="清空队列"> 清空队列</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearQueue_L</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q.rear = Q.front-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(Q.rear)</span><br><span class="line">&#123;</span><br><span class="line">Q.front-&gt;next = Q.rear-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(Q.rear);</span><br><span class="line">Q.rear = Q.front-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Q.rear = Q.front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearQueue_L</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*Q).rear = (*Q).front-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((*Q).rear)</span><br><span class="line">&#123;</span><br><span class="line">(*Q).front-&gt;next = (*Q).rear-&gt;next;</span><br><span class="line"><span class="built_in">free</span>((*Q).rear);</span><br><span class="line">(*Q).rear = (*Q).front-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(*Q).rear = (*Q).front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="销毁队列"> 销毁队列</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue_L</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(Q.front)</span><br><span class="line">&#123;</span><br><span class="line">Q.rear = Q.front-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(Q.front);</span><br><span class="line">Q.front = Q.rear;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue_L</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>((*Q).front)</span><br><span class="line">&#123;</span><br><span class="line">(*Q).rear = (*Q).front-&gt;next;</span><br><span class="line"><span class="built_in">free</span>((*Q).front);</span><br><span class="line">(*Q).front = (*Q).rear;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="判断队列是否为空"> 判断队列是否为空</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">QueueEmpty_L</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="计算队列的长度"> 计算队列的长度</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength_L</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">QueuePtr p = Q.front;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p!=Q.rear)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="得到队头元素"> 得到队头元素</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetHead_L</span><span class="params">(LinkQueue Q, QElemType_L &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">p = Q.front-&gt;next;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetHead_L</span><span class="params">(LinkQueue Q, QElemType_L *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">p = Q.front-&gt;next;</span><br><span class="line">*e = p-&gt;data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="入队"> 入队</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue_L</span><span class="params">(LinkQueue &amp;Q, QElemType_L e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"></span><br><span class="line">p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">p-&gt;data = e;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">Q.rear-&gt;next = p;</span><br><span class="line">Q.rear=p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue_L</span><span class="params">(LinkQueue *Q, QElemType_L e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"></span><br><span class="line">p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">p-&gt;data = e;</span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">(*Q).rear-&gt;next = p;</span><br><span class="line">(*Q).rear=p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="出队"> 出队</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue_L</span><span class="params">(LinkQueue &amp;Q, QElemType_L &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">p = Q.front-&gt;next;</span><br><span class="line">e = p-&gt;data;</span><br><span class="line"></span><br><span class="line">Q.front-&gt;next = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">Q.rear = Q.front;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue_L</span><span class="params">(LinkQueue *Q, QElemType_L *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((*Q).front==(*Q).rear)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">p = (*Q).front-&gt;next;</span><br><span class="line">*e = p-&gt;data;</span><br><span class="line"></span><br><span class="line">(*Q).front-&gt;next = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>((*Q).rear==p)</span><br><span class="line">(*Q).rear = (*Q).front;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="遍历非循环队列"> 遍历非循环队列</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueTraverse_L</span><span class="params">(LinkQueue Q, <span class="keyword">void</span> (Visit)(QElemType_L))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"></span><br><span class="line">p = Q.front-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p)</span><br><span class="line">&#123;</span><br><span class="line">Visit(p-&gt;data);</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="循环队列不设头指针"> 循环队列（不设头指针）</span></h2><blockquote><p><strong>假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针）</strong></p></blockquote><h3><span id="类型定义"> 类型定义</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType_L;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType_L data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,* QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QueuePtr rear;<span class="comment">//尾指针 </span></span><br><span class="line">&#125;LinkQueue;<span class="comment">//队列的链式存储表示</span></span><br></pre></td></tr></table></figure><h3><span id="循环队列初始化"> 循环队列初始化</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue_L</span><span class="params">(LinkQueue *Q)</span><span class="comment">//队列初始化 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*Q).rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!(*Q).rear)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">(*Q).rear-&gt;next = (*Q).rear;<span class="comment">//初次创建的(*Q).rear为头结点，且next指向</span></span><br><span class="line"><span class="comment">//自身，达到循环效果。 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="入队"> 入队</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue_L</span><span class="params">(LinkQueue *Q, QElemType e)</span><span class="comment">//入队 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"></span><br><span class="line">p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">p-&gt;data = e;</span><br><span class="line"></span><br><span class="line">p-&gt;next = (*Q).rear-&gt;next;<span class="comment">//入队后新结点的next始终指向头结点，构成循环队列 </span></span><br><span class="line">(*Q).rear-&gt;next = p;<span class="comment">//每次都在队尾入队 </span></span><br><span class="line">(*Q).rear = p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="出队"> 出队</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue_L</span><span class="params">(LinkQueue *Q, QElemType *e)</span><span class="comment">//出队 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr h, p;</span><br><span class="line"></span><br><span class="line">h = (*Q).rear-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(h-&gt;next==(*Q).rear-&gt;next)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">p = h-&gt;next;</span><br><span class="line">*e = p-&gt;data;</span><br><span class="line"></span><br><span class="line">h-&gt;next = p-&gt;next;<span class="comment">//当队列只有一个元素时，头结点的next指向自身 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p==(*Q).rear)<span class="comment">//队列只有一个元素 </span></span><br><span class="line">(*Q).rear = h;<span class="comment">//rear指向头结点 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="遍历循环队列"> 遍历循环队列</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output_L</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">QueuePtr p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(p=Q.rear-&gt;next-&gt;next; p!=Q.rear-&gt;next; p=p-&gt;next)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="循环队列设头指针"> 循环队列（设头指针）</span></h2><blockquote><p><strong>设置一个标志域tag，并以tag的值为0和1来区分，尾指针和头指针值相同时的队列状态是“空”还是“满”。</strong></p></blockquote><h3><span id="类型定义"> 类型定义</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">QElemType *base;</span><br><span class="line"><span class="keyword">int</span> front;</span><br><span class="line"><span class="keyword">int</span> rear;</span><br><span class="line"><span class="keyword">int</span> tag;<span class="comment">//0表示空，1表示满 </span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><h3><span id="队列初始化"> 队列初始化</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue_L</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*Q).base = (QElemType *)<span class="built_in">malloc</span>(MAXQSIZE*<span class="keyword">sizeof</span>(QElemType));</span><br><span class="line"><span class="keyword">if</span>(!((*Q).base))</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">(*Q).front = (*Q).rear = <span class="number">0</span>;</span><br><span class="line">(*Q).tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="入队"> 入队</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue_L</span><span class="params">(SqQueue *Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((*Q).rear==(*Q).front &amp;&amp; (*Q).tag==<span class="number">1</span>)<span class="comment">//队列满</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">(*Q).base[(*Q).rear] = e;</span><br><span class="line">(*Q).rear = ((*Q).rear+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((*Q).rear==(*Q).front)<span class="comment">//入队后队满 </span></span><br><span class="line">(*Q).tag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="出队"> 出队</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue_L</span><span class="params">(SqQueue *Q, QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((*Q).front==(*Q).rear &amp;&amp; (*Q).tag==<span class="number">0</span>)<span class="comment">//队列空</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">*e = (*Q).base[(*Q).front];</span><br><span class="line">(*Q).front = ((*Q).front+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((*Q).rear==(*Q).front)<span class="comment">//出队后队空 </span></span><br><span class="line">(*Q).tag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="遍历队列"> 遍历队列</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output_L</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=Q.front; i!=Q.rear; i=(i+<span class="number">1</span>)%MAXQSIZE)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, Q.base[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】第三章	栈</title>
      <link href="/2019/06/06/Stack/"/>
      <url>/2019/06/06/Stack/</url>
      
        <content type="html"><![CDATA[<h1><span id="目录"> 目录</span></h1><p><ul class="markdownIt-TOC"><li><a href="#%E9%A1%BA%E5%BA%8F%E6%A0%88">顺序栈</a><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">类型定义</a></li><li><a href="#%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">栈的初始化</a></li><li><a href="#%E9%94%80%E6%AF%81%E6%A0%88">销毁栈</a></li><li><a href="#%E6%B8%85%E7%A9%BA%E6%A0%88">清空栈</a></li><li><a href="#%E5%88%A4%E6%96%AD%E6%A0%88%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA">判断栈是否为空</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%A0%88%E7%9A%84%E9%95%BF%E5%BA%A6">计算栈的长度</a></li><li><a href="#%E5%BE%97%E5%88%B0%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0">得到栈顶元素</a></li><li><a href="#%E5%85%A5%E6%A0%88">入栈</a></li><li><a href="#%E5%87%BA%E6%A0%88">出栈</a></li><li><a href="#%E9%81%8D%E5%8E%86%E6%A0%88%E4%B8%AD%E5%85%83%E7%B4%A0">遍历栈中元素</a></li></ul></li></ul></p><h2><span id="顺序栈"> 顺序栈</span></h2><h3><span id="类型定义"> 类型定义</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE100<span class="comment">//顺序栈存储空间的初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT10 <span class="comment">//顺序栈存储空间的分配增量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType_Sq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">SElemType_Sq *base;<span class="comment">//在栈构造之前和销毁之后，base的值为NULL </span></span><br><span class="line">SElemType_Sq *top;<span class="comment">//栈顶指针 </span></span><br><span class="line"><span class="keyword">int</span> stacksize;<span class="comment">//当前已分配的存储空间，以元素为单位 </span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><h3><span id="栈的初始化"> 栈的初始化</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack_Sq</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> S.base = (SElemType_Sq *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType_Sq));</span><br><span class="line"><span class="keyword">if</span>(!S.base)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">S.top = S.base;</span><br><span class="line">S.stacksize = STACK_INIT_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitStack_Sq</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> (*S).base = (SElemType_Sq *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType_Sq));</span><br><span class="line"><span class="keyword">if</span>(!(*S).base)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">(*S).top = (*S).base;</span><br><span class="line">(*S).stacksize = STACK_INIT_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="销毁栈"> 销毁栈</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyStack_Sq</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(S.base);</span><br><span class="line"></span><br><span class="line">S.base = <span class="literal">NULL</span>;</span><br><span class="line">S.top = <span class="literal">NULL</span>;</span><br><span class="line">S.stacksize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyStack_Sq</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>((*S).base);</span><br><span class="line"></span><br><span class="line">(*S).base = <span class="literal">NULL</span>;</span><br><span class="line">(*S).top = <span class="literal">NULL</span>;</span><br><span class="line">(*S).stacksize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="清空栈"> 清空栈</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearStack_Sq</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S.top = S.base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ClearStack_Sq</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*S).top = (*S).base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="判断栈是否为空"> 判断栈是否为空</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty_Sq</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==S.base)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="计算栈的长度"> 计算栈的长度</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength_Sq</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> S.top - S.base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="得到栈顶元素"> 得到栈顶元素</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetTop_Sq</span><span class="params">(SqStack S, SElemType_Sq &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==S.base)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">e = *(S.top - <span class="number">1</span>);<span class="comment">//并不破坏栈 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetTop_Sq</span><span class="params">(SqStack S, SElemType_Sq *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==S.base)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">*e = *(S.top - <span class="number">1</span>);<span class="comment">//并不破坏栈 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="入栈"> 入栈</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push_Sq</span><span class="params">(SqStack &amp;S, SElemType_Sq e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)<span class="comment">//栈满，追加存储空间</span></span><br><span class="line">&#123;</span><br><span class="line">S.base = (SElemType_Sq *)<span class="built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType_Sq));</span><br><span class="line"><span class="keyword">if</span>(!S.base)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">S.top = S.base + S.stacksize;</span><br><span class="line">S.stacksize += STACKINCREMENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(S.top) = e;<span class="comment">//进栈先赋值，栈顶指针再自增 </span></span><br><span class="line">(S.top)++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push_Sq</span><span class="params">(SqStack *S, SElemType_Sq e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((*S).top-(*S).base&gt;=(*S).stacksize)<span class="comment">//栈满，追加存储空间</span></span><br><span class="line">&#123;</span><br><span class="line">(*S).base = (SElemType_Sq *)<span class="built_in">realloc</span>((*S).base, ((*S).stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType_Sq));</span><br><span class="line"><span class="keyword">if</span>(!(*S).base)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);<span class="comment">//存储分配失败</span></span><br><span class="line">(*S).top = (*S).base + (*S).stacksize;</span><br><span class="line">(*S).stacksize += STACKINCREMENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(S-&gt;top) = e;<span class="comment">//进栈先赋值，栈顶指针再自增 </span></span><br><span class="line">(S-&gt;top)++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="出栈"> 出栈</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop_Sq</span><span class="params">(SqStack &amp;S, SElemType_Sq &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==S.base)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">S.top--;<span class="comment">//出栈栈顶指针先递减，再赋值 </span></span><br><span class="line">e = *(S.top);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Pop_Sq</span><span class="params">(SqStack *S, SElemType_Sq *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((*S).top==(*S).base)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">(*S).top--;<span class="comment">//出栈栈顶指针先递减，再赋值 </span></span><br><span class="line">*e = *((*S).top);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="遍历栈中元素"> 遍历栈中元素</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackTraverse_Sq</span><span class="params">(SqStack S, <span class="keyword">void</span>(Visit)(SElemType_Sq))</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//遍历不应该破坏栈 </span></span><br><span class="line">SElemType_Sq *p = S.base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p&lt;S.top)</span><br><span class="line">Visit(*p++);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】第二章	线性表</title>
      <link href="/2019/06/06/List/"/>
      <url>/2019/06/06/List/</url>
      
        <content type="html"><![CDATA[<h1><span id="目录"> 目录</span></h1><p><ul class="markdownIt-TOC"><li><a href="#%E9%A1%BA%E5%BA%8F%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%95%B0%E7%BB%84">顺序线性表（数组）</a><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">类型定义</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E7%BA%BF%E6%80%A7%E8%A1%A8">初始化顺序线性表</a></li><li><a href="#%E5%88%A4%E6%96%AD%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA">判断顺序表是否为空</a></li><li><a href="#%E6%B8%85%E7%A9%BA%E9%A1%BA%E5%BA%8F%E8%A1%A8">清空顺序表</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6">计算顺序表的长度</a></li><li><a href="#%E7%94%A8e%E8%BF%94%E5%9B%9El%E4%B8%AD%E7%AC%ACi%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E7%9A%84%E5%80%BC">用e返回L中第i个数据元素的值</a></li><li><a href="#%E8%BF%94%E5%9B%9El%E4%B8%AD%E7%AC%AC1%E4%B8%AA%E4%B8%8Ee%E6%BB%A1%E8%B6%B3%E5%85%B3%E7%B3%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%8D%E5%BA%8F">返回L中第1个与e满足关系的数据元素的位序</a></li><li><a href="#%E5%9C%A8l%E4%B8%AD%E7%AC%ACi%E4%B8%AA%E4%BD%8D%E7%BD%AE%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0e">在L中第i个位置之前插入新的数据元素e</a></li><li><a href="#%E5%88%A0%E9%99%A4l%E7%9A%84%E7%AC%ACi%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E5%B9%B6%E7%94%A8e%E8%BF%94%E5%9B%9E%E5%85%B6%E5%80%BC">删除L的第i个数据元素，并用e返回其值</a></li><li><a href="#%E9%81%8D%E5%8E%86%E9%A1%BA%E5%BA%8F%E7%BA%BF%E6%80%A7%E8%A1%A8">遍历顺序线性表</a></li><li><a href="#%E5%90%88%E5%B9%B6la-lb%E4%B8%A4%E4%B8%AA%E9%A1%BA%E5%BA%8F%E7%BA%BF%E6%80%A7%E8%A1%A8">合并La、Lb两个顺序线性表</a></li></ul></li><li><a href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84">静态链表（数组）</a><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89-2">类型定义</a></li><li><a href="#%E5%B0%86%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84space%E4%B8%AD%E5%90%84%E5%88%86%E9%87%8F%E9%93%BE%E6%88%90%E4%B8%80%E4%B8%AA%E5%A4%87%E7%94%A8%E9%93%BE%E8%A1%A8space0cur%E4%B8%BA%E5%A4%B4%E6%8C%87%E9%92%880%E8%A1%A8%E7%A4%BA%E7%A9%BA%E6%8C%87%E9%92%88">将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针</a></li><li><a href="#%E8%8B%A5%E5%A4%87%E7%94%A8%E7%A9%BA%E9%97%B4%E9%93%BE%E8%A1%A8%E9%9D%9E%E7%A9%BA%E5%88%99%E8%BF%94%E5%9B%9E%E5%88%86%E9%85%8D%E7%9A%84%E7%BB%93%E7%82%B9%E4%B8%8B%E6%A0%87%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E0">若备用空间链表非空，则返回分配的结点下标，否则返回0</a></li><li><a href="#%E5%B0%86%E4%B8%8B%E6%A0%87%E4%B8%BAk%E7%9A%84%E7%A9%BA%E9%97%B2%E7%BB%93%E7%82%B9%E5%9B%9E%E6%94%B6%E5%88%B0%E5%A4%87%E7%94%A8%E9%93%BE%E8%A1%A8">将下标为k的空闲结点回收到备用链表</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6">计算静态链表的长度</a></li><li><a href="#%E5%9C%A8l%E4%B8%AD%E7%AC%ACi%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B9%8B%E5%89%8D%E6%8F%92%E5%85%A5%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0e">在L中第i个元素之前插入新的数据元素e</a></li><li><a href="#%E5%88%A0%E9%99%A4%E5%9C%A8l%E4%B8%AD%E7%AC%ACi%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0">删除在L中第i个数据元素</a></li><li><a href="#%E9%81%8D%E5%8E%86%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8">遍历静态链表</a></li></ul></li><li><a href="#%E9%9D%9E%E5%BE%AA%E7%8E%AF%E5%8D%95%E5%90%91%E7%BA%BF%E6%80%A7%E8%A1%A8">非循环单向线性表</a><ul><li><a href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89-3">类型定义</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E6%80%A7%E8%A1%A8">初始化线性表</a></li><li><a href="#%E6%B8%85%E7%A9%BA%E7%BA%BF%E6%80%A7%E8%A1%A8">清空线性表</a></li><li><a href="#%E9%94%80%E6%AF%81%E7%BA%BF%E6%80%A7%E8%A1%A8">销毁线性表</a></li><li><a href="#%E5%88%A4%E6%96%AD%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA">判断线性表是否为空</a></li><li><a href="#%E8%AE%A1%E7%AE%97%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%95%BF%E5%BA%A6">计算线性表的长度</a></li><li><a href="#%E7%94%A8e%E6%8E%A5%E6%94%B6%E9%A1%BA%E5%BA%8F%E8%A1%A8l%E4%B8%AD%E7%AC%ACi%E4%B8%AA%E5%85%83%E7%B4%A0">用e接收顺序表L中第i个元素</a></li><li><a href="#%E8%BF%94%E5%9B%9E%E9%A1%BA%E5%BA%8F%E8%A1%A8l%E4%B8%AD%E9%A6%96%E4%B8%AA%E4%B8%8Ee%E6%BB%A1%E8%B6%B3compare%E5%85%B3%E7%B3%BB%E7%9A%84%E5%85%83%E7%B4%A0%E4%BD%8D%E5%BA%8F">返回顺序表L中首个与e满足Compare关系的元素位序</a></li><li><a href="#%E7%94%A8pre_e%E6%8E%A5%E6%94%B6cur_e%E7%9A%84%E5%89%8D%E9%A9%B1">用pre_e接收cur_e的前驱</a></li><li><a href="#%E7%94%A8next_e%E6%8E%A5%E6%94%B6cur_e%E7%9A%84%E5%90%8E%E7%BB%A7">用next_e接收cur_e的后继</a></li><li><a href="#%E5%9C%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8l%E7%9A%84%E7%AC%ACi%E4%B8%AA%E4%BD%8D%E7%BD%AE%E4%B8%8A%E6%8F%92%E5%85%A5e">在顺序表L的第i个位置上插入e</a></li><li><a href="#%E5%88%A0%E9%99%A4%E9%A1%BA%E5%BA%8F%E8%A1%A8l%E4%B8%8A%E7%AC%ACi%E4%B8%AA%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%85%83%E7%B4%A0%E5%B9%B6%E7%94%A8e%E8%BF%94%E5%9B%9E">删除顺序表L上第i个位置的元素，并用e返回</a></li><li><a href="#%E7%94%A8visit%E5%87%BD%E6%95%B0%E8%AE%BF%E9%97%AE%E9%A1%BA%E5%BA%8F%E8%A1%A8l">用visit函数访问顺序表L</a></li></ul></li></ul></p><h2><span id="顺序线性表数组"> 顺序线性表（数组）</span></h2><h3><span id="类型定义"> 类型定义</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElemType data[MAXSIZE];        <span class="comment">/* 数组，存储数据元素 */</span></span><br><span class="line"><span class="keyword">int</span> length;                                <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h3><span id="初始化顺序线性表"> 初始化顺序线性表</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList *L)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="判断顺序表是否为空"> 判断顺序表是否为空</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListEmpty</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="清空顺序表"> 清空顺序表</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="计算顺序表的长度"> 计算顺序表的长度</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="用e返回l中第i个数据元素的值"> 用e返回L中第i个数据元素的值</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L.data[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="返回l中第1个与e满足关系的数据元素的位序"> 返回L中第1个与e满足关系的数据元素的位序</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (L.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">if</span> (L.data[i]==e)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=L.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="在l中第i个位置之前插入新的数据元素e"> 在L中第i个位置之前插入新的数据元素e</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;length==MAXSIZE)  <span class="comment">/* 顺序线性表已经满 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)<span class="comment">/* 当i比第一位置小或者比最后一位置后一位置还要大时 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i&lt;=L-&gt;length)        <span class="comment">/* 若插入数据位置不在表尾 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)  <span class="comment">/* 将要插入位置之后的数据元素向后移动一位 */</span></span><br><span class="line">L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;data[i<span class="number">-1</span>]=e;          <span class="comment">/* 将新元素插入 */</span></span><br><span class="line">L-&gt;length++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="删除l的第i个数据元素并用e返回其值"> 删除L的第i个数据元素，并用e返回其值</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType *e)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length==<span class="number">0</span>)               <span class="comment">/* 线性表为空 */</span></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length)         <span class="comment">/* 删除位置不正确 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> (i&lt;L-&gt;length)                <span class="comment">/* 如果删除不是最后位置 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=i;k&lt;L-&gt;length;k++)<span class="comment">/* 将删除位置后继元素前移 */</span></span><br><span class="line">L-&gt;data[k<span class="number">-1</span>]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="遍历顺序线性表"> 遍历顺序线性表</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListTraverse</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">            visit(L.data[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="合并la-lb两个顺序线性表"> 合并La、Lb两个顺序线性表</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionL</span><span class="params">(SqList *La,SqList Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> La_len,Lb_len,i;</span><br><span class="line">ElemType e;</span><br><span class="line">La_len=ListLength(*La);</span><br><span class="line">Lb_len=ListLength(Lb);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=Lb_len;i++)</span><br><span class="line">&#123;</span><br><span class="line">GetElem(Lb,i,&amp;e);</span><br><span class="line"><span class="keyword">if</span> (!LocateElem(*La,e))</span><br><span class="line">ListInsert(La,++La_len,e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="静态链表数组"> 静态链表（数组）</span></h2><h3><span id="类型定义"> 类型定义</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur;  <span class="comment">/* 游标(Cursor) ，为0时表示无指向 */</span></span><br><span class="line">&#125; Component,StaticLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure><h3><span id="将一维数组space中各分量链成一个备用链表space0cur为头指针quot0quot表示空指针"> 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(StaticLinkList space)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;MAXSIZE<span class="number">-1</span>; i++)  </span><br><span class="line">space[i].cur = i+<span class="number">1</span>;</span><br><span class="line">space[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>; <span class="comment">/* 目前静态链表为空，最后一个元素的cur为0 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="若备用空间链表非空则返回分配的结点下标否则返回0"> 若备用空间链表非空，则返回分配的结点下标，否则返回0</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SSL</span><span class="params">(StaticLinkList space)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> i = space[<span class="number">0</span>].cur;           <span class="comment">/* 当前数组第一个元素的cur存的值 */</span></span><br><span class="line">                                <span class="comment">/* 就是要返回的第一个备用空闲的下标 */</span></span><br><span class="line"><span class="keyword">if</span> (space[<span class="number">0</span>]. cur)         </span><br><span class="line">    space[<span class="number">0</span>]. cur = space[i].cur;       <span class="comment">/* 由于要拿出一个分量来使用了， */</span></span><br><span class="line">                                        <span class="comment">/* 所以我们就得把它的下一个 */</span></span><br><span class="line">                                        <span class="comment">/* 分量用来做备用 */</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="将下标为k的空闲结点回收到备用链表"> 将下标为k的空闲结点回收到备用链表</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span><span class="params">(StaticLinkList space, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    space[k].cur = space[<span class="number">0</span>].cur;    <span class="comment">/* 把第一个元素的cur值赋给要删除的分量cur */</span></span><br><span class="line">    space[<span class="number">0</span>].cur = k;               <span class="comment">/* 把要删除的分量下标赋值给第一个元素的cur */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="计算静态链表的长度"> 计算静态链表的长度</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=L[MAXSIZE<span class="number">-1</span>].cur;</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        i=L[i].cur;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="在l中第i个元素之前插入新的数据元素e"> 在L中第i个元素之前插入新的数据元素e</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i, ElemType e)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> j, k, l;   </span><br><span class="line">    k = MAXSIZE - <span class="number">1</span>;   <span class="comment">/* 注意k首先是最后一个元素的下标 */</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)   </span><br><span class="line">        <span class="keyword">return</span> ERROR;   </span><br><span class="line">    j = Malloc_SSL(L);   <span class="comment">/* 获得空闲分量的下标 */</span></span><br><span class="line">    <span class="keyword">if</span> (j)   </span><br><span class="line">    &#123;   </span><br><span class="line">L[j].data = e;   <span class="comment">/* 将数据赋值给此分量的data */</span></span><br><span class="line"><span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)   <span class="comment">/* 找到第i个元素之前的位置 */</span></span><br><span class="line">   k = L[k].cur;           </span><br><span class="line">L[j].cur = L[k].cur;    <span class="comment">/* 把第i个元素之前的cur赋值给新元素的cur */</span></span><br><span class="line">L[k].cur = j;           <span class="comment">/* 把新元素的下标赋值给第i个元素之前元素的ur */</span></span><br><span class="line"><span class="keyword">return</span> OK;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> ERROR;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="删除在l中第i个数据元素"> 删除在L中第i个数据元素</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span>   </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> j, k;   </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L))   </span><br><span class="line">        <span class="keyword">return</span> ERROR;   </span><br><span class="line">    k = MAXSIZE - <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)   </span><br><span class="line">        k = L[k].cur;   </span><br><span class="line">    j = L[k].cur;   </span><br><span class="line">    L[k].cur = L[j].cur;   </span><br><span class="line">    Free_SSL(L, j);   </span><br><span class="line">    <span class="keyword">return</span> OK;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="遍历静态链表"> 遍历静态链表</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListTraverse</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=L[MAXSIZE<span class="number">-1</span>].cur;</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">            visit(L[i].data);</span><br><span class="line">            i=L[i].cur;</span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="非循环单向线性表"> 非循环单向线性表</span></h2><h3><span id="类型定义"> 类型定义</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100<span class="comment">//顺序表存储空间的初始分配量 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT  10<span class="comment">//顺序表存储空间的分配增量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> LElemType_Sq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LElemType_Sq *elem;<span class="comment">//存储空间基址（指向第一个结点的指针） </span></span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//当前顺序表长度 </span></span><br><span class="line"><span class="keyword">int</span> listsize;<span class="comment">//当前分配的存储容量 </span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><h3><span id="初始化线性表"> 初始化线性表</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*L).elem = (LElemType_Sq*)<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="keyword">sizeof</span>(LElemType_Sq));</span><br><span class="line"><span class="keyword">if</span>(!(*L).elem)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW); <span class="comment">//分配内存失败</span></span><br><span class="line"></span><br><span class="line">(*L).length = <span class="number">0</span>;<span class="comment">//初始化顺序表长度为0</span></span><br><span class="line">(*L).listsize = LIST_INIT_SIZE;<span class="comment">//顺序表初始内存分配量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;<span class="comment">//初始化成功 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="清空线性表"> 清空线性表</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList_Sq</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">(*L).length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="销毁线性表"> 销毁线性表</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList_Sq</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>((*L).elem);</span><br><span class="line"></span><br><span class="line">(*L).elem = <span class="literal">NULL</span>;<span class="comment">//释放内存后置空指针 </span></span><br><span class="line">(*L).length = <span class="number">0</span>;</span><br><span class="line">(*L).listsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="判断线性表是否为空"> 判断线性表是否为空</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListEmpty_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.length==<span class="number">0</span> ? TRUE : FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="计算线性表的长度"> 计算线性表的长度</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="用e接收顺序表l中第i个元素"> 用e接收顺序表L中第i个元素</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_Sq</span><span class="params">(SqList L, <span class="keyword">int</span> i, LElemType_Sq *e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//i值不合法</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">*e = L.elem[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="返回顺序表l中首个与e满足compare关系的元素位序"> 返回顺序表L中首个与e满足Compare关系的元素位序</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList L, LElemType_Sq e, Status(Compare)(LElemType_Sq, LElemType_Sq))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//i的初值为第一个元素的位序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;=L.length &amp;&amp; !Compare(e, L.elem[i<span class="number">-1</span>]))</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;=L.length)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="用pre_e接收cur_e的前驱"> 用pre_e接收cur_e的前驱</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PriorElem_Sq</span><span class="params">(SqList L, LElemType_Sq cur_e, LElemType_Sq *pre_e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(L.elem[<span class="number">0</span>]!=cur_e)<span class="comment">//第一个结点无前驱 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(i&lt;L.length &amp;&amp; L.elem[i]!=cur_e)</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;L.length)</span><br><span class="line">&#123;</span><br><span class="line">*pre_e = L.elem[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="用next_e接收cur_e的后继"> 用next_e接收cur_e的后继</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NextElem_Sq</span><span class="params">(SqList L, LElemType_Sq cur_e, LElemType_Sq *next_e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;L.length &amp;&amp; L.elem[i]!=cur_e)</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;L.length<span class="number">-1</span>)<span class="comment">//最后一个结点无后继 </span></span><br><span class="line">&#123;</span><br><span class="line">*next_e = L.elem[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="在顺序表l的第i个位置上插入e"> 在顺序表L的第i个位置上插入e</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList *L, <span class="keyword">int</span> i, LElemType_Sq e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LElemType_Sq *newbase; </span><br><span class="line">LElemType_Sq *p, *q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;(*L).length+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//i值不合法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((*L).length &gt;= (*L).listsize)<span class="comment">//若存储空间已满，需开辟新空间 </span></span><br><span class="line">&#123;</span><br><span class="line">newbase = (LElemType_Sq*)<span class="built_in">realloc</span>((*L).elem, ((*L).listsize+LISTINCREMENT)*<span class="keyword">sizeof</span>(LElemType_Sq));</span><br><span class="line"><span class="keyword">if</span>(!newbase)</span><br><span class="line"><span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">(*L).elem = newbase;</span><br><span class="line">(*L).listsize += LISTINCREMENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q = &amp;(*L).elem[i<span class="number">-1</span>];<span class="comment">//q为插入位置 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(p=&amp;(*L).elem[(*L).length<span class="number">-1</span>]; p&gt;=q; --p)</span><br><span class="line">*(p+<span class="number">1</span>) = *p;<span class="comment">//插入位置及之后的元素右移 </span></span><br><span class="line"></span><br><span class="line">*q = e;<span class="comment">//插入e </span></span><br><span class="line">(*L).length++;<span class="comment">//表长增1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="删除顺序表l上第i个位置的元素并用e返回"> 删除顺序表L上第i个位置的元素，并用e返回</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList *L, <span class="keyword">int</span> i, LElemType_Sq *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LElemType_Sq *p, *q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;(*L).length)</span><br><span class="line"><span class="keyword">return</span> ERROR;<span class="comment">//i值不合法</span></span><br><span class="line"></span><br><span class="line">p = &amp;(*L).elem[i<span class="number">-1</span>];<span class="comment">//p为被删除元素的位置 </span></span><br><span class="line">*e = *p;</span><br><span class="line">q = (*L).elem+(*L).length<span class="number">-1</span>; <span class="comment">//表尾元素位置 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(++p; p&lt;=q; ++p)</span><br><span class="line">*(p<span class="number">-1</span>) = *p;<span class="comment">//被删元素之后的元素左移 </span></span><br><span class="line"></span><br><span class="line">(*L).length--;<span class="comment">//表长减1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="用visit函数访问顺序表l"> 用visit函数访问顺序表L</span></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListTraverse_Sq</span><span class="params">(SqList L, <span class="keyword">void</span>(Visit)(LElemType_Sq))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;L.length; i++)</span><br><span class="line">Visit(L.elem[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数据结构】第一章	绪论</title>
      <link href="/2019/06/06/Preface/"/>
      <url>/2019/06/06/Preface/</url>
      
        <content type="html"><![CDATA[<h1><span id="目录"> 目录</span></h1><p><ul class="markdownIt-TOC"><li><a href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E5%92%8C%E7%B1%BB%E5%9E%8B">预定义常量和类型</a></li><li><a href="#visit%E9%81%8D%E5%8E%86%E5%87%BD%E6%95%B0">Visit遍历函数</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89scanf%E5%87%BD%E6%95%B0">自定义Scanf函数</a></li><li><a href="#%E5%BD%A2%E5%8F%82%E9%83%A8%E5%88%86%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%9C%81%E7%95%A5%E5%8F%B7">形参部分可以使用省略号</a></li><li><a href="#%E5%BC%95%E7%94%A8-stdargh-%E5%A4%B4%E6%96%87%E4%BB%B6">引用 &lt;stdarg.h&gt; 头文件</a><ul><li><a href="#va_start%E5%87%BD%E6%95%B0">va_start函数</a></li><li><a href="#va_arg%E5%87%BD%E6%95%B0">va_arg函数</a></li><li><a href="#va_end%E5%87%BD%E6%95%B0">va_end函数</a></li></ul></li></ul></p><h2><span id="预定义常量和类型"> 预定义常量和类型</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="comment">//Status是函数的类型，其值是函数结果状态代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br></pre></td></tr></table></figure><h2><span id="visit遍历函数"> Visit遍历函数</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Visit</span><span class="params">(ElemType c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,c);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="自定义scanf函数"> 自定义Scanf函数</span></h2><blockquote><p>自定义的数据录入函数，用于从文件fp中读取格式化的输入。<br>与fscanf不同之处在于此函数只会读取西文字符，对于中文字符，则会跳过。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Scanf</span><span class="params">(FILE *fp, <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *i;</span><br><span class="line"><span class="keyword">char</span> *ch, *s;</span><br><span class="line"><span class="keyword">float</span> *f;</span><br><span class="line"><span class="keyword">int</span> count, k, len, n;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line">va_list ap;</span><br><span class="line"></span><br><span class="line">len = <span class="built_in">strlen</span>(format);</span><br><span class="line"></span><br><span class="line">va_start(ap, format);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(count=<span class="number">0</span>,k=<span class="number">2</span>; k&lt;=len; k=k+<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>((tmp=getc(fp))!=EOF)<span class="comment">//跳过所有非西文字符 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((tmp&gt;=<span class="number">0</span> &amp;&amp; tmp&lt;=<span class="number">127</span>))</span><br><span class="line">&#123;</span><br><span class="line">ungetc(tmp, fp);<span class="comment">//遇到首个西文字符，将此西文字符放入输入流 </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(tmp==EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(format[k<span class="number">-1</span>]==<span class="string">'c'</span>)<span class="comment">//读取字符 </span></span><br><span class="line">&#123;</span><br><span class="line">ch = va_arg(ap, <span class="keyword">char</span>*);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(tmp!=EOF)</span><br><span class="line">count += <span class="built_in">fscanf</span>(fp, <span class="string">"%c"</span>, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(format[k<span class="number">-1</span>]==<span class="string">'d'</span>)<span class="comment">//读取整型 </span></span><br><span class="line">&#123;</span><br><span class="line">i = va_arg(ap, <span class="keyword">int</span>*);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((tmp=getc(fp))!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((tmp&gt;=<span class="string">'0'</span> &amp;&amp; tmp&lt;=<span class="string">'9'</span>) || tmp==<span class="string">'-'</span> || tmp==<span class="string">'+'</span>)</span><br><span class="line">&#123;</span><br><span class="line">ungetc(tmp, fp);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(tmp!=EOF)</span><br><span class="line">count += <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(format[k<span class="number">-1</span>]==<span class="string">'f'</span>)<span class="comment">//读取浮点型 </span></span><br><span class="line">&#123;</span><br><span class="line">f = va_arg(ap, <span class="keyword">float</span>*);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((tmp=getc(fp))!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((tmp&gt;=<span class="string">'0'</span> &amp;&amp; tmp&lt;=<span class="string">'9'</span>) || tmp==<span class="string">'-'</span> || tmp==<span class="string">'+'</span>|| tmp==<span class="string">'.'</span> )</span><br><span class="line">&#123;</span><br><span class="line">ungetc(tmp, fp);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(tmp!=EOF)</span><br><span class="line">count += <span class="built_in">fscanf</span>(fp, <span class="string">"%f"</span>, f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(format[k<span class="number">-1</span>]==<span class="string">'s'</span>)<span class="comment">//读取字符串 </span></span><br><span class="line">&#123;</span><br><span class="line">s = va_arg(ap, <span class="keyword">char</span>*);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((tmp=getc(fp))!=EOF &amp;&amp; (!<span class="built_in">isprint</span>(tmp) || tmp==<span class="string">' '</span>))</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!feof(fp))</span><br><span class="line">&#123;</span><br><span class="line">ungetc(tmp, fp);</span><br><span class="line"><span class="keyword">while</span>((tmp=getc(fp))!=EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isprint</span>(tmp) &amp;&amp; tmp!=<span class="string">' '</span>)</span><br><span class="line">s[n++] = tmp;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ungetc(tmp, fp);</span><br><span class="line">&#125;</span><br><span class="line">                                                                                </span><br><span class="line">s[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">va_end(ap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="形参部分可以使用省略号"> 形参部分可以使用省略号</span></h2><blockquote><p>==C++==允许定义形参个数和类型不确定的函数。例如，C语言中的标准函数printf便使用这种机制。在声明不确定形参的函数时，<mark>形参部分可以使用省略号“…”代替。</mark>“…”告诉编译器，在函数调用时不检查形参类型是否与实参类型相同，也不检查参数个数。</p><p>即省略参数：用省略号…表示, ==省略号出现的地方可以有任意个任意类型的参数。==例如常用的printf函数：<br>int printf (const char *format,   …);</p></blockquote><h2><span id="引用-ltstdarghgt-头文件"> 引用 &lt;stdarg.h&gt; 头文件</span></h2><p>例如：<br>void ConnectData(int i,…);<br>在上面的代码中，编译器只检查第一个参数是否为整型，而不对其他参数进行检查。<br>对于可变参数的函数，需要进行特殊的处理。首先需要<mark>引用 &lt;stdarg.h&gt; 头文件</mark>，然后利用<mark>va_list类型和va_start、va_arg、va_end</mark> 3个宏读取传递到函数中的参数值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;//提供宏va_list、va_start、va_arg、va_end</span></span></span><br></pre></td></tr></table></figure><p>这几个宏的定义如下（在 ANSI C 中）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">type <span class="title">va_arg</span><span class="params">( va_list arg_ptr, type )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_end</span><span class="params">( va_list arg_ptr )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">va_start</span><span class="params">( va_list arg_ptr, prev_param )</span></span>;</span><br></pre></td></tr></table></figure><h3><span id="va_start函数"> va_start函数</span></h3><p>va_start函数将参数arg_ptr设置为可变参数列表的第一个参数。参数arg_ptr的类型必须为va_list。参数prev_param是在可变参数列表之前的那一个参数。（也就是说在 ANSI C 中，如果一个函数有可变参数，那么在该可变参数前必须有一个明确定义的参数，否则无法调用函数 va_start ，例如函数 int add(int i,…）是合法的，而函数 int add(…)是不合法的。）</p><h3><span id="va_arg函数"> va_arg函数</span></h3><p>va_arg函数将返回 arg_ptr 所指位置的值，并将 arg_ptr 指向下一个参数</p><h3><span id="va_end函数"> va_end函数</span></h3><p>检索完所有参数后，va_end将指针重置为NULL。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 绪论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法简易指南</title>
      <link href="/2019/02/23/Markdown/"/>
      <url>/2019/02/23/Markdown/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：本站使用<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>软件编辑</p></blockquote><h1><span id="目录"> 目录</span></h1><p><ul class="markdownIt-TOC"><li><a href="#%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8">目录列表</a></li><li><a href="#%E6%A0%87%E9%A2%98">标题</a></li><li><a href="#%E5%BC%95%E7%94%A8">引用</a><ul><li><a href="#%E5%8D%95%E8%A1%8C%E5%BC%8F">单行式</a></li><li><a href="#%E5%A4%9A%E8%A1%8C%E5%BC%8F">多行式</a></li><li><a href="#%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97">多层嵌套</a></li></ul></li><li><a href="#%E8%AF%AD%E4%B9%89%E6%A0%87%E8%AE%B0">语义标记</a><ul><li><a href="#%E6%96%9C%E4%BD%93">斜体</a></li><li><a href="#%E5%8A%A0%E7%B2%97-%E5%BC%BA%E8%B0%83">加粗 (强调)</a></li><li><a href="#%E5%88%A0%E9%99%A4%E7%BA%BF">删除线</a></li><li><a href="#%E8%BD%AC%E4%B9%89">转义</a></li><li><a href="#%E9%AB%98%E4%BA%AE">高亮</a></li><li><a href="#%E4%B8%8B%E6%A0%87">下标</a></li><li><a href="#%E4%B8%8A%E6%A0%87">上标</a></li><li><a href="#%E6%8F%92%E5%85%A5%E8%A1%A8%E6%83%85happy">插入表情:happy:</a></li><li><a href="#%E4%B8%8B%E5%88%92%E7%BA%BF">下划线</a></li><li><a href="#%E6%B0%B4%E5%B9%B3%E5%88%86%E5%89%B2%E7%BA%BF">水平分割线</a></li><li><a href="#%E6%B3%A8%E9%87%8A">注释</a></li></ul></li><li><a href="#%E5%88%97%E8%A1%A8">列表</a><ul><li><a href="#%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8">无序列表</a></li><li><a href="#%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8">有序列表</a></li><li><a href="#%E5%BA%8F%E8%A1%A8%E5%B5%8C%E5%A5%97">序表嵌套</a></li><li><a href="#%E5%B1%82%E7%BA%A7%E5%88%97%E8%A1%A8">层级列表</a></li><li><a href="#%E5%BA%8F%E8%A1%A8%E5%B5%8C%E5%A5%97%E4%BB%A3%E7%A0%81%E5%9D%97">序表嵌套代码块</a></li><li><a href="#%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8">任务列表</a></li></ul></li><li><a href="#%E4%BB%A3%E7%A0%81">代码</a><ul><li><a href="#%E8%A1%8C%E5%86%85%E6%A0%87%E8%AE%B0">行内标记</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E5%9D%97">代码块</a></li><li><a href="#%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87">插入图片</a></li></ul></li><li><a href="#%E8%B6%85%E9%93%BE%E6%8E%A5">超链接</a><ul><li><a href="#%E8%A1%8C%E5%86%85%E5%BC%8F">行内式</a></li><li><a href="#%E5%8F%82%E8%80%83%E5%BC%8F">参考式</a></li><li><a href="#%E8%87%AA%E5%8A%A8%E8%BF%9E%E6%8E%A5">自动连接</a></li><li><a href="#%E9%94%9A%E7%82%B9">锚点</a></li></ul></li><li><a href="#%E8%A1%A8%E6%A0%BC">表格</a><ul><li><a href="#%E7%89%B9%E6%AE%8A%E8%A1%A8%E6%A0%BC">特殊表格</a></li></ul></li><li><a href="#%E5%86%85%E5%B5%8Ccss%E6%A0%B7%E5%BC%8F">内嵌CSS样式</a></li><li><a href="#%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">数学公式</a><ul><li><a href="#%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F">数学表达式</a></li></ul></li></ul></p><h2><span id="目录列表"> 目录列表</span></h2><p>输入[toc]然后回车，将会产生一个目录，这个目录抽取了文章的所有标题，自动更新内容。</p><h2><span id="标题"> 标题</span></h2><p>使用#表示一级标题，##表示二级标题，以此类推，有6个标题。<br>注：# 后面保持空格</p><h2><span id="引用"> 引用</span></h2><h3><span id="单行式"> 单行式</span></h3><p>使用 &gt; 来插入块引用。例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; hello world!</span></span><br></pre></td></tr></table></figure><p><strong>演示：</strong></p><blockquote><p>hello world!</p></blockquote><h3><span id="多行式"> 多行式</span></h3><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello world!</span><br><span class="line">hello world!</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; hello world!</span></span><br><span class="line"><span class="quote">&gt; hello world!</span></span><br><span class="line"><span class="quote">&gt; hello world!</span></span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><p>相同的结果</p><blockquote><p>hello world!<br>hello world!<br>hello world!</p></blockquote><h3><span id="多层嵌套"> 多层嵌套</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> aaaaaaaaa</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &gt; bbbbbbbbb</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &gt; &gt; cccccccccc</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &gt; &gt; </span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><blockquote><p>aaaaaaaaa</p><blockquote><p>bbbbbbbbb</p><blockquote><p>cccccccccc</p></blockquote></blockquote></blockquote><h2><span id="语义标记"> 语义标记</span></h2><table><thead><tr><th>描述</th><th>效果</th><th>代码</th></tr></thead><tbody><tr><td>斜体</td><td><em>斜体</em></td><td><code>*斜体*</code></td></tr><tr><td>斜体</td><td><em>斜体</em></td><td><code>_斜体_</code></td></tr><tr><td>加粗</td><td><strong>加粗</strong></td><td><code>**加粗**</code></td></tr><tr><td>加粗+斜体</td><td><em><strong>加粗+斜体</strong></em></td><td><code>***加粗+斜体***</code></td></tr><tr><td>加粗+斜体</td><td><strong><em>加粗+斜体</em></strong></td><td><code>**_加粗+斜体_**</code></td></tr><tr><td>删除线</td><td><s>删除线</s></td><td><code>~~删除线~~</code></td></tr></tbody></table><h3><span id="斜体"> 斜体</span></h3><p>在标准的Markdown语法中，*和_包裹的内容会是斜体显示，但是GFM下划线一般用来分隔人名和代码变量名，因此我们推荐是用星号来包裹斜体内容。如果要显示星号，则使用转义：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\*</span></span><br></pre></td></tr></table></figure><h3><span id="加粗-强调"> 加粗 (强调)</span></h3><p>使用两个*号或者两个_包裹的内容将会被加粗。例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**使用两个*号加粗内容**</span></span><br><span class="line"><span class="strong">__使用两个下划线加粗内容__</span></span><br></pre></td></tr></table></figure><p>将会输出</p><p><strong>使用两个*号加粗内容</strong><br><strong>使用两个下划线加粗内容</strong></p><p><em>Typroa 推荐使用两个*号。</em></p><h3><span id="删除线"> 删除线</span></h3><p>GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用<code>~~</code>包裹的文本将会具有删除的样式，例如<code>~删除文本~</code>将产生<s>删除文本</s>的样式。</p><h3><span id="转义"> 转义</span></h3><p>markdown支持在以下字符前面插入反斜杠</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line"><span class="bullet">*   </span>星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line"><span class="section">#   井字号</span></span><br><span class="line"><span class="bullet">+   </span>加号</span><br><span class="line"><span class="bullet">-   </span>减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure><p>插入之后，将不再解析这些字符，而是原样输出。</p><h3><span id="高亮"> 高亮</span></h3><p>高亮使用<code>==</code>包裹，例如：<code>==高亮==</code>将产生<mark>高亮</mark></p><h3><span id="下标"> 下标</span></h3><p>下标使用<code>~</code>包裹，例如：<code>H~2~O</code>将产生H<sub>2</sub>O, 即水的分子式。</p><h3><span id="上标"> 上标</span></h3><p>上标使用<code>^</code>包裹，例如：<code>y^2^=4</code>将产生表达式y<sup>2</sup> = 4</p><h3><span id="插入表情happy"> 插入表情:happy:</span></h3><p>使用<code>:happy:</code>输入表情:happy:,使用<code>:sad:</code>输入表情:sad:,使用<code>:cry:</code>输入表情😢等。以此类推！</p><h3><span id="下划线"> 下划线</span></h3><p>用HTML的语法<code>&lt;u&gt;Underline&lt;/u&gt;</code>将产生下划线<u>Underline</u>.</p><h3><span id="水平分割线"> 水平分割线</span></h3><p>使用<code>***</code>或者<code>---</code>，然后回车，来产生水平分割线。</p><hr><h3><span id="注释"> 注释</span></h3><p>我们可以对某一个词语进行注释。例如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">某些人用过了才知道<span class="selector-attr">[^注释]</span></span><br><span class="line"><span class="selector-attr">[^注释]</span><span class="selector-pseudo">:Somebody</span> <span class="selector-tag">that</span> <span class="selector-tag">I</span> <span class="selector-tag">used</span> <span class="selector-tag">to</span> <span class="selector-tag">know</span>.</span><br></pre></td></tr></table></figure><p>将产生：</p><p>某些人用过了才知道<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p><em>把鼠标放在<code>注释</code>上，将会有提示内容。</em></p><h2><span id="列表"> 列表</span></h2><p>注：序列<code>.</code>后 保持空格</p><h3><span id="无序列表"> 无序列表</span></h3><p>输入+, -, *创建无序的列表，使用任意数字开头，创建有序列表，例如：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="strong">*无序的列表*</span><span class="strong">*</span></span><br><span class="line"><span class="strong">*</span> one</span><br><span class="line"><span class="bullet">* </span>two</span><br><span class="line"><span class="bullet">* </span>three</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><p><strong>无序的列表</strong></p><ul><li>one</li><li>two</li><li>three</li></ul><h3><span id="有序列表"> 有序列表</span></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**有序的列表**</span></span><br><span class="line"><span class="bullet">1. </span>one</span><br><span class="line"><span class="bullet">2. </span>two</span><br><span class="line"><span class="bullet">3. </span>three</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><p><strong>有序的列表</strong></p><ol><li>one</li><li>two</li><li>three</li></ol><h3><span id="序表嵌套"> 序表嵌套</span></h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> one</span><br><span class="line">    <span class="number">1.</span> one<span class="number">-1</span></span><br><span class="line">    <span class="number">2.</span> two<span class="number">-2</span></span><br><span class="line"><span class="number">2.</span> two </span><br><span class="line">    * two<span class="number">-1</span></span><br><span class="line">    * two<span class="number">-2</span></span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><ol><li>one<ol><li>one-1</li><li>two-2</li></ol></li><li>two<ul><li>two-1</li><li>two-2</li></ul></li></ol><h3><span id="层级列表"> 层级列表</span></h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">* 总目录</span></span><br><span class="line"><span class="comment">  * 一级目录</span></span><br><span class="line"><span class="comment">    * 二级目录</span></span><br><span class="line"><span class="comment">      * 三级目录</span></span><br></pre></td></tr></table></figure><p>说明：层级列表一般只支持三级列表，第一级实心圆点，第二级空心圆点，第三级以后都是实心方点。要实现层级列表，每下一级都要比上一级多输入2个空格或者一个Tab，而且第一级前面不要超过3个空格.</p><p><strong>演示</strong></p><ul><li>总目录<ul><li>一级目录<ul><li>二级目录<ul><li>三级目录</li></ul></li></ul></li></ul></li></ul><h3><span id="序表嵌套代码块"> 序表嵌套代码块</span></h3><p>注：换行+两个Tab</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* <span class="literal">one</span></span><br><span class="line">    var <span class="keyword">a</span> = <span class="number">10</span>;    <span class="comment"> // 与上行保持空行并递进缩进</span></span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><ul><li><p>one</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var a</span> = 10;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="任务列表"> 任务列表</span></h3><p>使用如下的代码创建任务列表，在[ ]中输入x表示完成，也可以通过点击选择完成或者没完成。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="string">[ ]</span> 吃饭</span><br><span class="line">- <span class="string">[ ]</span> 逛街</span><br><span class="line">- <span class="string">[ ]</span> 看电影</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><ul><li>[x] 吃饭</li><li>[x] 逛街</li><li>[x] 看电影</li></ul><h2><span id="代码"> 代码</span></h2><h3><span id="行内标记"> 行内标记</span></h3><p>使用`包裹的内容将会以代码样式显示，例如</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用<span class="string">`printf()`</span></span><br></pre></td></tr></table></figure><p>则会产生 <code>printf()</code> 样式。</p><h3><span id="代码块"> 代码块</span></h3><p><em>注：与上行距离一空行，根据不同的语言配置不同的代码着色</em></p><p>输入```或者~~~然后回车，可以输入代码块，并且可以选择代码的语言。</p><p>例如：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~~~java</span><br><span class="line">public Class HelloWorld&#123;</span><br><span class="line"><span class="code">  System.out.println("Hello World!");</span></span><br><span class="line">&#125;</span><br><span class="line">~~~</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class HelloWorld&#123;</span><br><span class="line">  System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">~~~javascript</span><br><span class="line">var num = 0;</span><br><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line"><span class="code">    num+=i;</span></span><br><span class="line">&#125;</span><br><span class="line">console.log(num);</span><br><span class="line">~~~</span><br></pre></td></tr></table></figure><p><strong>演示</strong></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    num+=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure><h3><span id="插入图片"> 插入图片</span></h3><p>我们可以通过拖拉的方式，将本地文件夹中的图片或者网络上的图片插入。</p><p><img src="http://typora.io/img/drag-img.gif" alt="drag and drop image"></p><hr><hr><h2><span id="超链接"> 超链接</span></h2><p><strong>Markdown支持两种形式的链接语法：行内式和参考式，行内式一般用的比较多。</strong></p><h3><span id="行内式"> 行内式</span></h3><p><strong>语法:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">打开百度</span>](<span class="link">https://www.baidu.com</span>)</span><br><span class="line">[<span class="string">打开百度</span>](<span class="link">https://www.baidu.com "打开百度"</span>)</span><br></pre></td></tr></table></figure><p>说明:[]里写链接文字，()里写链接地址, ()中的” “中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。<code>[链接文字](链接地址 &quot;链接标题&quot;)</code>这样的形式。链接地址与链接标题前有一个空格。</p><p><strong>展示效果</strong></p><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">打开百度</a></p><p><a href="https://www.baidu.com" title="打开百度" target="_blank" rel="noopener">打开百度</a></p><h3><span id="参考式"> 参考式</span></h3><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p><p><strong>语法:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我经常浏览的几个网站[<span class="string">Google</span>][<span class="symbol">1</span>]、[<span class="string">Baidu</span>][<span class="symbol">2</span>]、[<span class="string">51CTO</span>][<span class="symbol">3</span>]和看视频的网站[<span class="string">爱奇艺</span>][<span class="symbol">4</span>]感觉都是很不错的网站。</span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">http://www.google.com "google"</span></span><br><span class="line">[<span class="symbol">2</span>]:<span class="link">http://www.baidu.com "Baidu"</span></span><br><span class="line">[<span class="symbol">3</span>]:<span class="link">http://www.51cto.com "51cto"</span></span><br><span class="line">[<span class="symbol">4</span>]:<span class="link">http://www.aiqiyi.com "aiqiyi"</span></span><br></pre></td></tr></table></figure><p><strong>展示效果</strong></p><p>我经常浏览的几个网站<a href="http://www.google.com/%22google%22" target="_blank" rel="noopener">Google</a>、<a href="http://www.baidu.com/%22Baidu%22" target="_blank" rel="noopener">Baidu</a>、<a href="http://www.51cto.com/%2251cto%22" target="_blank" rel="noopener">51CTO</a>和看视频的网站<a href="http://www.aiqiyi.com/%22aiqiyi%22" target="_blank" rel="noopener">爱奇艺</a>感觉都是很不错的网站。</p><h3><span id="自动连接"> 自动连接</span></h3><p><strong>语法:</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">https:</span><span class="comment">//www.baidu.com&gt;</span></span><br><span class="line">&lt;xxx<span class="meta">@outlook</span>.com&gt;</span><br></pre></td></tr></table></figure><p>说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样。</p><p><strong>展示效果</strong></p><p><a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p><p><a href="mailto:xxx@outlook.com" target="_blank" rel="noopener">xxx@outlook.com</a></p><h3><span id="锚点"> 锚点</span></h3><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。</p><p>注意：Markdown Extra 只支持在标题后插入锚点，其它地方无效</p><h2><span id="表格"> 表格</span></h2><p>注：<code>:</code>代表对齐方式 ， <strong><code>:</code> 与<code>|</code> 之间不要有空格</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">|姓名|</span>性别<span class="params">|毕业学校|</span>工资<span class="params">|</span></span><br><span class="line"><span class="params">|</span><span class="symbol">:---|</span><span class="symbol">:---</span><span class="symbol">:|</span><span class="symbol">:---</span><span class="symbol">:|---</span><span class="symbol">:|</span></span><br><span class="line"><span class="params">|杨洋|</span>男<span class="params">|重庆交通大学|</span><span class="number">3200</span><span class="params">|</span></span><br><span class="line"><span class="params">|</span>峰哥<span class="params">|男|</span>贵州大学<span class="params">|5000|</span></span><br><span class="line"><span class="params">|坑货|</span>女<span class="params">|北京大学|</span><span class="number">2000</span><span class="params">|</span></span><br></pre></td></tr></table></figure><p>将产生:</p><table><thead><tr><th style="text-align:left">姓名</th><th style="text-align:center">性别</th><th style="text-align:center">毕业学校</th><th style="text-align:right">工资</th></tr></thead><tbody><tr><td style="text-align:left">杨洋</td><td style="text-align:center">男</td><td style="text-align:center">重庆交通大学</td><td style="text-align:right">3200</td></tr><tr><td style="text-align:left">峰哥</td><td style="text-align:center">男</td><td style="text-align:center">贵州大学</td><td style="text-align:right">5000</td></tr><tr><td style="text-align:left">坑货</td><td style="text-align:center">女</td><td style="text-align:center">北京大学</td><td style="text-align:right">2000</td></tr></tbody></table><p>其中代码的第二行指定对齐的方式，第一个是左对齐，第二个和第三个是居中，最后一个是右对齐。</p><h3><span id="特殊表格"> 特殊表格</span></h3><p>注：一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的<br>所以常规的做法是使用HTML标签，但是这样的编写效率极低。<br>但是有了这款工具的话，所有问题都迎刃而解。</p><p>在线生成HTML代码 <a href="http://www.tablesgenerator.com/" target="_blank" rel="noopener">Tables Generator</a> (国外的站)</p><p><img src="https:////upload-images.jianshu.io/upload_images/6912209-46aac2b114b995ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p><p>​                                                                    <u>Tables Generator</u></p><p><strong>演示</strong></p><p><img src="https:////upload-images.jianshu.io/upload_images/6912209-5e14abef7e65830d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/409/format/webp" alt="img"></p><h2><span id="内嵌css样式"> 内嵌CSS样式</span></h2><p><strong>代码</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: #AD5D0F;font-size: 30px; font-family: '宋体';"</span>&gt;</span>内联样式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>演示</strong></p><p style="color: #AD5D0F;font-size: 30px; font-family: '宋体';">内联样式</p><h2><span id="数学公式"> 数学公式</span></h2><blockquote><p>注：本站默认关闭数学公式渲染效果</p></blockquote><h3><span id="数学表达式"> 数学表达式</span></h3><p>要启用这个功能，首先到<code>Preference</code>-&gt;<code>Editor</code>中启用。然后使用<code>$</code>符号包裹Tex命令。</p><p>例如：</p><p><code>$lim_{x \to \infty} \ exp(-x)=0$</code>将产生如下的数学表达式：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>lim</mi><mo>⁡</mo></mo><mrow><mi>x</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow></msub><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mo>−</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\lim_{x \to \infty} \exp(-x)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lim</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord">−</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></p><p><code>$$ x \href{why-equal.html}{=} y^2 + 1 $$</code>将产生如下的数学表达式：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo href="why-equal.html">=</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mi mathvariant="normal">​</mi></mrow><annotation encoding="application/x-tex">x \href{why-equal.html}{=} y^2 + 1 ​</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0585479999999998em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><a href="why-equal.html"><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></a><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">​</span></span></span></span></span></p><p><code>$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $</code>将产生如下的数学表达式：</p><p>$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $</p><blockquote><p>参考资料：</p><p><a href="https://ouweiya.gitbooks.io/markdown/index.html" target="_blank" rel="noopener">https://ouweiya.gitbooks.io/markdown/index.html</a></p><p><a href="https://www.jianshu.com/p/b03a8d7b1719" target="_blank" rel="noopener">https://www.jianshu.com/p/b03a8d7b1719</a></p><p><a href="https://segmentfault.com/markdown#articleHeader4" target="_blank" rel="noopener">https://segmentfault.com/markdown#articleHeader4</a></p><p><a href="https://wizardforcel.gitbooks.io/markdown-simple-world/0.html" target="_blank" rel="noopener">https://wizardforcel.gitbooks.io/markdown-simple-world/0.html</a></p><p><a href="https://coding.net/help/doc/project/markdown.html" target="_blank" rel="noopener">https://coding.net/help/doc/project/markdown.html</a></p><p><a href="https://guo365.github.io/study/Markdown.html" target="_blank" rel="noopener">https://guo365.github.io/study/Markdown.html</a></p><p><a href="https://yuedu.baidu.com/ebook/f2ec7e699a6648d7c1c708a1284ac850ad020418" target="_blank" rel="noopener">https://yuedu.baidu.com/ebook/f2ec7e699a6648d7c1c708a1284ac850ad020418</a></p></blockquote><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Somebody that I used to know. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/02/17/hello-world/"/>
      <url>/2019/02/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3><span id="run-server">Run server</span></h3><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
