<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="[TOC]  第一章	常用算法杂项  第二章	C语言程序设计  第三章	数据结构基本操作  预定义常量和类型 1234567891011//函数结果状态代码#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2//Status是函数的类型，其值是函数结果状态代码">
<meta property="og:type" content="website">
<meta property="og:title" content="糙皮大叔">
<meta property="og:url" content="https://dddanbo.github.io/总章.html">
<meta property="og:site_name" content="糙皮大叔">
<meta property="og:description" content="[TOC]  第一章	常用算法杂项  第二章	C语言程序设计  第三章	数据结构基本操作  预定义常量和类型 1234567891011//函数结果状态代码#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2//Status是函数的类型，其值是函数结果状态代码">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-14T05:03:55.984Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="糙皮大叔">
<meta name="twitter:description" content="[TOC]  第一章	常用算法杂项  第二章	C语言程序设计  第三章	数据结构基本操作  预定义常量和类型 1234567891011//函数结果状态代码#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2//Status是函数的类型，其值是函数结果状态代码">



  <link rel="alternate" href="/atom.xml" title="糙皮大叔" type="application/atom+xml">



  
  
  <link rel="canonical" href="https://dddanbo.github.io/总章">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title> | 糙皮大叔</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">糙皮大叔</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">糙皮大叔</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

    
    
      
      
    
      
      
    
    

  


          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">

</h1>

<div class="post-meta">
  
  



</div>

</header>

      
      
      
      <div class="post-body">
        
        
          <p>[TOC]</p>
<h1><span id="第一章常用算法杂项"> 第一章	常用算法杂项</span></h1>
<h1><span id="第二章c语言程序设计"> 第二章	C语言程序设计</span></h1>
<h1><span id="第三章数据结构基本操作"> 第三章	数据结构基本操作</span></h1>
<h2><span id="预定义常量和类型"> 预定义常量和类型</span></h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OVERFLOW -2</span></span><br><span class="line"><span class="comment">//Status是函数的类型，其值是函数结果状态代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br></pre></td></tr></table></figure>
<h2><span id="visit遍历函数"> Visit遍历函数</span></h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Visit</span><span class="params">(ElemType c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d "</span>,c);</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="自定义scanf函数"> 自定义Scanf函数</span></h2>
<blockquote>
<p>自定义的数据录入函数，用于从文件fp中读取格式化的输入。<br>
与fscanf不同之处在于此函数只会读取西文字符，对于中文字符，则会跳过。</p>
</blockquote>
<h3><span id="形参部分可以使用省略号"> 形参部分可以使用省略号</span></h3>
<blockquote>
<p>==C++==允许定义形参个数和类型不确定的函数。例如，C语言中的标准函数printf便使用这种机制。在声明不确定形参的函数时，<mark>形参部分可以使用省略号“…”代替。</mark>“…”告诉编译器，在函数调用时不检查形参类型是否与实参类型相同，也不检查参数个数。</p>
<p>即省略参数：用省略号…表示, ==省略号出现的地方可以有任意个任意类型的参数。==例如常用的printf函数：<br>
int printf (const char *format,   …);</p>
</blockquote>
<h3><span id="引用-ltstdarghgt-头文件的va_list-va_start-va_arg-va_end"> 引用 &lt;stdarg.h&gt; 头文件的va_list、va_start、va_arg、va_end</span></h3>
<blockquote>
<p>例如：<br>
void ConnectData(int i,…);<br>
在上面的代码中，编译器只检查第一个参数是否为整型，而不对其他参数进行检查。<br>
对于可变参数的函数，需要进行特殊的处理。首先需要<mark>引用 &lt;stdarg.h&gt; 头文件</mark>，然后利用va_list类型和va_start、va_arg、va_end 3个宏读取传递到函数中的参数值。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;							//提供宏va_list、va_start、va_arg、va_end</span></span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>这几个宏的定义如下（在 ANSI C 中）：</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="function">type <span class="title">va_arg</span><span class="params">( va_list arg_ptr, type )</span></span>;</span><br><span class="line">&gt;  <span class="function"><span class="keyword">void</span> <span class="title">va_end</span><span class="params">( va_list arg_ptr )</span></span>;</span><br><span class="line">&gt;  <span class="function"><span class="keyword">void</span> <span class="title">va_start</span><span class="params">( va_list arg_ptr, prev_param )</span></span>; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h4><span id="va_start函数"> va_start函数</span></h4>
<p>va_start函数将参数arg_ptr设置为可变参数列表的第一个参数。参数arg_ptr的类型必须为va_list。参数prev_param是在可变参数列表之前的那一个参数。（也就是说在 ANSI C 中，如果一个函数有可变参数，那么在该可变参数前必须有一个明确定义的参数，否则无法调用函数 va_start ，例如函数 int add(int i,…）是合法的，而函数 int add(…)是不合法的。）</p>
<h4><span id="va_arg函数"> va_arg函数</span></h4>
<p>va_arg函数将返回 arg_ptr 所指位置的值，并将 arg_ptr 指向下一个参数</p>
<h4><span id="va_end函数"> va_end函数</span></h4>
<p>检索完所有参数后，va_end将指针重置为NULL。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Scanf</span><span class="params">(FILE *fp, <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *i;</span><br><span class="line">	<span class="keyword">char</span> *ch, *s;</span><br><span class="line">	<span class="keyword">float</span> *f;</span><br><span class="line">	<span class="keyword">int</span> count, k, len, n;		</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	va_list ap;</span><br><span class="line">	</span><br><span class="line">	len = <span class="built_in">strlen</span>(format);</span><br><span class="line">	</span><br><span class="line">	va_start(ap, format);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(count=<span class="number">0</span>,k=<span class="number">2</span>; k&lt;=len; k=k+<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>((tmp=getc(fp))!=EOF)			<span class="comment">//跳过所有非西文字符 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((tmp&gt;=<span class="number">0</span> &amp;&amp; tmp&lt;=<span class="number">127</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				ungetc(tmp, fp);			<span class="comment">//遇到首个西文字符，将此西文字符放入输入流 </span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(tmp==EOF)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(format[k<span class="number">-1</span>]==<span class="string">'c'</span>)				<span class="comment">//读取字符		 </span></span><br><span class="line">		&#123;</span><br><span class="line">			ch = va_arg(ap, <span class="keyword">char</span>*);</span><br><span class="line">						</span><br><span class="line">			<span class="keyword">if</span>(tmp!=EOF)</span><br><span class="line">				count += <span class="built_in">fscanf</span>(fp, <span class="string">"%c"</span>, ch);					</span><br><span class="line">		&#125;	</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(format[k<span class="number">-1</span>]==<span class="string">'d'</span>)				<span class="comment">//读取整型 </span></span><br><span class="line">		&#123;</span><br><span class="line">			i = va_arg(ap, <span class="keyword">int</span>*);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>((tmp=getc(fp))!=EOF)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>((tmp&gt;=<span class="string">'0'</span> &amp;&amp; tmp&lt;=<span class="string">'9'</span>) || tmp==<span class="string">'-'</span> || tmp==<span class="string">'+'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					ungetc(tmp, fp);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(tmp!=EOF)</span><br><span class="line">				count += <span class="built_in">fscanf</span>(fp, <span class="string">"%d"</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(format[k<span class="number">-1</span>]==<span class="string">'f'</span>)				<span class="comment">//读取浮点型 </span></span><br><span class="line">		&#123;</span><br><span class="line">			f = va_arg(ap, <span class="keyword">float</span>*);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>((tmp=getc(fp))!=EOF)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>((tmp&gt;=<span class="string">'0'</span> &amp;&amp; tmp&lt;=<span class="string">'9'</span>) || tmp==<span class="string">'-'</span> || tmp==<span class="string">'+'</span>|| tmp==<span class="string">'.'</span> )</span><br><span class="line">				&#123;</span><br><span class="line">					ungetc(tmp, fp);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(tmp!=EOF)</span><br><span class="line">				count += <span class="built_in">fscanf</span>(fp, <span class="string">"%f"</span>, f);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(format[k<span class="number">-1</span>]==<span class="string">'s'</span>)				<span class="comment">//读取字符串 </span></span><br><span class="line">		&#123;</span><br><span class="line">			s = va_arg(ap, <span class="keyword">char</span>*);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>((tmp=getc(fp))!=EOF &amp;&amp; (!<span class="built_in">isprint</span>(tmp) || tmp==<span class="string">' '</span>))</span><br><span class="line">				;</span><br><span class="line">			</span><br><span class="line">			n = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(!feof(fp))</span><br><span class="line">			&#123;</span><br><span class="line">				ungetc(tmp, fp);</span><br><span class="line">				<span class="keyword">while</span>((tmp=getc(fp))!=EOF)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">isprint</span>(tmp) &amp;&amp; tmp!=<span class="string">' '</span>)</span><br><span class="line">						s[n++] = tmp;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						<span class="keyword">break</span>;	</span><br><span class="line">				&#125;</span><br><span class="line">				ungetc(tmp, fp);			</span><br><span class="line">			&#125;</span><br><span class="line">                                                                                </span><br><span class="line">			s[n] = <span class="string">'\0'</span>;</span><br><span class="line">					</span><br><span class="line">			count++;		</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	va_end(ap);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="顺序线性表数组"> 顺序线性表（数组）</span></h2>
<h3><span id="类型定义"> 类型定义</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data[MAXSIZE];        <span class="comment">/* 数组，存储数据元素 */</span></span><br><span class="line">	<span class="keyword">int</span> length;                                <span class="comment">/* 线性表当前长度 */</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<h3><span id="初始化顺序线性表"> 初始化顺序线性表</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(SqList *L)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="判断顺序表是否为空"> 判断顺序表是否为空</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListEmpty</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="清空顺序表"> 清空顺序表</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    L-&gt;length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="计算顺序表的长度"> 计算顺序表的长度</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="用e返回l中第i个数据元素的值"> 用e返回L中第i个数据元素的值</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i,ElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L.data[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="返回l中第1个与e满足关系的数据元素的位序"> 返回L中第1个与e满足关系的数据元素的位序</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (L.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">if</span> (L.data[i]==e)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=L.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="在l中第i个位置之前插入新的数据元素e"> 在L中第i个位置之前插入新的数据元素e</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;length==MAXSIZE)  <span class="comment">/* 顺序线性表已经满 */</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)<span class="comment">/* 当i比第一位置小或者比最后一位置后一位置还要大时 */</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i&lt;=L-&gt;length)        <span class="comment">/* 若插入数据位置不在表尾 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)  <span class="comment">/* 将要插入位置之后的数据元素向后移动一位 */</span></span><br><span class="line">			L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;data[i<span class="number">-1</span>]=e;          <span class="comment">/* 将新元素插入 */</span></span><br><span class="line">	L-&gt;length++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="删除l的第i个数据元素并用e返回其值"> 删除L的第i个数据元素，并用e返回其值</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList *L,<span class="keyword">int</span> i,ElemType *e)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;length==<span class="number">0</span>)               <span class="comment">/* 线性表为空 */</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L-&gt;length)         <span class="comment">/* 删除位置不正确 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e=L-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> (i&lt;L-&gt;length)                <span class="comment">/* 如果删除不是最后位置 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=i;k&lt;L-&gt;length;k++)<span class="comment">/* 将删除位置后继元素前移 */</span></span><br><span class="line">			L-&gt;data[k<span class="number">-1</span>]=L-&gt;data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="遍历顺序线性表"> 遍历顺序线性表</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListTraverse</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">            visit(L.data[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="合并la-lb两个顺序线性表"> 合并La、Lb两个顺序线性表</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionL</span><span class="params">(SqList *La,SqList Lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> La_len,Lb_len,i;</span><br><span class="line">	ElemType e;</span><br><span class="line">	La_len=ListLength(*La);</span><br><span class="line">	Lb_len=ListLength(Lb);</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=Lb_len;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		GetElem(Lb,i,&amp;e);</span><br><span class="line">		<span class="keyword">if</span> (!LocateElem(*La,e))</span><br><span class="line">			ListInsert(La,++La_len,e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="静态链表数组"> 静态链表（数组）</span></h2>
<h3><span id="类型定义"> 类型定义</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> cur;  <span class="comment">/* 游标(Cursor) ，为0时表示无指向 */</span></span><br><span class="line">&#125; Component,StaticLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure>
<h3><span id="将一维数组space中各分量链成一个备用链表space0cur为头指针quot0quot表示空指针"> 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList</span><span class="params">(StaticLinkList space)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;MAXSIZE<span class="number">-1</span>; i++)  </span><br><span class="line">		space[i].cur = i+<span class="number">1</span>;</span><br><span class="line">	space[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>; <span class="comment">/* 目前静态链表为空，最后一个元素的cur为0 */</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="若备用空间链表非空则返回分配的结点下标否则返回0"> 若备用空间链表非空，则返回分配的结点下标，否则返回0</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Malloc_SSL</span><span class="params">(StaticLinkList space)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> i = space[<span class="number">0</span>].cur;           		<span class="comment">/* 当前数组第一个元素的cur存的值 */</span></span><br><span class="line">	                                		<span class="comment">/* 就是要返回的第一个备用空闲的下标 */</span></span><br><span class="line">	<span class="keyword">if</span> (space[<span class="number">0</span>]. cur)         </span><br><span class="line">	    space[<span class="number">0</span>]. cur = space[i].cur;       <span class="comment">/* 由于要拿出一个分量来使用了， */</span></span><br><span class="line">	                                        <span class="comment">/* 所以我们就得把它的下一个 */</span></span><br><span class="line">	                                        <span class="comment">/* 分量用来做备用 */</span></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="将下标为k的空闲结点回收到备用链表"> 将下标为k的空闲结点回收到备用链表</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Free_SSL</span><span class="params">(StaticLinkList space, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    space[k].cur = space[<span class="number">0</span>].cur;    <span class="comment">/* 把第一个元素的cur值赋给要删除的分量cur */</span></span><br><span class="line">    space[<span class="number">0</span>].cur = k;               <span class="comment">/* 把要删除的分量下标赋值给第一个元素的cur */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="计算静态链表的长度"> 计算静态链表的长度</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=L[MAXSIZE<span class="number">-1</span>].cur;</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        i=L[i].cur;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="在l中第i个元素之前插入新的数据元素e"> 在L中第i个元素之前插入新的数据元素e</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i, ElemType e)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> j, k, l;   </span><br><span class="line">    k = MAXSIZE - <span class="number">1</span>;   <span class="comment">/* 注意k首先是最后一个元素的下标 */</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)   </span><br><span class="line">        <span class="keyword">return</span> ERROR;   </span><br><span class="line">    j = Malloc_SSL(L);   <span class="comment">/* 获得空闲分量的下标 */</span></span><br><span class="line">    <span class="keyword">if</span> (j)   </span><br><span class="line">    &#123;   </span><br><span class="line">		L[j].data = e;   <span class="comment">/* 将数据赋值给此分量的data */</span></span><br><span class="line">		<span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= i - <span class="number">1</span>; l++)   <span class="comment">/* 找到第i个元素之前的位置 */</span></span><br><span class="line">		   k = L[k].cur;           </span><br><span class="line">		L[j].cur = L[k].cur;    <span class="comment">/* 把第i个元素之前的cur赋值给新元素的cur */</span></span><br><span class="line">		L[k].cur = j;           <span class="comment">/* 把新元素的下标赋值给第i个元素之前元素的ur */</span></span><br><span class="line">		<span class="keyword">return</span> OK;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> ERROR;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="删除在l中第i个数据元素"> 删除在L中第i个数据元素</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(StaticLinkList L, <span class="keyword">int</span> i)</span>   </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> j, k;   </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; ListLength(L))   </span><br><span class="line">        <span class="keyword">return</span> ERROR;   </span><br><span class="line">    k = MAXSIZE - <span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++)   </span><br><span class="line">        k = L[k].cur;   </span><br><span class="line">    j = L[k].cur;   </span><br><span class="line">    L[k].cur = L[j].cur;   </span><br><span class="line">    Free_SSL(L, j);   </span><br><span class="line">    <span class="keyword">return</span> OK;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="遍历静态链表"> 遍历静态链表</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListTraverse</span><span class="params">(StaticLinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=L[MAXSIZE<span class="number">-1</span>].cur;</span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">            visit(L[i].data);</span><br><span class="line">            i=L[i].cur;</span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="非循环单向线性表"> 非循环单向线性表</span></h2>
<h3><span id="类型定义"> 类型定义</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_INIT_SIZE 100				<span class="comment">//顺序表存储空间的初始分配量 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTINCREMENT  10				<span class="comment">//顺序表存储空间的分配增量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> LElemType_Sq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LElemType_Sq *elem;					<span class="comment">//存储空间基址（指向第一个结点的指针） </span></span><br><span class="line">	<span class="keyword">int</span> length;							<span class="comment">//当前顺序表长度 </span></span><br><span class="line">	<span class="keyword">int</span> listsize;						<span class="comment">//当前分配的存储容量 </span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<h3><span id="初始化线性表"> 初始化线性表</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*L).elem = (LElemType_Sq*)<span class="built_in">malloc</span>(LIST_INIT_SIZE*<span class="keyword">sizeof</span>(LElemType_Sq));</span><br><span class="line">	<span class="keyword">if</span>(!(*L).elem)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW); 				<span class="comment">//分配内存失败</span></span><br><span class="line"></span><br><span class="line">	(*L).length = <span class="number">0</span>;					<span class="comment">//初始化顺序表长度为0</span></span><br><span class="line">	(*L).listsize = LIST_INIT_SIZE;		<span class="comment">//顺序表初始内存分配量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;							<span class="comment">//初始化成功	 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="清空线性表"> 清空线性表</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearList_Sq</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*L).length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="销毁线性表"> 销毁线性表</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyList_Sq</span><span class="params">(SqList *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>((*L).elem);</span><br><span class="line"></span><br><span class="line">	(*L).elem = <span class="literal">NULL</span>;					<span class="comment">//释放内存后置空指针 </span></span><br><span class="line">	(*L).length = <span class="number">0</span>;</span><br><span class="line">	(*L).listsize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="判断线性表是否为空"> 判断线性表是否为空</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListEmpty_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> 	L.length==<span class="number">0</span> ? TRUE : FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="计算线性表的长度"> 计算线性表的长度</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ListLength_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> L.length;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="用e接收顺序表l中第i个元素"> 用e接收顺序表L中第i个元素</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_Sq</span><span class="params">(SqList L, <span class="keyword">int</span> i, LElemType_Sq *e)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> ERROR;					<span class="comment">//i值不合法</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		*e = L.elem[i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="返回顺序表l中首个与e满足compare关系的元素位序"> 返回顺序表L中首个与e满足Compare关系的元素位序</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem_Sq</span><span class="params">(SqList L, LElemType_Sq e, Status(Compare)(LElemType_Sq, LElemType_Sq))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;							<span class="comment">//i的初值为第一个元素的位序</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=L.length &amp;&amp; !Compare(e, L.elem[i<span class="number">-1</span>]))</span><br><span class="line">		++i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i&lt;=L.length)</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="用pre_e接收cur_e的前驱"> 用pre_e接收cur_e的前驱</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PriorElem_Sq</span><span class="params">(SqList L, LElemType_Sq cur_e, LElemType_Sq *pre_e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(L.elem[<span class="number">0</span>]!=cur_e)				<span class="comment">//第一个结点无前驱 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;L.length &amp;&amp; L.elem[i]!=cur_e)</span><br><span class="line">			++i;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(i&lt;L.length)</span><br><span class="line">		&#123;</span><br><span class="line">			*pre_e = L.elem[i<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">return</span> OK;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">			</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="用next_e接收cur_e的后继"> 用next_e接收cur_e的后继</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">NextElem_Sq</span><span class="params">(SqList L, LElemType_Sq cur_e, LElemType_Sq *next_e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&lt;L.length &amp;&amp; L.elem[i]!=cur_e)</span><br><span class="line">		++i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i&lt;L.length<span class="number">-1</span>)					<span class="comment">//最后一个结点无后继 </span></span><br><span class="line">	&#123;</span><br><span class="line">		*next_e = L.elem[i+<span class="number">1</span>];	</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="在顺序表l的第i个位置上插入e"> 在顺序表L的第i个位置上插入e</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert_Sq</span><span class="params">(SqList *L, <span class="keyword">int</span> i, LElemType_Sq e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LElemType_Sq *newbase; </span><br><span class="line">	LElemType_Sq *p, *q;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;(*L).length+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;					<span class="comment">//i值不合法</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((*L).length &gt;= (*L).listsize)	<span class="comment">//若存储空间已满，需开辟新空间 </span></span><br><span class="line">	&#123;</span><br><span class="line">		newbase = (LElemType_Sq*)<span class="built_in">realloc</span>((*L).elem, ((*L).listsize+LISTINCREMENT)*<span class="keyword">sizeof</span>(LElemType_Sq));</span><br><span class="line">		<span class="keyword">if</span>(!newbase)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">		(*L).elem = newbase;</span><br><span class="line">		(*L).listsize += LISTINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	q = &amp;(*L).elem[i<span class="number">-1</span>];				<span class="comment">//q为插入位置 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(p=&amp;(*L).elem[(*L).length<span class="number">-1</span>]; p&gt;=q; --p)</span><br><span class="line">		*(p+<span class="number">1</span>) = *p;					<span class="comment">//插入位置及之后的元素右移 </span></span><br><span class="line">	</span><br><span class="line">	*q = e;								<span class="comment">//插入e </span></span><br><span class="line">	(*L).length++;						<span class="comment">//表长增1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="删除顺序表l上第i个位置的元素并用e返回"> 删除顺序表L上第i个位置的元素，并用e返回</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete_Sq</span><span class="params">(SqList *L, <span class="keyword">int</span> i, LElemType_Sq *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LElemType_Sq *p, *q;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;(*L).length)</span><br><span class="line">		<span class="keyword">return</span> ERROR;					<span class="comment">//i值不合法</span></span><br><span class="line">	</span><br><span class="line">	p = &amp;(*L).elem[i<span class="number">-1</span>];				<span class="comment">//p为被删除元素的位置 </span></span><br><span class="line">	*e = *p;</span><br><span class="line">	q = (*L).elem+(*L).length<span class="number">-1</span>; 		<span class="comment">//表尾元素位置 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(++p; p&lt;=q; ++p)</span><br><span class="line">		*(p<span class="number">-1</span>) = *p;					<span class="comment">//被删元素之后的元素左移 </span></span><br><span class="line"></span><br><span class="line">	(*L).length--;						<span class="comment">//表长减1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="用visit函数访问顺序表l"> 用visit函数访问顺序表L</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListTraverse_Sq</span><span class="params">(SqList L, <span class="keyword">void</span>(Visit)(LElemType_Sq))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;L.length; i++)</span><br><span class="line">		Visit(L.elem[i]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="单向循环链表"> 单向循环链表</span></h2>
<h2><span id="顺序栈"> 顺序栈</span></h2>
<h3><span id="类型定义"> 类型定义</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_INIT_SIZE	100				<span class="comment">//顺序栈存储空间的初始分配量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKINCREMENT	10 				<span class="comment">//顺序栈存储空间的分配增量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> SElemType_Sq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	SElemType_Sq *base;				<span class="comment">//在栈构造之前和销毁之后，base的值为NULL </span></span><br><span class="line">	SElemType_Sq *top;				<span class="comment">//栈顶指针 </span></span><br><span class="line">	<span class="keyword">int</span> stacksize;					<span class="comment">//当前已分配的存储空间，以元素为单位 </span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
<h3><span id="栈的初始化"> 栈的初始化</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack_Sq</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	S.base = (SElemType_Sq *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType_Sq));</span><br><span class="line">	<span class="keyword">if</span>(!S.base)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		</span><br><span class="line">	S.top = S.base;</span><br><span class="line">	S.stacksize = STACK_INIT_SIZE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitStack_Sq</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	(*S).base = (SElemType_Sq *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType_Sq));</span><br><span class="line">	<span class="keyword">if</span>(!(*S).base)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		</span><br><span class="line">	(*S).top = (*S).base;</span><br><span class="line">	(*S).stacksize = STACK_INIT_SIZE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="销毁栈"> 销毁栈</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyStack_Sq</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>(S.base);</span><br><span class="line">	</span><br><span class="line">	S.base = <span class="literal">NULL</span>;</span><br><span class="line">	S.top = <span class="literal">NULL</span>;</span><br><span class="line">	S.stacksize = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DestroyStack_Sq</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">free</span>((*S).base);</span><br><span class="line">	</span><br><span class="line">	(*S).base = <span class="literal">NULL</span>;</span><br><span class="line">	(*S).top = <span class="literal">NULL</span>;</span><br><span class="line">	(*S).stacksize = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="清空栈"> 清空栈</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearStack_Sq</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	S.top = S.base;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">ClearStack_Sq</span><span class="params">(SqStack *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*S).top = (*S).base;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="判断栈是否为空"> 判断栈是否为空</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackEmpty_Sq</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br></pre></td></tr></table></figure>
<h3><span id="计算栈的长度"> 计算栈的长度</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength_Sq</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> S.top - S.base;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br></pre></td></tr></table></figure>
<h3><span id="得到栈顶元素"> 得到栈顶元素</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetTop_Sq</span><span class="params">(SqStack S, SElemType_Sq &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">		</span><br><span class="line">	e = *(S.top - <span class="number">1</span>);							<span class="comment">//并不破坏栈 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetTop_Sq</span><span class="params">(SqStack S, SElemType_Sq *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">		</span><br><span class="line">	*e = *(S.top - <span class="number">1</span>);							<span class="comment">//并不破坏栈 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="入栈"> 入栈</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push_Sq</span><span class="params">(SqStack &amp;S, SElemType_Sq e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize)		<span class="comment">//栈满，追加存储空间</span></span><br><span class="line">	&#123;</span><br><span class="line">		S.base = (SElemType_Sq *)<span class="built_in">realloc</span>(S.base, (S.stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType_Sq));</span><br><span class="line">		<span class="keyword">if</span>(!S.base)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);						<span class="comment">//存储分配失败</span></span><br><span class="line">		S.top = S.base + S.stacksize;</span><br><span class="line">		S.stacksize += STACKINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	*(S.top) = e;								<span class="comment">//进栈先赋值，栈顶指针再自增 </span></span><br><span class="line">	(S.top)++;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Push_Sq</span><span class="params">(SqStack *S, SElemType_Sq e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((*S).top-(*S).base&gt;=(*S).stacksize)		<span class="comment">//栈满，追加存储空间</span></span><br><span class="line">	&#123;</span><br><span class="line">		(*S).base = (SElemType_Sq *)<span class="built_in">realloc</span>((*S).base, ((*S).stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType_Sq));</span><br><span class="line">		<span class="keyword">if</span>(!(*S).base)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);						<span class="comment">//存储分配失败</span></span><br><span class="line">		(*S).top = (*S).base + (*S).stacksize;</span><br><span class="line">		(*S).stacksize += STACKINCREMENT;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	*(S-&gt;top) = e;								<span class="comment">//进栈先赋值，栈顶指针再自增 </span></span><br><span class="line">	(S-&gt;top)++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="出栈"> 出栈</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop_Sq</span><span class="params">(SqStack &amp;S, SElemType_Sq &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	S.top--;									<span class="comment">//出栈栈顶指针先递减，再赋值 </span></span><br><span class="line">	e = *(S.top);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">Pop_Sq</span><span class="params">(SqStack *S, SElemType_Sq *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((*S).top==(*S).base)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	(*S).top--;									<span class="comment">//出栈栈顶指针先递减，再赋值 </span></span><br><span class="line">	*e = *((*S).top);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="遍历栈中元素"> 遍历栈中元素</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StackTraverse_Sq</span><span class="params">(SqStack S, <span class="keyword">void</span>(Visit)(SElemType_Sq))</span></span></span><br><span class="line"><span class="function"></span>&#123;												<span class="comment">//遍历不应该破坏栈 </span></span><br><span class="line">	SElemType_Sq *p = S.base;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(p&lt;S.top)</span><br><span class="line">		Visit(*p++);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br></pre></td></tr></table></figure>
<h2><span id="非循环队列"> 非循环队列</span></h2>
<h3><span id="类型定义"> 类型定义</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType_L;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>				 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QElemType_L data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,* QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QueuePtr front;					<span class="comment">//头指针 </span></span><br><span class="line">	QueuePtr rear;					<span class="comment">//尾指针 </span></span><br><span class="line">&#125;LinkQueue;							<span class="comment">//队列的链式存储表示</span></span><br></pre></td></tr></table></figure>
<h3><span id="非循环队列的初始化"> 非循环队列的初始化</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue_L</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="keyword">if</span>(!Q.front)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">	Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">InitQueue_L</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*Q).front = (*Q).rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="keyword">if</span>(!(*Q).front)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">	(*Q).front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="清空队列"> 清空队列</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearQueue_L</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q.rear = Q.front-&gt;next;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(Q.rear)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.front-&gt;next = Q.rear-&gt;next;		</span><br><span class="line">		<span class="built_in">free</span>(Q.rear);		</span><br><span class="line">		Q.rear = Q.front-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Q.rear = Q.front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearQueue_L</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*Q).rear = (*Q).front-&gt;next;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>((*Q).rear)</span><br><span class="line">	&#123;</span><br><span class="line">		(*Q).front-&gt;next = (*Q).rear-&gt;next;		</span><br><span class="line">		<span class="built_in">free</span>((*Q).rear);		</span><br><span class="line">		(*Q).rear = (*Q).front-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	(*Q).rear = (*Q).front;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="销毁队列"> 销毁队列</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue_L</span><span class="params">(LinkQueue &amp;Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(Q.front)</span><br><span class="line">	&#123;</span><br><span class="line">		Q.rear = Q.front-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(Q.front);</span><br><span class="line">		Q.front = Q.rear;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue_L</span><span class="params">(LinkQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>((*Q).front)</span><br><span class="line">	&#123;</span><br><span class="line">		(*Q).rear = (*Q).front-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>((*Q).front);</span><br><span class="line">		(*Q).front = (*Q).rear;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="判断队列是否为空"> 判断队列是否为空</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">QueueEmpty_L</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br></pre></td></tr></table></figure>
<h3><span id="计算队列的长度"> 计算队列的长度</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength_L</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	QueuePtr p = Q.front;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(p!=Q.rear)</span><br><span class="line">	&#123;</span><br><span class="line">		count++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br></pre></td></tr></table></figure>
<h3><span id="得到队头元素"> 得到队头元素</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetHead_L</span><span class="params">(LinkQueue Q, QElemType_L &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">		</span><br><span class="line">	p = Q.front-&gt;next;</span><br><span class="line">	e = p-&gt;data;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">GetHead_L</span><span class="params">(LinkQueue Q, QElemType_L *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">		</span><br><span class="line">	p = Q.front-&gt;next;</span><br><span class="line">	*e = p-&gt;data;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="入队"> 入队</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue_L</span><span class="params">(LinkQueue &amp;Q, QElemType_L e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	</span><br><span class="line">	p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="keyword">if</span>(!p)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">	p-&gt;data = e;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	Q.rear-&gt;next = p;</span><br><span class="line">	Q.rear=p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue_L</span><span class="params">(LinkQueue *Q, QElemType_L e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	</span><br><span class="line">	p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="keyword">if</span>(!p)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">	p-&gt;data = e;</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	(*Q).rear-&gt;next = p;</span><br><span class="line">	(*Q).rear=p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="出队"> 出队</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue_L</span><span class="params">(LinkQueue &amp;Q, QElemType_L &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">		</span><br><span class="line">	p = Q.front-&gt;next;</span><br><span class="line">	e = p-&gt;data;</span><br><span class="line">	</span><br><span class="line">	Q.front-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(Q.rear==p)</span><br><span class="line">		Q.rear = Q.front;</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DeQueue_L</span><span class="params">(LinkQueue *Q, QElemType_L *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((*Q).front==(*Q).rear)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">		</span><br><span class="line">	p = (*Q).front-&gt;next;</span><br><span class="line">	*e = p-&gt;data;</span><br><span class="line">	</span><br><span class="line">	(*Q).front-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>((*Q).rear==p)</span><br><span class="line">		(*Q).rear = (*Q).front;</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="遍历非循环队列"> 遍历非循环队列</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueTraverse_L</span><span class="params">(LinkQueue Q, <span class="keyword">void</span> (Visit)(QElemType_L))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	</span><br><span class="line">	p = Q.front-&gt;next;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">		Visit(p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************</span></span><br></pre></td></tr></table></figure>
<h2><span id="循环队列不设头指针"> 循环队列（不设头指针）</span></h2>
<blockquote>
<p><strong>假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针）</strong></p>
</blockquote>
<h3><span id="类型定义"> 类型定义</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType_L;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>				 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QElemType_L data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,* QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QueuePtr rear;					<span class="comment">//尾指针 </span></span><br><span class="line">&#125;LinkQueue;							<span class="comment">//队列的链式存储表示</span></span><br></pre></td></tr></table></figure>
<h3><span id="循环队列初始化"> 循环队列初始化</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue_L</span><span class="params">(LinkQueue *Q)</span>					<span class="comment">//队列初始化 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*Q).rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="keyword">if</span>(!(*Q).rear)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">	(*Q).rear-&gt;next = (*Q).rear;	<span class="comment">//初次创建的(*Q).rear为头结点，且next指向</span></span><br><span class="line">									<span class="comment">//自身，达到循环效果。 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="入队"> 入队</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue_L</span><span class="params">(LinkQueue *Q, QElemType e)</span>	<span class="comment">//入队 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	</span><br><span class="line">	p = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	<span class="keyword">if</span>(!p)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	p-&gt;data = e;</span><br><span class="line"></span><br><span class="line">	p-&gt;next = (*Q).rear-&gt;next;	<span class="comment">//入队后新结点的next始终指向头结点，构成循环队列 </span></span><br><span class="line">	(*Q).rear-&gt;next = p;		<span class="comment">//每次都在队尾入队 </span></span><br><span class="line">	(*Q).rear = p;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="出队"> 出队</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue_L</span><span class="params">(LinkQueue *Q, QElemType *e)</span>	<span class="comment">//出队 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr h, p;</span><br><span class="line">	</span><br><span class="line">	h = (*Q).rear-&gt;next;</span><br><span class="line">	<span class="keyword">if</span>(h-&gt;next==(*Q).rear-&gt;next)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">		</span><br><span class="line">	p = h-&gt;next;</span><br><span class="line">	*e = p-&gt;data;</span><br><span class="line">	</span><br><span class="line">	h-&gt;next = p-&gt;next;	<span class="comment">//当队列只有一个元素时，头结点的next指向自身 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(p==(*Q).rear)							<span class="comment">//队列只有一个元素 </span></span><br><span class="line">		(*Q).rear = h;							<span class="comment">//rear指向头结点 </span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="遍历循环队列"> 遍历循环队列</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output_L</span><span class="params">(LinkQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	QueuePtr p;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(p=Q.rear-&gt;next-&gt;next; p!=Q.rear-&gt;next; p=p-&gt;next)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="循环队列设头指针"> 循环队列（设头指针）</span></h2>
<blockquote>
<p><strong>设置一个标志域tag，并以tag的值为0和1来区分，尾指针和头指针值相同时的队列状态是“空”还是“满”。</strong></p>
</blockquote>
<h3><span id="类型定义"> 类型定义</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	QElemType *base;</span><br><span class="line">	<span class="keyword">int</span> front;	</span><br><span class="line">	<span class="keyword">int</span> rear;</span><br><span class="line">	<span class="keyword">int</span> tag;							<span class="comment">//0表示空，1表示满 </span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<h3><span id="队列初始化"> 队列初始化</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue_L</span><span class="params">(SqQueue *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*Q).base = (QElemType *)<span class="built_in">malloc</span>(MAXQSIZE*<span class="keyword">sizeof</span>(QElemType));</span><br><span class="line">	<span class="keyword">if</span>(!((*Q).base))</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	</span><br><span class="line">	(*Q).front = (*Q).rear = <span class="number">0</span>;</span><br><span class="line">	(*Q).tag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="入队"> 入队</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue_L</span><span class="params">(SqQueue *Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((*Q).rear==(*Q).front &amp;&amp; (*Q).tag==<span class="number">1</span>)	<span class="comment">//队列满</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	(*Q).base[(*Q).rear] = e;</span><br><span class="line">	(*Q).rear = ((*Q).rear+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((*Q).rear==(*Q).front)					<span class="comment">//入队后队满 </span></span><br><span class="line">		(*Q).tag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="出队"> 出队</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue_L</span><span class="params">(SqQueue *Q, QElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((*Q).front==(*Q).rear &amp;&amp; (*Q).tag==<span class="number">0</span>)	<span class="comment">//队列空</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	*e = (*Q).base[(*Q).front];</span><br><span class="line">	(*Q).front = ((*Q).front+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((*Q).rear==(*Q).front)					<span class="comment">//出队后队空 </span></span><br><span class="line">		(*Q).tag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="遍历队列"> 遍历队列</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Output_L</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=Q.front; i!=Q.rear; i=(i+<span class="number">1</span>)%MAXQSIZE)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, Q.base[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="堆串"> 堆串</span></h2>
<h3><span id="类型定义"> 类型定义</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 串的堆存储表示 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *ch;							<span class="comment">//若是非空串，则按串长分配存储区，否则ch为NULL </span></span><br><span class="line">	<span class="keyword">int</span> length;</span><br><span class="line">&#125;HString;</span><br></pre></td></tr></table></figure>
<h3><span id="初始化s为空串"> 初始化S为空串</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitString_H</span><span class="params">(HString *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*S).ch = <span class="literal">NULL</span>;</span><br><span class="line">	(*S).length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="生成一个其值等于常量chars的串t"> 生成一个其值等于常量chars的串T</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrAssign_H</span><span class="params">(HString *T, <span class="keyword">char</span> *chars)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	</span><br><span class="line">	InitString_H(T);	</span><br><span class="line"></span><br><span class="line">	i = <span class="built_in">strlen</span>(chars);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!i)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		(*T).ch = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(i*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));		</span><br><span class="line">		<span class="keyword">if</span>(!((*T).ch))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">			(*T).ch[j] = chars[j];</span><br><span class="line">			</span><br><span class="line">		(*T).length = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="由串s复制得到串t"> 由串S复制得到串T</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrCopy_H</span><span class="params">(HString *T, HString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">	InitString_H(T);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(StrEmpty_H(S))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">		</span><br><span class="line">	(*T).ch = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(S.length*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="keyword">if</span>(!(*T).ch)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;S.length; i++)</span><br><span class="line">		(*T).ch[i] = S.ch[i];</span><br><span class="line">	</span><br><span class="line">	(*T).length = S.length;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="若s为空串返回true否则返回false"> 若S为空串，返回TRUE,否则返回FALSE</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrEmpty_H</span><span class="params">(HString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.length==<span class="number">0</span> &amp;&amp; S.ch==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="若sgtt返回值gt0若sltt返回值lt0否则返回值0"> 若S&gt;T，返回值&gt;0；若S&lt;T，返回值&lt;0；否则，返回值=0</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrCompare_H</span><span class="params">(HString S, HString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;S.length&amp;&amp;i&lt;T.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(S.ch[i]!=T.ch[i])</span><br><span class="line">			<span class="keyword">return</span> S.ch[i]-T.ch[i];	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> S.length-T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="求串长"> 求串长</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrLength_H</span><span class="params">(HString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(StrEmpty_H(S))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> S.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="清空串s"> 清空串S</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearString_H</span><span class="params">(HString *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((*S).ch)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>((*S).ch);</span><br><span class="line">		(*S).ch = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	(*S).length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="用t返回由s1和s2联接而成的新串"> 用T返回由S1和S2联接而成的新串</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Concat_H</span><span class="params">(HString *T, HString S1, HString S2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">	InitString_H(T);</span><br><span class="line">	</span><br><span class="line">	(*T).length = S1.length + S2.length;</span><br><span class="line">	</span><br><span class="line">	(*T).ch = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>((*T).length*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="keyword">if</span>(!(*T).ch)</span><br><span class="line">		<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;S1.length; i++)</span><br><span class="line">		(*T).ch[i] = S1.ch[i];</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;S2.length; i++)</span><br><span class="line">		(*T).ch[S1.length+i] = S2.ch[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="用sub返回串s的第pos个字符起长度为len的子串"> 用Sub返回串S的第pos个字符起长度为len的子串</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SubString_H</span><span class="params">(HString *Sub, HString S, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">	InitString_H(Sub);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(StrEmpty_H(S))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pos&lt;<span class="number">1</span> || pos&gt;S.length || len&lt;<span class="number">0</span> || pos+len<span class="number">-1</span>&gt;S.length)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len)								<span class="comment">//非空子串</span></span><br><span class="line">	&#123;</span><br><span class="line">		(*Sub).ch = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(len*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">		<span class="keyword">if</span>(!(*Sub).ch)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">			(*Sub).ch[i] = S.ch[i+pos<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">		(*Sub).length = len;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="返回t在s中第pos个字符后第一次出现的位置不存在则返回0"> 返回T在S中第pos个字符后第一次出现的位置，不存在则返回0</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_H</span><span class="params">(HString S, HString T, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s, t, i;</span><br><span class="line">	HString Sub;</span><br><span class="line">	</span><br><span class="line">	InitString_H(&amp;Sub);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pos&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		s = S.length;</span><br><span class="line">		t = T.length;</span><br><span class="line">		i = pos;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(i+t<span class="number">-1</span>&lt;=s)</span><br><span class="line">		&#123;</span><br><span class="line">			SubString_H(&amp;Sub, S, i, t);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(StrCompare_H(Sub, T))</span><br><span class="line">				i++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="用v替换主串s中出现的所有与t相等的不重叠的子串"> 用V替换主串S中出现的所有与T相等的不重叠的子串</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Replace_H</span><span class="params">(HString *S, HString T, HString V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(StrEmpty_H(T))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">		</span><br><span class="line">	i = Index_H(*S, T, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(i!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		StrDelete_H(S, i, StrLength_H(T));</span><br><span class="line"></span><br><span class="line">		StrInsert_H(S, i, V);</span><br><span class="line"></span><br><span class="line">		i += StrLength_H(V);</span><br><span class="line"></span><br><span class="line">		i = Index_H(*S, T, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="在串s的第pos个字符之前插入串t"> 在串S的第pos个字符之前插入串T</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrInsert_H</span><span class="params">(HString *S, <span class="keyword">int</span> pos, HString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pos&lt;<span class="number">1</span> || pos&gt;(*S).length+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(StrEmpty_H(T))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		(*S).ch = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>((*S).ch, ((*S).length+T.length)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">		<span class="keyword">if</span>(!(*S).ch)</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(i=(*S).length<span class="number">-1</span>; i&gt;=pos<span class="number">-1</span>; i--)		<span class="comment">//为插入T而腾出位置</span></span><br><span class="line">			(*S).ch[i+T.length] = (*S).ch[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;T.length; i++)</span><br><span class="line">			(*S).ch[pos<span class="number">-1</span>+i] = T.ch[i]; 		<span class="comment">//插入T</span></span><br><span class="line"></span><br><span class="line">		(*S).length += T.length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="从串s中删除第pos个字符起长度为len的子串"> 从串S中删除第pos个字符起长度为len的子串</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">StrDelete_H</span><span class="params">(HString *S, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(StrEmpty_H(*S))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(pos&lt;<span class="number">1</span> || pos+len<span class="number">-1</span>&gt;(*S).length ||len&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=pos<span class="number">-1</span>; i+len&lt;=(*S).length; i++)</span><br><span class="line">		(*S).ch[i] = (*S).ch[i+len];</span><br><span class="line"></span><br><span class="line">	(*S).length -= len;</span><br><span class="line"></span><br><span class="line">	(*S).ch = (<span class="keyword">char</span>*)<span class="built_in">realloc</span>((*S).ch, (*S).length*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));	<span class="comment">//缩小分配的空间 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="销毁串s"> 销毁串S</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyString_H</span><span class="params">(HString *S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//堆串不能被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="输出串s"> 输出串S</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrPrint_H</span><span class="params">(HString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(StrEmpty_H(S))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"S为空串，不可输出！"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;S.length; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>, S.ch[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="数组和广义表"> 数组和广义表</span></h2>
<h3><span id="类型定义"> 类型定义</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 400							<span class="comment">//假设非零元个数的最大值为400</span></span></span><br></pre></td></tr></table></figure>
<h3><span id="三元组顺序表稀疏矩阵类型定义"> 三元组顺序表(稀疏矩阵)类型定义</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> MElemType_TSq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> i, j;								<span class="comment">//该非零元的行下标和列下标 </span></span><br><span class="line">	MElemType_TSq e;</span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	Triple data[MAXSIZE+<span class="number">1</span>];					<span class="comment">//非零元三元组表，data[0]未用</span></span><br><span class="line">	<span class="keyword">int</span> mu, nu, tu;							<span class="comment">//矩阵的行数、列数和非零元个数</span></span><br><span class="line">&#125;TSMatrix;</span><br></pre></td></tr></table></figure>
<h3><span id="创建n个矩阵"> 创建n个矩阵</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateSMatrix_T</span><span class="params">(FILE *fp, <span class="keyword">int</span> n, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count, k;</span><br><span class="line">	TSMatrix *M;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	va_list ap;	</span><br><span class="line">	va_start(ap, n);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(count=<span class="number">1</span>; count&lt;=n; count++)</span><br><span class="line">	&#123;</span><br><span class="line">		M = va_arg(ap, TSMatrix*);</span><br><span class="line">		</span><br><span class="line">		Scanf(fp, <span class="string">"%d%d%d"</span>, &amp;((*M).mu), &amp;((*M).nu), &amp;((*M).tu));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;=(*M).tu; k++)</span><br><span class="line">			Scanf(fp, <span class="string">"%d%d%d"</span>, &amp;((*M).data[k].i), &amp;((*M).data[k].j), &amp;((*M).data[k].e));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	va_end(ap);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="销毁矩阵"> 销毁矩阵</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroySMatrix_T</span><span class="params">(TSMatrix *M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*M).mu = <span class="number">0</span>;</span><br><span class="line">	(*M).nu = <span class="number">0</span>;</span><br><span class="line">	(*M).tu = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="输出矩阵"> 输出矩阵</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintSMatrix_T</span><span class="params">(TSMatrix M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> r, c;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(r=<span class="number">1</span>; r&lt;=M.mu; r++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(c=<span class="number">1</span>; c&lt;=M.nu; c++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(r==M.data[k].i &amp;&amp; c==M.data[k].j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%3d "</span>, M.data[k].e);</span><br><span class="line">				k++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"  0 "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="矩阵的复制"> 矩阵的复制</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CopySMatrix_T</span><span class="params">(TSMatrix M, TSMatrix *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(*T) = M;								<span class="comment">//结构可以直接复制 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="矩阵的加法q-m-n"> 矩阵的加法Q = M + N</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">AddSMatri_T</span><span class="params">(TSMatrix M, TSMatrix N, TSMatrix *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, n, k;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(M.mu!=N.mu || M.nu!=N.nu)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"两矩阵不能相加！！\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Q-&gt;mu = M.mu;</span><br><span class="line">	Q-&gt;nu = M.nu;</span><br><span class="line">	Q-&gt;tu = <span class="number">0</span>;</span><br><span class="line">	m = n = k = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m&lt;=M.tu &amp;&amp; n&lt;=N.tu)				<span class="comment">//依次遍历M与N的三元组 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(M.data[m].i&lt;N.data[n].i)</span><br><span class="line">		&#123;</span><br><span class="line">			Q-&gt;data[k] = M.data[m];</span><br><span class="line">			m++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(M.data[m].i&gt;N.data[n].i)</span><br><span class="line">		&#123;</span><br><span class="line">			Q-&gt;data[k] = N.data[n];</span><br><span class="line">			n++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>								<span class="comment">//M.data[m].i==N.data[n].i</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(M.data[m].j&lt;N.data[n].j)</span><br><span class="line">			&#123;</span><br><span class="line">				Q-&gt;data[k] = M.data[m];</span><br><span class="line">				m++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(M.data[m].j&gt;N.data[n].j)</span><br><span class="line">			&#123;</span><br><span class="line">				Q-&gt;data[k] = N.data[n];</span><br><span class="line">				n++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>							<span class="comment">//M.data[m].j==N.data[n].j</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(M.data[m].e+N.data[n].e)</span><br><span class="line">				&#123;</span><br><span class="line">					Q-&gt;data[k].i = M.data[m].i;</span><br><span class="line">					Q-&gt;data[k].j = M.data[m].j;</span><br><span class="line">					Q-&gt;data[k].e = M.data[m].e + N.data[n].e;</span><br><span class="line">					m++;</span><br><span class="line">					n++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					m++;</span><br><span class="line">					n++;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		k++;</span><br><span class="line">		Q-&gt;tu++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m&lt;=M.tu)</span><br><span class="line">	&#123;</span><br><span class="line">		Q-&gt;data[k] = M.data[m];</span><br><span class="line">		m++;</span><br><span class="line">		k++;</span><br><span class="line">		Q-&gt;tu++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(n&lt;=N.tu)</span><br><span class="line">	&#123;</span><br><span class="line">		Q-&gt;data[k] = N.data[n];</span><br><span class="line">		n++;</span><br><span class="line">		k++;</span><br><span class="line">		Q-&gt;tu++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="矩阵的减法q-m-n"> 矩阵的减法Q = M - N</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SubSMatrix_T</span><span class="params">(TSMatrix M, TSMatrix N, TSMatrix *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, n, k;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(M.mu!=N.mu || M.nu!=N.nu)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"两矩阵不能相减！！\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Q-&gt;mu = M.mu;</span><br><span class="line">	Q-&gt;nu = M.nu;</span><br><span class="line">	Q-&gt;tu = <span class="number">0</span>;</span><br><span class="line">	m = n = k = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m&lt;=M.tu &amp;&amp; n&lt;=N.tu)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(M.data[m].i&lt;N.data[n].i)</span><br><span class="line">		&#123;</span><br><span class="line">			Q-&gt;data[k] = M.data[m];</span><br><span class="line">			m++;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(M.data[m].i&gt;N.data[n].i)</span><br><span class="line">		&#123;</span><br><span class="line">			Q-&gt;data[k].i =  N.data[n].i;</span><br><span class="line">			Q-&gt;data[k].j =  N.data[n].j;</span><br><span class="line">			Q-&gt;data[k].e = -N.data[n].e;</span><br><span class="line">			n++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>								<span class="comment">//M.data[m].i==N.data[n].i</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(M.data[m].j&lt;N.data[n].j)</span><br><span class="line">			&#123;</span><br><span class="line">				Q-&gt;data[k] = M.data[m];</span><br><span class="line">				m++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(M.data[m].j&gt;N.data[n].j)</span><br><span class="line">			&#123;</span><br><span class="line">				Q-&gt;data[k].i =  N.data[n].i;</span><br><span class="line">				Q-&gt;data[k].j =  N.data[n].j;</span><br><span class="line">				Q-&gt;data[k].e = -N.data[n].e;</span><br><span class="line">				n++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>							<span class="comment">//M.data[m].j==N.data[n].j</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(M.data[m].e-N.data[n].e)</span><br><span class="line">				&#123;</span><br><span class="line">					Q-&gt;data[k].i = M.data[m].i;</span><br><span class="line">					Q-&gt;data[k].j = M.data[m].j;</span><br><span class="line">					Q-&gt;data[k].e = M.data[m].e - N.data[n].e;</span><br><span class="line">					m++;</span><br><span class="line">					n++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					m++;</span><br><span class="line">					n++;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;		</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		k++;</span><br><span class="line">		Q-&gt;tu++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m&lt;=M.tu)</span><br><span class="line">	&#123;</span><br><span class="line">		Q-&gt;data[k] = M.data[m];</span><br><span class="line">		m++;</span><br><span class="line">		k++;</span><br><span class="line">		Q-&gt;tu++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(n&lt;=N.tu)</span><br><span class="line">	&#123;</span><br><span class="line">		Q-&gt;data[k].i =  N.data[n].i;</span><br><span class="line">		Q-&gt;data[k].j =  N.data[n].j;</span><br><span class="line">		Q-&gt;data[k].e = -N.data[n].e;;</span><br><span class="line">		n++;</span><br><span class="line">		k++;</span><br><span class="line">		Q-&gt;tu++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="矩阵的乘法q-m-n"> 矩阵的乘法Q = M * N</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">MultSMatrix_T</span><span class="params">(TSMatrix M, TSMatrix N, TSMatrix *Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, n, i, j, k;</span><br><span class="line">	MElemType_TSq c, c1, c2;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(M.nu!=N.mu)							<span class="comment">//M列数等于N行数 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"两矩阵不能相乘！！\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> ERROR;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Q-&gt;mu = M.mu;							<span class="comment">//Q初始化 </span></span><br><span class="line">	Q-&gt;nu = N.nu;</span><br><span class="line">	Q-&gt;tu = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(M.tu*N.tu)							<span class="comment">//Q是非零矩阵</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=M.mu; i++)				<span class="comment">//传统矩阵乘法 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=N.nu; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				c = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;=M.nu; k++)</span><br><span class="line">				&#123;</span><br><span class="line">					c1 = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;=M.tu; m++)	<span class="comment">//依次寻找位于指定位置的M三元组 </span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(M.data[m].i==i &amp;&amp; M.data[m].j==k)</span><br><span class="line">						&#123;</span><br><span class="line">							c1 = M.data[m].e;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					c2 = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span>(n=<span class="number">1</span>; n&lt;=N.tu; n++)	<span class="comment">//依次寻找位于指定位置的N三元组</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(N.data[n].i==k &amp;&amp; N.data[n].j==j)</span><br><span class="line">						&#123;</span><br><span class="line">							c2 = N.data[n].e;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span>(c1 &amp;&amp; c2)</span><br><span class="line">						c += c1 * c2;	</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(c)</span><br><span class="line">				&#123;</span><br><span class="line">					Q-&gt;tu++;</span><br><span class="line">					Q-&gt;data[Q-&gt;tu].i = i;</span><br><span class="line">					Q-&gt;data[Q-&gt;tu].j = j;</span><br><span class="line">					Q-&gt;data[Q-&gt;tu].e = c;</span><br><span class="line">				&#125;			</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="矩阵转置"> 矩阵转置</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TransposeSMatrix_T</span><span class="params">(TSMatrix M, TSMatrix *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p, q, col;</span><br><span class="line">	</span><br><span class="line">	T-&gt;mu = M.nu;</span><br><span class="line">	T-&gt;nu = M.mu;</span><br><span class="line">	T-&gt;tu = M.tu;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T-&gt;tu)</span><br><span class="line">	&#123;</span><br><span class="line">		q = <span class="number">1</span>;									<span class="comment">//q用于T中非零元计数 </span></span><br><span class="line">		<span class="keyword">for</span>(col=<span class="number">1</span>; col&lt;=M.nu; ++col)			<span class="comment">//col代表M的列，T的行 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(p=<span class="number">1</span>; p&lt;=M.tu; ++p)				<span class="comment">//p用于M中非零元计数</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(M.data[p].j==col)</span><br><span class="line">				&#123;</span><br><span class="line">					T-&gt;data[q].i = M.data[p].j;	<span class="comment">//M的列变为T的行 </span></span><br><span class="line">					T-&gt;data[q].j = M.data[p].i;	<span class="comment">//M的行变为T的列</span></span><br><span class="line">					T-&gt;data[q].e = M.data[p].e;	<span class="comment">//每个三元组值不变</span></span><br><span class="line">					++q; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="矩阵快速转置"> 矩阵快速转置</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FastTransposeSMatrix_T</span><span class="params">(TSMatrix M, TSMatrix *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> col, t, p, q;</span><br><span class="line">	<span class="keyword">int</span> num[M.nu];							<span class="comment">//num[col]表示M第col列中非零元的个数 </span></span><br><span class="line">	<span class="keyword">int</span> copt[M.nu];							<span class="comment">//copt[col]表示M第col列第一个非零元在T-&gt;data中恰当的位置 </span></span><br><span class="line">	</span><br><span class="line">	T-&gt;mu = M.nu;</span><br><span class="line">	T-&gt;nu = M.mu;</span><br><span class="line">	T-&gt;tu = M.tu;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T-&gt;tu)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(col=<span class="number">1</span>; col&lt;=M.nu; ++col)</span><br><span class="line">			num[col] = <span class="number">0</span>;					<span class="comment">//初始化数组num</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(t=<span class="number">1</span>; t&lt;=M.tu; ++t)				<span class="comment">//t遍历M中三元组</span></span><br><span class="line">			num[M.data[t].j]++;				<span class="comment">//统计M中每列非零元个数</span></span><br><span class="line">		</span><br><span class="line">		copt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(col=<span class="number">2</span>; col&lt;=M.nu; ++col)</span><br><span class="line">			copt[col] = copt[col<span class="number">-1</span>] + num[col<span class="number">-1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(p=<span class="number">1</span>; p&lt;=M.tu; ++p)				<span class="comment">//依次扫描M中的三元组 </span></span><br><span class="line">		&#123;</span><br><span class="line">			col = M.data[p].j;				<span class="comment">//col为M中第p个三元组中元素的列 </span></span><br><span class="line">			q = copt[col];					<span class="comment">//q为当前三元组元素在T中应放置的位置 </span></span><br><span class="line">			T-&gt;data[q].i = M.data[p].j;</span><br><span class="line">			T-&gt;data[q].j = M.data[p].i;</span><br><span class="line">			T-&gt;data[q].e = M.data[p].e;</span><br><span class="line">			++copt[col];					<span class="comment">//再遇到此列元素时位置增一 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="树和二叉树"> 树和二叉树</span></h2>
<h3><span id="二叉树二叉链表存储相关类型定义"> 二叉树（二叉链表存储）相关类型定义</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;							<span class="comment">//假设二叉树元素均为字符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TElemType data;								<span class="comment">//结点元素 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>;</span>						<span class="comment">//左孩子指针 </span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">rchild</span>;</span>						<span class="comment">//右孩子指针 </span></span><br><span class="line">&#125;BiTNode;										<span class="comment">//二叉树结点 </span></span><br><span class="line"><span class="keyword">typedef</span> BiTNode* BiTree;						<span class="comment">//指向二叉树结点的指针</span></span><br></pre></td></tr></table></figure>
<h4><span id="栈元素类型"> 栈元素类型</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> BiTree SElemType_Sq;					<span class="comment">//重定义栈元素类型 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../../▲03 栈和队列/01 SequenceStack/SequenceStack.c"</span>	<span class="comment">//**▲03 栈和队列**// </span></span></span><br><span class="line"></span><br><span class="line">要用到栈的类型定义</span><br></pre></td></tr></table></figure>
<h4><span id="存储当前结点信息按树结构打印树的时候使用"> 存储当前结点信息，按树结构打印树的时候使用</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>									</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	BiTree left;								<span class="comment">//当前结点的左指针 </span></span><br><span class="line">	BiTree right;								<span class="comment">//当前结点的右指针 </span></span><br><span class="line">	<span class="keyword">int</span> n;										<span class="comment">//当前结点的次序 </span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure>
<h3><span id="构造空二叉树t-初始化二叉树"> 构造空二叉树T (初始化二叉树)</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*T = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="清空二叉树t"> 清空二叉树T</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(*T)												 		<span class="comment">//二叉树不为空</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((*T)-&gt;lchild)										<span class="comment">//清空左树 </span></span><br><span class="line">			ClearBiTree(&amp;((*T)-&gt;lchild));							</span><br><span class="line">		<span class="keyword">if</span>((*T)-&gt;rchild)										<span class="comment">//清空右树 </span></span><br><span class="line">			ClearBiTree(&amp;((*T)-&gt;rchild));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">free</span>(*T);												<span class="comment">//释放根结点 </span></span><br><span class="line">		</span><br><span class="line">		*T = <span class="literal">NULL</span>;												<span class="comment">//置空树指针 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="销毁二叉树t"> 销毁二叉树T</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyBiTree</span><span class="params">(BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//二叉树无法销毁 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="判断二叉树t是否为空"> 判断二叉树T是否为空</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BiTreeEmpty</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> T==<span class="literal">NULL</span> ? TRUE : ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="按先序序列构造二叉树_1"> 按先序序列构造二叉树_1</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(FILE *fp, BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">	Scanf(fp, <span class="string">"%c"</span>, &amp;ch);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(ch == <span class="string">'^'</span>)</span><br><span class="line">		*T = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		*T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		<span class="keyword">if</span>(!(*T))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		(*T)-&gt;data = ch;</span><br><span class="line">		CreateBiTree(fp, &amp;(*T)-&gt;lchild);</span><br><span class="line">		CreateBiTree(fp, &amp;(*T)-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="按先序序列构造二叉树_2"> 按先序序列构造二叉树_2</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">f</span><span class="params">(FILE *fp, BiTree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">	Scanf(fp, <span class="string">"%c"</span>, &amp;ch);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(ch == <span class="string">'^'</span>)</span><br><span class="line">		*T = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		*T = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">		<span class="keyword">if</span>(!(*T))</span><br><span class="line">			<span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">		(*T)-&gt;data = ch;</span><br><span class="line">		CreateBiTree(fp, &amp;(*T)-&gt;lchild);</span><br><span class="line">		CreateBiTree(fp, &amp;(*T)-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="返回二叉树长度按完全二叉树计算"> 返回二叉树长度（按完全二叉树计算）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTreeLength</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node node[<span class="number">100</span>];												<span class="comment">//存储结点信息 </span></span><br><span class="line">	<span class="keyword">int</span> i, len;</span><br><span class="line">	</span><br><span class="line">	i = len = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T)</span><br><span class="line">	&#123;	</span><br><span class="line">		node[i].left = T-&gt;lchild;</span><br><span class="line">		node[i].right = T-&gt;rchild;</span><br><span class="line">		node[i].n = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(node[i].n&gt;len)</span><br><span class="line">			len = node[i].n;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(node[i].left)									<span class="comment">//访问左子树 </span></span><br><span class="line">			&#123;</span><br><span class="line">				node[i+<span class="number">1</span>].left = node[i].left-&gt;lchild;</span><br><span class="line">				node[i+<span class="number">1</span>].right = node[i].left-&gt;rchild;</span><br><span class="line">				node[i+<span class="number">1</span>].n = <span class="number">2</span>*node[i].n;</span><br><span class="line">				node[i].left = <span class="literal">NULL</span>;</span><br><span class="line">				i++;</span><br><span class="line">				<span class="keyword">if</span>(node[i].n&gt;len)</span><br><span class="line">					len = node[i].n;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(node[i].right)									<span class="comment">//左子树为空时访问右子树 </span></span><br><span class="line">			&#123;</span><br><span class="line">				node[i+<span class="number">1</span>].left = node[i].right-&gt;lchild;</span><br><span class="line">				node[i+<span class="number">1</span>].right = node[i].right-&gt;rchild;</span><br><span class="line">				node[i+<span class="number">1</span>].n = <span class="number">2</span>*node[i].n+<span class="number">1</span>;</span><br><span class="line">				node[i].right = <span class="literal">NULL</span>;</span><br><span class="line">				i++;</span><br><span class="line">				<span class="keyword">if</span>(node[i].n&gt;len)</span><br><span class="line">					len = node[i].n;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(node[i].left==<span class="literal">NULL</span> &amp;&amp; node[i].right==<span class="literal">NULL</span>)</span><br><span class="line">				i--;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="返回二叉树深度层数"> 返回二叉树深度（层数）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BiTreeDepth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> LD, RD;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;								<span class="comment">//空树深度为0 </span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		LD = BiTreeDepth(T-&gt;lchild);			<span class="comment">//求左子树深度 </span></span><br><span class="line">		RD = BiTreeDepth(T-&gt;rchild);			<span class="comment">//求右子树深度 </span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">return</span> (LD&gt;=RD?LD:RD)+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="用e返回二叉树的根结点值"> 用e返回二叉树的根结点值</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Root</span><span class="params">(BiTree T, TElemType *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!T)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		*e = T-&gt;data;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="返回某结点的值p为结点指针"> 返回某结点的值，p为结点指针</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TElemType <span class="title">Value</span><span class="params">(BiTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="为某结点赋值p为结点指针"> 为某结点赋值，p为结点指针</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Assign</span><span class="params">(BiTree p, TElemType value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p-&gt;data = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="返回某结点的双亲结点值"> 返回某结点的双亲结点值</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TElemType <span class="title">Parent</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTNode node[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span> || (T!=<span class="literal">NULL</span> &amp;&amp; e==T-&gt;data))</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">	</span><br><span class="line">	node[i] = *T;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(node[i].lchild)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node[i].lchild-&gt;data==e)</span><br><span class="line">				<span class="keyword">return</span> node[i].data;</span><br><span class="line">			node[i+<span class="number">1</span>] = *(node[i].lchild);</span><br><span class="line">			node[i].lchild = <span class="literal">NULL</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(node[i].rchild)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node[i].rchild-&gt;data==e)</span><br><span class="line">				<span class="keyword">return</span> node[i].data;</span><br><span class="line">			node[i+<span class="number">1</span>] = *(node[i].rchild);</span><br><span class="line">			node[i].rchild = <span class="literal">NULL</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(node[i].lchild==<span class="literal">NULL</span> &amp;&amp; node[i].rchild==<span class="literal">NULL</span>)</span><br><span class="line">			i--;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'\0'</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="返回某结点的左孩子结点值"> 返回某结点的左孩子结点值</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TElemType <span class="title">LeftChild</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTNode node[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!T)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">	</span><br><span class="line">	node[i] = *T;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(node[i].data!=e &amp;&amp; node[i].lchild)</span><br><span class="line">		&#123;</span><br><span class="line">			node[i+<span class="number">1</span>] = *(node[i].lchild);</span><br><span class="line">			node[i].lchild = <span class="literal">NULL</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(node[i].data==e)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node[i].lchild)</span><br><span class="line">				<span class="keyword">return</span> node[i].lchild-&gt;data;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="string">'\0'</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(node[i].rchild)</span><br><span class="line">		&#123;</span><br><span class="line">			node[i+<span class="number">1</span>] = *(node[i].rchild);</span><br><span class="line">			node[i].rchild = <span class="literal">NULL</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(node[i].lchild==<span class="literal">NULL</span> &amp;&amp; node[i].rchild==<span class="literal">NULL</span> &amp;&amp; node[i].data!=e)</span><br><span class="line">			i--;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'\0'</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="返回某结点的右孩子结点值"> 返回某结点的右孩子结点值</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TElemType <span class="title">RightChild</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTNode node[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!T)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">	</span><br><span class="line">	node[i] = *T;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(node[i].data!=e &amp;&amp; node[i].lchild)</span><br><span class="line">		&#123;</span><br><span class="line">			node[i+<span class="number">1</span>] = *(node[i].lchild);</span><br><span class="line">			node[i].lchild = <span class="literal">NULL</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(node[i].data==e)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node[i].rchild)</span><br><span class="line">				<span class="keyword">return</span> node[i].rchild-&gt;data;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="string">'\0'</span>;		</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(node[i].rchild)</span><br><span class="line">		&#123;</span><br><span class="line">			node[i+<span class="number">1</span>] = *(node[i].rchild);</span><br><span class="line">			node[i].rchild = <span class="literal">NULL</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="keyword">if</span>(node[i].lchild==<span class="literal">NULL</span> &amp;&amp; node[i].rchild==<span class="literal">NULL</span>)</span><br><span class="line">			i--;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="返回某结点的左兄弟结点值"> 返回某结点的左兄弟结点值</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TElemType <span class="title">LeftSibling</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTNode node[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span> || (T!=<span class="literal">NULL</span> &amp;&amp; e==T-&gt;data))</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">	</span><br><span class="line">	node[i] = *T;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(node[i].rchild)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node[i].rchild-&gt;data==e)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(node[i].lchild)</span><br><span class="line">					<span class="keyword">return</span> node[i].lchild-&gt;data;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			node[i+<span class="number">1</span>] = *(node[i].rchild);</span><br><span class="line">			node[i].rchild = <span class="literal">NULL</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(node[i].lchild)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node[i].lchild-&gt;data==e)</span><br><span class="line">				<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">			node[i+<span class="number">1</span>] = *(node[i].lchild);</span><br><span class="line">			node[i].lchild = <span class="literal">NULL</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(node[i].lchild==<span class="literal">NULL</span> &amp;&amp; node[i].rchild==<span class="literal">NULL</span>)</span><br><span class="line">			i--;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="返回某结点的右兄弟结点值"> 返回某结点的右兄弟结点值</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TElemType <span class="title">RightSibling</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTNode node[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span> || (T!=<span class="literal">NULL</span> &amp;&amp; e==T-&gt;data))</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">	</span><br><span class="line">	node[i] = *T;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(node[i].lchild)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node[i].lchild-&gt;data==e)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(node[i].rchild)</span><br><span class="line">					<span class="keyword">return</span> node[i].rchild-&gt;data;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			node[i+<span class="number">1</span>] = *(node[i].lchild);</span><br><span class="line">			node[i].lchild = <span class="literal">NULL</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(node[i].rchild)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node[i].rchild-&gt;data==e)</span><br><span class="line">				<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">			node[i+<span class="number">1</span>] = *(node[i].rchild);</span><br><span class="line">			node[i].rchild = <span class="literal">NULL</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(node[i].lchild==<span class="literal">NULL</span> &amp;&amp; node[i].rchild==<span class="literal">NULL</span>)</span><br><span class="line">			i--;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="获取指向结点e的指针_1"> 获取指向结点e的指针_1</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">LocationBiTree_1</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTNode node[<span class="number">100</span>];</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T-&gt;data==e)</span><br><span class="line">		<span class="keyword">return</span> T;</span><br><span class="line"></span><br><span class="line">	node[i] = *T;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(node[i].lchild)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node[i].lchild-&gt;data==e)</span><br><span class="line">				<span class="keyword">return</span> node[i].lchild;</span><br><span class="line">			node[i+<span class="number">1</span>] = *(node[i].lchild);</span><br><span class="line">			node[i].lchild = <span class="literal">NULL</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(node[i].rchild)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(node[i].rchild-&gt;data==e)</span><br><span class="line">				<span class="keyword">return</span> node[i].rchild;</span><br><span class="line">			node[i+<span class="number">1</span>] = *(node[i].rchild);</span><br><span class="line">			node[i].rchild = <span class="literal">NULL</span>;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(node[i].lchild==<span class="literal">NULL</span> &amp;&amp; node[i].rchild==<span class="literal">NULL</span>)</span><br><span class="line">			i--;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="获取指向结点e的指针_2"> 获取指向结点e的指针_2</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiTree <span class="title">LocationBiTree_2</span><span class="params">(BiTree T, TElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree p = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(T-&gt;data==e)</span><br><span class="line">			p = T;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(p=LocationBiTree_2(T-&gt;lchild, e))</span><br><span class="line">				<span class="keyword">return</span> p;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(p=LocationBiTree_2(T-&gt;rchild, e))</span><br><span class="line">				<span class="keyword">return</span> p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="将树t0插入到树t中成为结点e的子树lr为插入标记t0只有左子树"> 将树T0插入到树T中成为结点e的子树，LR为插入标记，T0只有左子树</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InsertBiTree</span><span class="params">(BiTree T, TElemType e, BiTree T0, <span class="keyword">int</span> LR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree p = LocationBiTree_1(T, e);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">		T0-&gt;rchild = LR ? p-&gt;rchild : p-&gt;lchild;</span><br><span class="line">		LR ? (p-&gt;rchild=T0) : (p-&gt;lchild=T0);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ERROR;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="删除e结点的左子树或右子树lr为删除标记"> 删除e结点的左子树或右子树，LR为删除标记</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteBiTree</span><span class="params">(BiTree T, TElemType e, <span class="keyword">int</span> LR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree p = LocationBiTree_2(T, e);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(p)</span><br><span class="line">	&#123;</span><br><span class="line">		LR ? ClearBiTree(&amp;(p-&gt;rchild)) : ClearBiTree(&amp;(p-&gt;lchild));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="层序遍历二叉树_1利用数组实现"> 层序遍历二叉树_1（利用数组实现）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse_1</span><span class="params">(BiTree T, <span class="keyword">void</span>(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	BiTree p[<span class="number">100</span>];					<span class="comment">//树指针数组</span></span><br><span class="line">	</span><br><span class="line">	i = j = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T)</span><br><span class="line">		p[j++] = T;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)</span><br><span class="line">	&#123;</span><br><span class="line">		Visit(p[i]-&gt;data);</span><br><span class="line">		<span class="keyword">if</span>(p[i]-&gt;lchild)</span><br><span class="line">			p[j++] = p[i]-&gt;lchild;</span><br><span class="line">		<span class="keyword">if</span>(p[i]-&gt;rchild)</span><br><span class="line">			p[j++] = p[i]-&gt;rchild;</span><br><span class="line">		i++;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="层序遍历二叉树_2利用队列实现"> 层序遍历二叉树_2（利用队列实现）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LevelOrderTraverse_2</span><span class="params">(BiTree T, Status (*visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BiTree p;</span><br><span class="line">	LinkQueue Q;</span><br><span class="line">	InitQueue(Q);</span><br><span class="line">	p = T;</span><br><span class="line">	<span class="keyword">while</span> (p || !QueueEmpty(Q))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p)</span><br><span class="line">		&#123;</span><br><span class="line">			visit(p-&gt;data);</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;lchild)</span><br><span class="line">				EnQueue(Q, p-&gt;lchild);</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;rchild)</span><br><span class="line">				EnQueue(Q, p-&gt;rchild);</span><br><span class="line">			<span class="keyword">if</span> (!QueueEmpty(Q))</span><br><span class="line">				DeQueue(Q, p);</span><br><span class="line">			<span class="keyword">else</span>		<span class="comment">//队列为空时，退出while循环</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="先序遍历二叉树_1递归"> 先序遍历二叉树_1（递归）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse_1</span><span class="params">(BiTree T, <span class="keyword">void</span>(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T)</span><br><span class="line">	&#123;</span><br><span class="line">		Visit(T-&gt;data);</span><br><span class="line">		PreOrderTraverse_1(T-&gt;lchild, Visit);</span><br><span class="line">		PreOrderTraverse_1(T-&gt;rchild, Visit);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="先序遍历二叉树_2递归"> 先序遍历二叉树_2（递归）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PreOrderTraverse_2</span><span class="params">(BiTree T, Status(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">if</span>(T)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(Visit(T-&gt;data))</span><br><span class="line">		&#123;</span><br><span class="line">			PreOrderTraverse_2(T-&gt;lchild, Visit);</span><br><span class="line">			PreOrderTraverse_2(T-&gt;rchild, Visit);	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="先序遍历二叉树_1非递归"> 先序遍历二叉树_1（非递归）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse_3</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	SElemType_Sq e;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!BiTreeEmpty(T))</span><br><span class="line">	&#123;</span><br><span class="line">		InitStack_Sq(&amp;S);</span><br><span class="line">		Push_Sq(&amp;S, T);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(!StackEmpty_Sq(S))</span><br><span class="line">		&#123;</span><br><span class="line">			GetTop_Sq(S, &amp;e);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c "</span>, e-&gt;data);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(e-&gt;lchild)</span><br><span class="line">				Push_Sq(&amp;S, e-&gt;lchild);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">while</span>(!StackEmpty_Sq(S))</span><br><span class="line">				&#123;</span><br><span class="line">					Pop_Sq(&amp;S, &amp;e);</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">if</span>(e-&gt;rchild)</span><br><span class="line">					&#123;</span><br><span class="line">						Push_Sq(&amp;S, e-&gt;rchild);</span><br><span class="line">						<span class="keyword">break</span>;					</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="先序遍历二叉树_2非递归"> 先序遍历二叉树_2（非递归）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PreOrderTraverse_4</span><span class="params">(BiTree T, Status (*visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	BiTree p;</span><br><span class="line">	InitStack(S);</span><br><span class="line">	p = T;</span><br><span class="line">	<span class="keyword">while</span> (p || !StackEmpty(S))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p)  	<span class="comment">//访问根指针，左指针进栈</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (ERROR == visit(p-&gt;data))</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			Push(S, p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			Pop(S, p);</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="中序遍历二叉树_1递归"> 中序遍历二叉树_1（递归）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse_1</span><span class="params">(BiTree T, <span class="keyword">void</span>(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T)</span><br><span class="line">	&#123;</span><br><span class="line">		InOrderTraverse_1(T-&gt;lchild, Visit);</span><br><span class="line">		Visit(T-&gt;data);</span><br><span class="line">		InOrderTraverse_1(T-&gt;rchild, Visit);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="中序遍历二叉树_2非递归"> 中序遍历二叉树_2（非递归）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse_2</span><span class="params">(BiTree T, Status(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	SElemType_Sq p;</span><br><span class="line">	</span><br><span class="line">	InitStack_Sq(&amp;S);</span><br><span class="line">	Push_Sq(&amp;S, T);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!StackEmpty_Sq(S))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(GetTop_Sq(S, &amp;p) &amp;&amp; p)				<span class="comment">//栈顶元素不为空</span></span><br><span class="line">			Push_Sq(&amp;S, p-&gt;lchild);					<span class="comment">//向左走到尽头</span></span><br><span class="line">			</span><br><span class="line">		Pop_Sq(&amp;S, &amp;p);								<span class="comment">//空指针退栈</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(!StackEmpty_Sq(S))						<span class="comment">//访问结点，向右一步 </span></span><br><span class="line">		&#123;</span><br><span class="line">			Pop_Sq(&amp;S, &amp;p);</span><br><span class="line">			<span class="keyword">if</span>(!Visit(p-&gt;data))</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			Push_Sq(&amp;S, p-&gt;rchild);</span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="中序遍历二叉树_3非递归"> 中序遍历二叉树_3（非递归）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InOrderTraverse_3</span><span class="params">(BiTree T, Status(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	SElemType_Sq p;</span><br><span class="line">	</span><br><span class="line">	InitStack_Sq(&amp;S);</span><br><span class="line">	p = T;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(p || !StackEmpty_Sq(S))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(p)</span><br><span class="line">		&#123;</span><br><span class="line">			Push_Sq(&amp;S, p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			Pop_Sq(&amp;S, &amp;p);</span><br><span class="line">			<span class="keyword">if</span>(!Visit(p-&gt;data))</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="后序遍历二叉树递归"> 后序遍历二叉树（递归）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T, <span class="keyword">void</span>(Visit)(TElemType))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T)</span><br><span class="line">	&#123;</span><br><span class="line">		PostOrderTraverse(T-&gt;lchild, Visit);</span><br><span class="line">		PostOrderTraverse(T-&gt;rchild, Visit);</span><br><span class="line">		Visit(T-&gt;data);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="后序遍历二叉树_1非递归"> 后序遍历二叉树_1（非递归）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse_1</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	BiTree p;</span><br><span class="line">	SElemType_Sq e;</span><br><span class="line">	<span class="keyword">int</span> StackMark[<span class="number">100</span>] = &#123;&#125;;							<span class="comment">//模拟栈，设置各结点访问标记 </span></span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">	InitStack_Sq(&amp;S);</span><br><span class="line">	p = T;</span><br><span class="line">	k = <span class="number">-1</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(p)</span><br><span class="line">		&#123;</span><br><span class="line">			Push_Sq(&amp;S, p);</span><br><span class="line">			k++;</span><br><span class="line">			StackMark[k] = <span class="number">1</span>;</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">while</span>(!p &amp;&amp; !StackEmpty_Sq(S))			<span class="comment">//p为空但栈不为空 </span></span><br><span class="line">		&#123;</span><br><span class="line">			GetTop_Sq(S, &amp;p);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(StackMark[k]==<span class="number">1</span>)				<span class="comment">//已访问过一次，当前是第二次访问 </span></span><br><span class="line">			&#123;</span><br><span class="line">				StackMark[k] = <span class="number">2</span>;				</span><br><span class="line">				p = p-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>							<span class="comment">//已访问过两次，当前是第三次访问 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%c "</span>, p-&gt;data);</span><br><span class="line">				Pop_Sq(&amp;S, &amp;e);</span><br><span class="line">				StackMark[k] = <span class="number">0</span>;</span><br><span class="line">				k--;</span><br><span class="line">				p = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(StackEmpty_Sq(S))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="后序遍历二叉树_2非递归"> 后序遍历二叉树_2（非递归）</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PostOrderTraverse_2</span><span class="params">(BiTree T, Status (*visit)(TElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SqStack S;</span><br><span class="line">	InitStack(S);</span><br><span class="line">	BiTree p;</span><br><span class="line">	<span class="keyword">int</span> Tag[<span class="number">20</span>];	<span class="comment">//标志栈</span></span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	p = T;</span><br><span class="line">	<span class="keyword">while</span> (p || !StackEmpty(S))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (p)  	<span class="comment">//向左走到尽头</span></span><br><span class="line">		&#123;</span><br><span class="line">			Push(S, p);</span><br><span class="line">			p = p-&gt;lchild;</span><br><span class="line">			Tag[t++] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!StackEmpty(S) &amp;&amp; <span class="number">1</span> == Tag[t<span class="number">-1</span>])  	<span class="comment">//结点标志为1表示右子树已经访问过</span></span><br><span class="line">		&#123;</span><br><span class="line">			Pop(S, p);</span><br><span class="line">			t--;</span><br><span class="line">			<span class="keyword">if</span> (ERROR == visit(p-&gt;data))</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!StackEmpty(S))  	<span class="comment">//结点标志为0，则访问右子树，并将结点标志置为1</span></span><br><span class="line">		&#123;</span><br><span class="line">			Tag[t<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">			GetTop(S, p);</span><br><span class="line">			p = p-&gt;rchild;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="按二叉树的结构打印树"> 按二叉树的结构打印树</span></h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintTree</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> row, col;</span><br><span class="line">	<span class="keyword">int</span> i, j, m, l, r;</span><br><span class="line">	BiTNode a[<span class="number">100</span>][<span class="number">100</span>] = &#123;&#125;;					<span class="comment">//用一个足够大的矩阵按原样存储树 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T)</span><br><span class="line">	&#123;</span><br><span class="line">		row = BiTreeDepth(T);					<span class="comment">//总行数</span></span><br><span class="line">		col = <span class="built_in">pow</span>(<span class="number">2</span>, row) - <span class="number">1</span>;					<span class="comment">//总列数</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=row<span class="number">-1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=<span class="built_in">pow</span>(<span class="number">2</span>, i<span class="number">-1</span>); j++)</span><br><span class="line">			&#123;</span><br><span class="line">				m = (<span class="number">2</span>*j<span class="number">-1</span>)*<span class="built_in">pow</span>(<span class="number">2</span>, row-i);		<span class="comment">//当前行结点相对位序 </span></span><br><span class="line">				l = (<span class="number">4</span>*j<span class="number">-3</span>)*<span class="built_in">pow</span>(<span class="number">2</span>, row-i<span class="number">-1</span>);	<span class="comment">//下一行结点相对位序 </span></span><br><span class="line">				r = (<span class="number">4</span>*j<span class="number">-1</span>)*<span class="built_in">pow</span>(<span class="number">2</span>, row-i<span class="number">-1</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(i==<span class="number">1</span>)						<span class="comment">//初始化 </span></span><br><span class="line">					a[i][m] = *T;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(a[i][m].lchild)				<span class="comment">//下一行 </span></span><br><span class="line">					a[i+<span class="number">1</span>][l] = *(a[i][m].lchild);</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">if</span>(a[i][m].rchild)				<span class="comment">//下一行 </span></span><br><span class="line">					a[i+<span class="number">1</span>][r] = *(a[i][m].rchild);</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=row; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=col; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i][j].data)</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"%c"</span>, a[i][j].data);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="第四章数据结构算法描述"> 第四章	数据结构算法描述</span></h1>
<h2><span id="栈"> 栈</span></h2>
<h3><span id="中缀表达式转换成后缀表达式逆波兰式并对逆波兰表达式求值"> 中缀表达式转换成后缀表达式（逆波兰式），并对逆波兰表达式求值</span></h3>
<blockquote>
<p>[Question-3.21-main.c](E:\数据结构和算法\数据结构严蔚敏\Data-Structure-master\▼配套习题解析\▼03 栈和队列\▼习题测试文档-03\Question-3.21-main.c)</p>
</blockquote>
<blockquote>
<p>[Question-3.22-main.c](E:\数据结构和算法\数据结构严蔚敏\Data-Structure-master\▼配套习题解析\▼03 栈和队列\▼习题测试文档-03\Question-3.22-main.c)</p>
</blockquote>

        
      </div>
      
      
      
    </div>
    



    
    
    
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">DDDANBO</p>
              <div class="site-description motion-element" itemprop="description">将十四行诗写到大洋尽头</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text"> 第一章	常用算法杂项</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text"> 第二章	C语言程序设计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text"> 第三章	数据结构基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.1.</span> <span class="nav-text"> 预定义常量和类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.2.</span> <span class="nav-text"> Visit遍历函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.3.</span> <span class="nav-text"> 自定义Scanf函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.3.1.</span> <span class="nav-text"> 形参部分可以使用省略号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.3.2.</span> <span class="nav-text"> 引用 &lt;stdarg.h&gt; 头文件的va_list、va_start、va_arg、va_end</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">3.3.2.1.</span> <span class="nav-text"> va_start函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">3.3.2.2.</span> <span class="nav-text"> va_arg函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">3.3.2.3.</span> <span class="nav-text"> va_end函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.</span> <span class="nav-text"> 顺序线性表（数组）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.1.</span> <span class="nav-text"> 类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.2.</span> <span class="nav-text"> 初始化顺序线性表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.3.</span> <span class="nav-text"> 判断顺序表是否为空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.4.</span> <span class="nav-text"> 清空顺序表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.5.</span> <span class="nav-text"> 计算顺序表的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.6.</span> <span class="nav-text"> 用e返回L中第i个数据元素的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.7.</span> <span class="nav-text"> 返回L中第1个与e满足关系的数据元素的位序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.8.</span> <span class="nav-text"> 在L中第i个位置之前插入新的数据元素e</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.9.</span> <span class="nav-text"> 删除L的第i个数据元素，并用e返回其值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.10.</span> <span class="nav-text"> 遍历顺序线性表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.4.11.</span> <span class="nav-text"> 合并La、Lb两个顺序线性表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.5.</span> <span class="nav-text"> 静态链表（数组）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.5.1.</span> <span class="nav-text"> 类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.5.2.</span> <span class="nav-text"> 将一维数组space中各分量链成一个备用链表，space[0].cur为头指针，&quot;0&quot;表示空指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.5.3.</span> <span class="nav-text"> 若备用空间链表非空，则返回分配的结点下标，否则返回0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.5.4.</span> <span class="nav-text"> 将下标为k的空闲结点回收到备用链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.5.5.</span> <span class="nav-text"> 计算静态链表的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.5.6.</span> <span class="nav-text"> 在L中第i个元素之前插入新的数据元素e</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.5.7.</span> <span class="nav-text"> 删除在L中第i个数据元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.5.8.</span> <span class="nav-text"> 遍历静态链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.</span> <span class="nav-text"> 非循环单向线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.1.</span> <span class="nav-text"> 类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.2.</span> <span class="nav-text"> 初始化线性表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.3.</span> <span class="nav-text"> 清空线性表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.4.</span> <span class="nav-text"> 销毁线性表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.5.</span> <span class="nav-text"> 判断线性表是否为空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.6.</span> <span class="nav-text"> 计算线性表的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.7.</span> <span class="nav-text"> 用e接收顺序表L中第i个元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.8.</span> <span class="nav-text"> 返回顺序表L中首个与e满足Compare关系的元素位序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.9.</span> <span class="nav-text"> 用pre_e接收cur_e的前驱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.10.</span> <span class="nav-text"> 用next_e接收cur_e的后继</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.11.</span> <span class="nav-text"> 在顺序表L的第i个位置上插入e</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.12.</span> <span class="nav-text"> 删除顺序表L上第i个位置的元素，并用e返回</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.6.13.</span> <span class="nav-text"> 用visit函数访问顺序表L</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.7.</span> <span class="nav-text"> 单向循环链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.8.</span> <span class="nav-text"> 顺序栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.8.1.</span> <span class="nav-text"> 类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.8.2.</span> <span class="nav-text"> 栈的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.8.3.</span> <span class="nav-text"> 销毁栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.8.4.</span> <span class="nav-text"> 清空栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.8.5.</span> <span class="nav-text"> 判断栈是否为空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.8.6.</span> <span class="nav-text"> 计算栈的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.8.7.</span> <span class="nav-text"> 得到栈顶元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.8.8.</span> <span class="nav-text"> 入栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.8.9.</span> <span class="nav-text"> 出栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.8.10.</span> <span class="nav-text"> 遍历栈中元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.9.</span> <span class="nav-text"> 非循环队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.9.1.</span> <span class="nav-text"> 类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.9.2.</span> <span class="nav-text"> 非循环队列的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.9.3.</span> <span class="nav-text"> 清空队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.9.4.</span> <span class="nav-text"> 销毁队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.9.5.</span> <span class="nav-text"> 判断队列是否为空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.9.6.</span> <span class="nav-text"> 计算队列的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.9.7.</span> <span class="nav-text"> 得到队头元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.9.8.</span> <span class="nav-text"> 入队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.9.9.</span> <span class="nav-text"> 出队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.9.10.</span> <span class="nav-text"> 遍历非循环队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.10.</span> <span class="nav-text"> 循环队列（不设头指针）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.10.1.</span> <span class="nav-text"> 类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.10.2.</span> <span class="nav-text"> 循环队列初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.10.3.</span> <span class="nav-text"> 入队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.10.4.</span> <span class="nav-text"> 出队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.10.5.</span> <span class="nav-text"> 遍历循环队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.11.</span> <span class="nav-text"> 循环队列（设头指针）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.11.1.</span> <span class="nav-text"> 类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.11.2.</span> <span class="nav-text"> 队列初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.11.3.</span> <span class="nav-text"> 入队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.11.4.</span> <span class="nav-text"> 出队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.11.5.</span> <span class="nav-text"> 遍历队列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.</span> <span class="nav-text"> 堆串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.1.</span> <span class="nav-text"> 类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.2.</span> <span class="nav-text"> 初始化S为空串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.3.</span> <span class="nav-text"> 生成一个其值等于常量chars的串T</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.4.</span> <span class="nav-text"> 由串S复制得到串T</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.5.</span> <span class="nav-text"> 若S为空串，返回TRUE,否则返回FALSE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.6.</span> <span class="nav-text"> 若S&gt;T，返回值&gt;0；若S&lt;T，返回值&lt;0；否则，返回值=0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.7.</span> <span class="nav-text"> 求串长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.8.</span> <span class="nav-text"> 清空串S</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.9.</span> <span class="nav-text"> 用T返回由S1和S2联接而成的新串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.10.</span> <span class="nav-text"> 用Sub返回串S的第pos个字符起长度为len的子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.11.</span> <span class="nav-text"> 返回T在S中第pos个字符后第一次出现的位置，不存在则返回0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.12.</span> <span class="nav-text"> 用V替换主串S中出现的所有与T相等的不重叠的子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.13.</span> <span class="nav-text"> 在串S的第pos个字符之前插入串T</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.14.</span> <span class="nav-text"> 从串S中删除第pos个字符起长度为len的子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.15.</span> <span class="nav-text"> 销毁串S</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.12.16.</span> <span class="nav-text"> 输出串S</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.13.</span> <span class="nav-text"> 数组和广义表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.13.1.</span> <span class="nav-text"> 类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.13.2.</span> <span class="nav-text"> 三元组顺序表(稀疏矩阵)类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.13.3.</span> <span class="nav-text"> 创建n个矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.13.4.</span> <span class="nav-text"> 销毁矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.13.5.</span> <span class="nav-text"> 输出矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.13.6.</span> <span class="nav-text"> 矩阵的复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.13.7.</span> <span class="nav-text"> 矩阵的加法Q = M + N</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.13.8.</span> <span class="nav-text"> 矩阵的减法Q = M - N</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.13.9.</span> <span class="nav-text"> 矩阵的乘法Q = M * N</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.13.10.</span> <span class="nav-text"> 矩阵转置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.13.11.</span> <span class="nav-text"> 矩阵快速转置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.</span> <span class="nav-text"> 树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.1.</span> <span class="nav-text"> 二叉树（二叉链表存储）相关类型定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.1.1.</span> <span class="nav-text"> 栈元素类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.1.2.</span> <span class="nav-text"> 存储当前结点信息，按树结构打印树的时候使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.2.</span> <span class="nav-text"> 构造空二叉树T (初始化二叉树)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.3.</span> <span class="nav-text"> 清空二叉树T</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.4.</span> <span class="nav-text"> 销毁二叉树T</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.5.</span> <span class="nav-text"> 判断二叉树T是否为空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.6.</span> <span class="nav-text"> 按先序序列构造二叉树_1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.7.</span> <span class="nav-text"> 按先序序列构造二叉树_2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.8.</span> <span class="nav-text"> 返回二叉树长度（按完全二叉树计算）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.9.</span> <span class="nav-text"> 返回二叉树深度（层数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.10.</span> <span class="nav-text"> 用e返回二叉树的根结点值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.11.</span> <span class="nav-text"> 返回某结点的值，p为结点指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.12.</span> <span class="nav-text"> 为某结点赋值，p为结点指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.13.</span> <span class="nav-text"> 返回某结点的双亲结点值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.14.</span> <span class="nav-text"> 返回某结点的左孩子结点值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.15.</span> <span class="nav-text"> 返回某结点的右孩子结点值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.16.</span> <span class="nav-text"> 返回某结点的左兄弟结点值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.17.</span> <span class="nav-text"> 返回某结点的右兄弟结点值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.18.</span> <span class="nav-text"> 获取指向结点e的指针_1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.19.</span> <span class="nav-text"> 获取指向结点e的指针_2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.20.</span> <span class="nav-text"> 将树T0插入到树T中成为结点e的子树，LR为插入标记，T0只有左子树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.21.</span> <span class="nav-text"> 删除e结点的左子树或右子树，LR为删除标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.22.</span> <span class="nav-text"> 层序遍历二叉树_1（利用数组实现）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.23.</span> <span class="nav-text"> 层序遍历二叉树_2（利用队列实现）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.24.</span> <span class="nav-text"> 先序遍历二叉树_1（递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.25.</span> <span class="nav-text"> 先序遍历二叉树_2（递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.26.</span> <span class="nav-text"> 先序遍历二叉树_1（非递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.27.</span> <span class="nav-text"> 先序遍历二叉树_2（非递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.28.</span> <span class="nav-text"> 中序遍历二叉树_1（递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.29.</span> <span class="nav-text"> 中序遍历二叉树_2（非递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.30.</span> <span class="nav-text"> 中序遍历二叉树_3（非递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.31.</span> <span class="nav-text"> 后序遍历二叉树（递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.32.</span> <span class="nav-text"> 后序遍历二叉树_1（非递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.33.</span> <span class="nav-text"> 后序遍历二叉树_2（非递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">3.14.34.</span> <span class="nav-text"> 按二叉树的结构打印树</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text"> 第四章	数据结构算法描述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">4.1.</span> <span class="nav-text"> 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#undefined"><span class="nav-number">4.1.1.</span> <span class="nav-text"> 中缀表达式转换成后缀表达式（逆波兰式），并对逆波兰表达式求值</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DDDANBO</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">64k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点阅读时长">58 分钟</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>




  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
